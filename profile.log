SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/cursor.vim
Sourced 1 time
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
    1              0.000005 scriptencoding utf-8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Author: Jo√£o Paulo S. de Souza <joao.paulo.silvasouza@hotmail.com>
                            " Description: Echoes lint message for the current line, if any
                            
                            " Controls the milliseconds delay before echoing a message.
    1              0.000008 let g:ale_echo_delay = get(g:, 'ale_echo_delay', 10)
                            " A string format for the echoed message.
    1              0.000007 let g:ale_echo_msg_format = get(g:, 'ale_echo_msg_format', '%code: %%s')
                            
    1              0.000004 let s:cursor_timer = -1
    1              0.000004 let s:last_pos = [0, 0, 0]
                            
    1              0.000005 function! ale#cursor#TruncatedEcho(original_message) abort
                                let l:message = a:original_message
                                " Change tabs to spaces.
                                let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
                                let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
                                let l:shortmess_options = &l:shortmess
                            
                                try
                                    let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
                                    silent! setlocal shortmess+=T
                            
                                    try
                                        exec "norm! :echomsg l:message\n"
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
                                    if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
                                    endif
                                finally
                                    let &l:shortmess = l:shortmess_options
                                endtry
                            endfunction
                            
    1              0.000004 function! s:StopCursorTimer() abort
                                if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif
                            endfunction
                            
    1              0.000003 function! ale#cursor#EchoCursorWarning(...) abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if g:ale_echo_cursor
                                    if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
                                endif
                            
                                if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif
                            endfunction
                            
    1              0.000004 function! ale#cursor#EchoCursorWarningWithDelay() abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
                                if l:pos != s:last_pos
                                    let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
                                    let s:last_pos = l:pos
                                    let s:cursor_timer = timer_start(
                                    \   l:delay,
                                    \   function('ale#cursor#EchoCursorWarning')
                                    \)
                                endif
                            endfunction
                            
    1              0.000005 function! s:ShowCursorDetailForItem(loc, options) abort
                                let l:stay_here = get(a:options, 'stay_here', 0)
                            
                                let s:last_detailed_line = line('.')
                                let l:message = get(a:loc, 'detail', a:loc.text)
                                let l:lines = split(l:message, "\n")
                                call ale#preview#Show(l:lines, {'stay_here': l:stay_here})
                            
                                " Clear the echo message if we manually displayed details.
                                if !l:stay_here
                                    execute 'echo'
                                endif
                            endfunction
                            
    1              0.000004 function! ale#cursor#ShowCursorDetail() abort
                                let l:buffer = bufnr('')
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode() isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if !empty(l:loc)
                                    call s:ShowCursorDetailForItem(l:loc, {'stay_here': 0})
                                endif
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale.vim
Sourced 1 time
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>
                            " Description: Primary code path for the plugin
                            "   Manages execution of linters when requested by autocommands
                            
                            " Strings used for severity in the echoed message
    1              0.000010 let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')
    1              0.000007 let g:ale_echo_msg_info_str = get(g:, 'ale_echo_msg_info_str', 'Info')
    1              0.000006 let g:ale_echo_msg_log_str = get(g:, 'ale_echo_msg_log_str', 'Log')
    1              0.000008 let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')
                            " Ignoring linters, for disabling some, or ignoring LSP diagnostics.
    1              0.000007 let g:ale_linters_ignore = get(g:, 'ale_linters_ignore', {})
    1              0.000005 let g:ale_disable_lsp = get(g:, 'ale_disable_lsp', 0)
                            
                            " LSP window/showMessage format
    1              0.000008 let g:ale_lsp_show_message_format = get(g:, 'ale_lsp_show_message_format', '%severity%:%linter%: %s')
                            " Valid values mimic LSP definitions (error, warning and information; log is
                            " never shown)
    1              0.000007 let g:ale_lsp_show_message_severity = get(g:, 'ale_lsp_show_message_severity', 'error')
                            
    1              0.000003 let s:lint_timer = -1
    1              0.000008 let s:getcmdwintype_exists = exists('*getcmdwintype')
                            
                            " Return 1 if a file is too large for ALE to handle.
    1              0.000004 function! ale#FileTooLarge(buffer) abort
                                let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
                                return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0
                            endfunction
                            
                            " A function for checking various conditions whereby ALE just shouldn't
                            " attempt to do anything, say if particular buffer types are open in Vim.
    1              0.000003 function! ale#ShouldDoNothing(buffer) abort
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
                                if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
                                if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for diff buffers.
                                if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
                                if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
                                if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
                                if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
                                if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
                                if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
                                if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
                                if exists(':CtrlPFunky') is 2
                                \&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000005 function! s:Lint(buffer, should_lint_file, timer_id) abort
                                " Use the filetype from the buffer
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
                                let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
                                let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                                let l:linters = !empty(l:ignore_config) || l:disable_lsp
                                \   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)
                                \   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
                                let g:ale_want_results_buffer = a:buffer
                                silent doautocmd <nomodeline> User ALEWantResults
                                unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
                                if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
                                let l:lint_file = empty(l:linters)
                                \   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
                                call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)
                            endfunction
                            
                            " (delay, [linting_flag, buffer_number])
    1              0.000003 function! ale#Queue(delay, ...) abort
                                if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                let l:buffer = get(a:000, 1, v:null)
                            
                                if l:buffer is v:null
                                    let l:buffer = bufnr('')
                                endif
                            
                                if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Default linting_flag to ''
                                let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
                                if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
                                if a:delay > 0
                                    let s:lint_timer = timer_start(
                                    \   a:delay,
                                    \   function('s:Lint', [l:buffer, l:should_lint_file])
                                    \)
                                else
                                    call s:Lint(l:buffer, l:should_lint_file, 0)
                                endif
                            endfunction
                            
    1              0.000005 let s:current_ale_version = [2, 6, 0]
                            
                            " A function used to check for ALE features in files outside of the project.
    1              0.000003 function! ale#Has(feature) abort
                                let l:match = matchlist(a:feature, '\c\v^ale-(\d+)\.(\d+)(\.(\d+))?$')
                            
                                if !empty(l:match)
                                    let l:version = [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
                            
                                    return ale#semver#GTE(s:current_ale_version, l:version)
                                endif
                            
                                return 0
                            endfunction
                            
                            " Given a buffer number and a variable name, look for that variable in the
                            " buffer scope, then in global scope. If the name does not exist in the global
                            " scope, an exception will be thrown.
                            "
                            " Every variable name will be prefixed with 'ale_'.
    1              0.000003 function! ale#Var(buffer, variable_name) abort
                                let l:full_name = 'ale_' . a:variable_name
                                let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
                                return get(l:vars, l:full_name, g:[l:full_name])
                            endfunction
                            
                            " Initialize a variable with a default value, if it isn't already set.
                            "
                            " Every variable name will be prefixed with 'ale_'.
    1              0.000003 function! ale#Set(variable_name, default) abort
                                let l:full_name = 'ale_' . a:variable_name
                            
                                if !has_key(g:, l:full_name)
                                    let g:[l:full_name] = a:default
                                endif
                            endfunction
                            
                            " Given a string for adding to a command, return the string padded with a
                            " space on the left if it is not empty. Otherwise return an empty string.
                            "
                            " This can be used for making command strings cleaner and easier to test.
    1              0.000003 function! ale#Pad(string) abort
                                return !empty(a:string) ? ' ' . a:string : ''
                            endfunction
                            
                            " Given a environment variable name and a value, produce part of a command for
                            " setting an environment variable before running a command. The syntax will be
                            " valid for cmd on Windows, or most shells on Unix.
    1              0.000004 function! ale#Env(variable_name, value) abort
                                if has('win32')
                                    return 'set ' . a:variable_name . '=' . ale#Escape(a:value) . ' && '
                                endif
                            
                                return a:variable_name . '=' . ale#Escape(a:value) . ' '
                            endfunction
                            
                            " Escape a string suitably for each platform.
                            " shellescape does not work on Windows.
    1              0.000003 function! ale#Escape(str) abort
                                if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(
                                    \   a:str =~# ' '
                                    \       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'
                                    \       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),
                                    \   '%',
                                    \   '%%',
                                    \   'g',
                                    \)
                                endif
                            
                                return shellescape (a:str)
                            endfunction
                            
                            " Get the loclist item message according to a given format string.
                            "
                            " See `:help g:ale_loclist_msg_format` and `:help g:ale_echo_msg_format`
    1              0.000003 function! ale#GetLocItemMessage(item, format_string) abort
                                let l:msg = a:format_string
                                let l:severity = g:ale_echo_msg_warning_str
                                let l:code = get(a:item, 'code', '')
                                let l:type = get(a:item, 'type', 'E')
                                let l:linter_name = get(a:item, 'linter_name', '')
                                let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
                                if l:type is# 'E'
                                    let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
                                let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
                                let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
                                let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
                                return l:msg
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/util.vim
Sourced 1 time
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Contains miscellaneous functions
                            
                            " A wrapper function for mode() so we can test calls for it.
    1              0.000005 function! ale#util#Mode(...) abort
                                return call('mode', a:000)
                            endfunction
                            
                            " A wrapper function for feedkeys so we can test calls for it.
    1              0.000003 function! ale#util#FeedKeys(...) abort
                                return call('feedkeys', a:000)
                            endfunction
                            
                            " Show a message in as small a window as possible.
                            "
                            " Vim 8 does not support echoing long messages from asynchronous callbacks,
                            " but NeoVim does. Small messages can be echoed in Vim 8, and larger messages
                            " have to be shown in preview windows.
    1              0.000003 function! ale#util#ShowMessage(string) abort
                                if !has('nvim')
                                    call ale#preview#CloseIfTypeMatches('ale-preview.message')
                                endif
                            
                                " We have to assume the user is using a monospace font.
                                if has('nvim') || (a:string !~? "\n" && len(a:string) < &columns)
                                    execute 'echo a:string'
                                else
                                    call ale#preview#Show(split(a:string, "\n"), {
                                    \   'filetype': 'ale-preview.message',
                                    \   'stay_here': 1,
                                    \})
                                endif
                            endfunction
                            
                            " A wrapper function for execute, so we can test executing some commands.
    1              0.000003 function! ale#util#Execute(expr) abort
                                execute a:expr
                            endfunction
                            
    1              0.000006 if !exists('g:ale#util#nul_file')
                                " A null file for sending output to nothing.
    1              0.000004     let g:ale#util#nul_file = '/dev/null'
                            
    1              0.000007     if has('win32')
                                    let g:ale#util#nul_file = 'nul'
    1              0.000001     endif
    1              0.000002 endif
                            
                            " Given a job, a buffered line of data, a list of parts of lines, a mode data
                            " is being read in, and a callback, join the lines of output for a NeoVim job
                            " or socket together, and call the callback with the joined output.
                            "
                            " Note that jobs and IDs are the same thing on NeoVim.
    1              0.000005 function! ale#util#JoinNeovimOutput(job, last_line, data, mode, callback) abort
                                if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
                                endif
                            
                                let l:lines = a:data[:-2]
                            
                                if len(a:data) > 1
                                    let l:lines[0] = a:last_line . l:lines[0]
                                    let l:new_last_line = a:data[-1]
                                else
                                    let l:new_last_line = a:last_line . get(a:data, 0, '')
                                endif
                            
                                for l:line in l:lines
                                    call a:callback(a:job, l:line)
                                endfor
                            
                                return l:new_last_line
                            endfunction
                            
                            " Return the number of lines for a given buffer.
    1              0.000003 function! ale#util#GetLineCount(buffer) abort
                                return len(getbufline(a:buffer, 1, '$'))
                            endfunction
                            
    1              0.000004 function! ale#util#GetFunction(string_or_ref) abort
                                if type(a:string_or_ref) is v:t_string
                                    return function(a:string_or_ref)
                                endif
                            
                                return a:string_or_ref
                            endfunction
                            
                            " Open the file (at the given line).
                            " options['open_in'] can be:
                            "   current-buffer (default)
                            "   tab
                            "   vertical-split
                            "   horizontal-split
    1              0.000004 function! ale#util#Open(filename, line, column, options) abort
                                let l:open_in = get(a:options, 'open_in', 'current-buffer')
                                let l:args_to_open = '+' . a:line . ' ' . fnameescape(a:filename)
                            
                                if l:open_in is# 'tab'
                                    call ale#util#Execute('tabedit ' . l:args_to_open)
                                elseif l:open_in is# 'horizontal-split'
                                    call ale#util#Execute('split ' . l:args_to_open)
                                elseif l:open_in is# 'vertical-split'
                                    call ale#util#Execute('vsplit ' . l:args_to_open)
                                elseif bufnr(a:filename) isnot bufnr('')
                                    " Open another file only if we need to.
                                    call ale#util#Execute('edit ' . l:args_to_open)
                                else
                                    normal! m`
                                endif
                            
                                call cursor(a:line, a:column)
                                normal! zz
                            endfunction
                            
    1              0.000004 let g:ale#util#error_priority = 5
    1              0.000004 let g:ale#util#warning_priority = 4
    1              0.000003 let g:ale#util#info_priority = 3
    1              0.000004 let g:ale#util#style_error_priority = 2
    1              0.000004 let g:ale#util#style_warning_priority = 1
                            
    1              0.000003 function! ale#util#GetItemPriority(item) abort
                                if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
                                if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority
                            endfunction
                            
                            " Compare two loclist items for ALE, sorted by their buffers, filenames, and
                            " line numbers and column numbers.
    1              0.000004 function! ale#util#LocItemCompare(left, right) abort
                                if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
                                if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
                                if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
                                if a:left.lnum < a:right.lnum
                                    return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Compare two loclist items, including the text for the items.
                            "
                            " This function can be used for de-duplicating lists.
    1              0.000004 function! ale#util#LocItemCompareWithText(left, right) abort
                                let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                            
                                if l:cmp_value
                                    return l:cmp_value
                                endif
                            
                                if a:left.text < a:right.text
                                    return -1
                                endif
                            
                                if a:left.text > a:right.text
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function will perform a binary search and a small sequential search
                            " on the list to find the last problem in the buffer and line which is
                            " on or before the column. The index of the problem will be returned.
                            "
                            " -1 will be returned if nothing can be found.
    1              0.000004 function! ale#util#BinarySearch(loclist, buffer, line, column) abort
                                let l:min = 0
                                let l:max = len(a:loclist) - 1
                            
                                while 1
                                    if l:max < l:min
                                        return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0
                                        \&& a:loclist[l:index - 1].bufnr == a:buffer
                                        \&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile
                            endfunction
                            
                            " A function for testing if a function is running inside a sandbox.
                            " See :help sandbox
    1              0.000002 function! ale#util#InSandbox() abort
                                try
                                    let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
                                return 0
                            endfunction
                            
    1              0.000002 function! ale#util#Tempname() abort
                                let l:clear_tempdir = 0
                            
                                if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
                                try
                                    let l:name = tempname() " no-custom-checks
                                finally
                                    if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
                                endtry
                            
                                return l:name
                            endfunction
                            
                            " Given a single line, or a List of lines, and a single pattern, or a List
                            " of patterns, return all of the matches for the lines(s) from the given
                            " patterns, using matchlist().
                            "
                            " Only the first pattern which matches a line will be returned.
    1              0.000004 function! ale#util#GetMatches(lines, patterns) abort
                                let l:matches = []
                                let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
                                let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
                                for l:line in l:lines
                                    for l:pattern in l:patterns
                                        let l:match = matchlist(l:line, l:pattern)
                            
                                        if !empty(l:match)
                                            call add(l:matches, l:match)
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:matches
                            endfunction
                            
    1              0.000005 function! s:LoadArgCount(function) abort
                                let l:Function = a:function
                            
                                redir => l:output
                                    silent! function Function
                                redir END
                            
                                if !exists('l:output')
                                    return 0
                                endif
                            
                                let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
                                let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
                                return len(l:arg_list)
                            endfunction
                            
                            " Given the name of a function, a Funcref, or a lambda, return the number
                            " of named arguments for a function.
    1              0.000003 function! ale#util#FunctionArgCount(function) abort
                                let l:Function = ale#util#GetFunction(a:function)
                                let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
                                if l:count == 0
                                    let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
                                    if l:function_name =~# '#'
                                        execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
                                        let l:count = s:LoadArgCount(l:Function)
                                    endif
                                endif
                            
                                return l:count
                            endfunction
                            
                            " Escape a string so the characters in it will be safe for use inside of PCRE
                            " or RE2 regular expressions without characters having special meanings.
    1              0.000003 function! ale#util#EscapePCRE(unsafe_string) abort
                                return substitute(a:unsafe_string, '\([\-\[\]{}()*+?.^$|]\)', '\\\1', 'g')
                            endfunction
                            
                            " Escape a string so that it can be used as a literal string inside an evaled
                            " vim command.
    1              0.000003 function! ale#util#EscapeVim(unsafe_string) abort
                                return "'" . substitute(a:unsafe_string, "'", "''", 'g') . "'"
                            endfunction
                            
                            
                            " Given a String or a List of String values, try and decode the string(s)
                            " as a JSON value which can be decoded with json_decode. If the JSON string
                            " is invalid, the default argument value will be returned instead.
                            "
                            " This function is useful in code where the data can't be trusted to be valid
                            " JSON, and where throwing exceptions is mostly just irritating.
    1              0.000004 function! ale#util#FuzzyJSONDecode(data, default) abort
                                if empty(a:data)
                                    return a:default
                                endif
                            
                                let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
                            
                                try
                                    let l:result = json_decode(l:str)
                            
                                    " Vim 8 only uses the value v:none for decoding blank strings.
                                    if !has('nvim') && l:result is v:none
                                        return a:default
                                    endif
                            
                                    return l:result
                                catch /E474/
                                    return a:default
                                endtry
                            endfunction
                            
                            " Write a file, including carriage return characters for DOS files.
                            "
                            " The buffer number is required for determining the fileformat setting for
                            " the buffer.
    1              0.000003 function! ale#util#Writefile(buffer, lines, filename) abort
                                let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                \   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')
                                \   : a:lines
                            
                                call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks
                            endfunction
                            
    1              0.000005 if !exists('s:patial_timers')
    1              0.000004     let s:partial_timers = {}
    1              0.000002 endif
                            
    1              0.000004 function! s:ApplyPartialTimer(timer_id) abort
                                if has_key(s:partial_timers, a:timer_id)
                                    let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
                                    call call(l:Callback, [a:timer_id] + l:args)
                                endif
                            endfunction
                            
                            " Given a delay, a callback, a List of arguments, start a timer with
                            " timer_start() and call the callback provided with [timer_id] + args.
                            "
                            " The timer must not be stopped with timer_stop().
                            " Use ale#util#StopPartialTimer() instead, which can stop any timer, and will
                            " clear any arguments saved for executing callbacks later.
    1              0.000004 function! ale#util#StartPartialTimer(delay, callback, args) abort
                                let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
                                let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
                                return l:timer_id
                            endfunction
                            
    1              0.000004 function! ale#util#StopPartialTimer(timer_id) abort
                                call timer_stop(a:timer_id)
                            
                                if has_key(s:partial_timers, a:timer_id)
                                    call remove(s:partial_timers, a:timer_id)
                                endif
                            endfunction
                            
                            " Given a possibly multi-byte string and a 1-based character position on a
                            " line, return the 1-based byte position on that line.
    1              0.000003 function! ale#util#Col(str, chr) abort
                                if a:chr < 2
                                    return a:chr
                                endif
                            
                                return strlen(join(split(a:str, '\zs')[0:a:chr - 2], '')) + 1
                            endfunction
                            
    1              0.000004 function! ale#util#FindItemAtCursor(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                let l:loclist = get(l:info, 'loclist', [])
                                let l:pos = getpos('.')
                                let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
                                let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
                                return [l:info, l:loc]
                            endfunction
                            
    1              0.000003 function! ale#util#Input(message, value) abort
                                return input(a:message, a:value)
                            endfunction

SCRIPT  /home/kc/.vim/plugged/vista.vim/autoload/vista/sidebar.vim
Sourced 1 time
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
                            " Which filetype the current sidebar should be.
    1              0.000007 function! vista#sidebar#WhichFileType() abort
                              if t:vista.provider ==# 'coc'
                                    \ || (t:vista.provider ==# 'ctags' && g:vista#renderer#ctags ==# 'default')
                                return 'vista'
                              elseif t:vista.provider ==# 'markdown'
                                return 'vista_markdown'
                              else
                                return 'vista_kind'
                              endif
                            endfunction
                            
    1              0.000005 function! s:NewWindow() abort
                              let position = get(g:, 'vista_sidebar_position', 'vertical botright')
                              let width = get(g:, 'vista_sidebar_width', 30)
                              let open = position.' '.width.'new'
                              silent execute open '__vista__'
                            
                              execute 'setlocal filetype='.vista#sidebar#WhichFileType()
                            
                              " FIXME when to delete?
                              if has_key(t:vista.source, 'fpath')
                                let w:vista_first_line_hi_id = matchaddpos('MoreMsg', [1])
                              endif
                            endfunction
                            
                            " Reload vista buffer given the unrendered data
    1              0.000004 function! vista#sidebar#Reload(data) abort
                              " empty(a:data):
                              "   May be triggered by autocmd event sometimes
                              "   e.g., unsupported filetypes for ctags or no related language servers.
                              "
                              " !has_key(t:vista, 'bufnr'):
                              "   May opening a new tab if bufnr does not exist in t:vista.
                              "
                              " t:vista.winnr() == -1:
                              "   vista window is not visible.
                              if empty(a:data)
                                    \ || !has_key(t:vista, 'bufnr')
                                    \ || t:vista.winnr() == -1
                                return
                              endif
                            
                              let rendered = vista#renderer#Render(a:data)
                              call vista#util#SetBufline(t:vista.bufnr, rendered)
                            endfunction
                            
                            " Open or update vista buffer given the rendered rows.
    1              0.000003 function! vista#sidebar#OpenOrUpdate(rows) abort
                              " (Re)open a window and move to it
                              if !exists('t:vista.bufnr')
                                call s:NewWindow()
                                let t:vista = get(t:, 'vista', {})
                                let t:vista.bufnr = bufnr('%')
                                let t:vista.winid = win_getid()
                                let t:vista.pos = [winsaveview(), winnr(), winrestcmd()]
                              else
                                let winnr = t:vista.winnr()
                                if winnr ==  -1
                                  call s:NewWindow()
                                elseif winnr() != winnr
                                  noautocmd execute winnr.'wincmd w'
                                endif
                              endif
                            
                              if exists('#User#VistaWinOpen')
                                doautocmd User VistaWinOpen
                              endif
                            
                              call vista#util#SetBufline(t:vista.bufnr, a:rows)
                            
                              if has_key(t:vista, 'lnum')
                                call vista#cursor#ShowTagFor(t:vista.lnum)
                                unlet t:vista.lnum
                              endif
                            
                              if !get(g:, 'vista_stay_on_open', 1)
                                wincmd p
                              endif
                            endfunction
                            
    1              0.000003 function! vista#sidebar#Close() abort
                              if exists('t:vista.bufnr')
                                let winnr = t:vista.winnr()
                                if winnr != -1
                                  noautocmd execute winnr.'wincmd c'
                                endif
                            
                                " Jump back to the previous window if we are in the vista sidebar atm.
                                if winnr == winnr()
                                  wincmd p
                                endif
                            
                                silent execute  t:vista.bufnr.'bwipe!'
                                unlet t:vista.bufnr
                              endif
                            
                              call s:ClearAugroups('VistaCoc', 'VistaCtags')
                            
                              call vista#GenericCloseOverlay()
                            endfunction
                            
    1              0.000003 function! s:ClearAugroups(...) abort
                              for aug in a:000
                                if exists('#'.aug)
                                  execute 'autocmd!' aug
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! vista#sidebar#Open() abort
                              let [bufnr, winnr, fname, fpath] = [bufnr('%'), winnr(), expand('%'), expand('%:p')]
                              call vista#source#Update(bufnr, winnr, fname, fpath)
                              let executive = vista#GetExplicitExecutiveOrDefault()
                              " Support the builtin markdown toc extension as an executive
                              if vista#SupportToc() && executive ==# 'toc'
                                call vista#extension#{&filetype}#Execute(v:false, v:true)
                              else
                                call vista#executive#{executive}#Execute(v:false, v:true, v:false)
                              endif
                            endfunction
                            
    1              0.000003 function! vista#sidebar#IsVisible() abort
                              return bufwinnr('__vista__') != -1
                            endfunction
                            
    1              0.000003 function! vista#sidebar#ToggleFocus() abort
                              if !exists('t:vista') || t:vista.winnr() == -1
                                call vista#sidebar#Open()
                                return
                              endif
                              let winnr = t:vista.winnr()
                              if winnr != winnr()
                                execute winnr.'wincmd w'
                              else
                                execute t:vista.source.winnr().'wincmd w'
                              endif
                            endfunction
                            
    1              0.000003 function! vista#sidebar#Toggle() abort
                              if vista#sidebar#IsVisible()
                                call vista#sidebar#Close()
                              else
                                call vista#sidebar#Open()
                              endif
                            endfunction

SCRIPT  /home/kc/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim
Sourced 1 time
Total time:   0.000514
 Self time:   0.000514

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
    1              0.000004 scriptencoding utf-8
                            
    1              0.000005 let s:scope_icon = ['‚äï', '‚äñ']
                            
    1              0.000009 let s:visibility_icon = {
                                  \ 'public': '+',
                                  \ 'protected': '~',
                                  \ 'private': '-',
                                  \ }
                            
    1              0.000009 let g:vista_fold_toggle_icons = get(g:, 'vista_fold_toggle_icons', ['‚ñº', '‚ñ∂'])
                            
    1              0.000004 let g:vista#renderer#default#vlnum_offset = 3
                            
                            " Return the rendered row to be displayed given the depth
    1              0.000005 function! s:Assemble(line, depth) abort
                              let line = a:line
                            
                              let kind = get(line, 'kind', '')
                            
                              if !empty(kind)
                                let kind = vista#renderer#Decorate(kind)
                              endif
                            
                              let row = vista#util#Join(
                                    \ repeat(' ', a:depth * 4),
                                    \ s:GetVisibility(line),
                                    \ get(line, 'name'),
                                    \ get(line, 'signature', ''),
                                    \ ' : '.kind,
                                    \ ':'.get(line, 'line', '')
                                    \ )
                            
                              return row
                            endfunction
                            
                            " Actually append to the rows
    1              0.000006 function! s:Append(line, rows, depth) abort
                              let line = a:line
                              let rows = a:rows
                            
                              let row = s:Assemble(line, a:depth)
                            
                              call add(rows, row)
                              call add(s:vlnum_cache, line)
                            endfunction
                            
    1              0.000006 function! s:ApplyAppend(line, row, rows) abort
                              let line = a:line
                              let rows = a:rows
                            
                              call add(rows, a:row)
                              call add(s:vlnum_cache, line)
                            endfunction
                            
    1              0.000005 function! s:Insert(container, key, line) abort
                              if has_key(a:container, a:key)
                                call add(a:container[a:key], a:line)
                              else
                                let a:container[a:key] = [a:line]
                              endif
                            endfunction
                            
                            " Return the next root name and line after appending to the rows.
    1              0.000005 function! s:AppendChild(line, rows, depth) abort
                              if has_key(a:line, 'scope')
                                call s:Append(a:line, a:rows, a:depth)
                                let parent_name = a:line.scope
                                let next_root_name = parent_name . s:scope_seperator . a:line.name
                                return [next_root_name, a:line]
                              endif
                            
                              return [v:null, v:null]
                            endfunction
                            
    1              0.000005 function! s:Compare(s1, s2) abort
                              return a:s1.line - a:s2.line
                            endfunction
                            
                            " This way is more of heuristic.
                            "
                            " the line of child should larger than parent's, which partially fixes this issue comment:
                            " https://github.com/universal-ctags/ctags/issues/2065#issuecomment-485117935
                            "
                            " The previous nearest one should be the exact one.
    1              0.000005 function! s:RealParentOf(candidate) abort
                              let candidate = a:candidate
                            
                              let name = candidate.scope
                              let kind = candidate.scopeKind
                            
                              let parent_candidates = []
                              for pc in t:vista.without_scope
                                if pc.name ==# name && pc.kind ==# kind && pc.line <= candidate.line
                                  call add(parent_candidates, pc)
                                endif
                              endfor
                            
                              if !empty(parent_candidates)
                                call sort(parent_candidates, function('s:Compare'))
                                return parent_candidates[-1]
                              endif
                            
                              return {}
                            endfunction
                            
                            " Previously we use the regexp to see if the scope of candidate is matched:
                            "
                            " \ ' && v:val.scope =~# ''^''.l:scope'.
                            "
                            " but it runs into the error like NFA E869 '\@ ' in some cases, so we use this
                            " now. Ref #161
    1              0.000006 function! s:StartWith(candidate_scope, root_scope) abort
                              return a:candidate_scope[:len(a:root_scope)] == a:root_scope
                            endfunction
                            
                            " Find all descendants of the root
    1              0.000006 function! s:DescendantsOf(candidates, root_line, scope) abort
                              let candidates = filter(copy(a:candidates),
                                    \ 'has_key(v:val, ''scope'')'.
                                    \ ' && s:StartWith(v:val.scope, a:scope)'.
                                    \ ' && v:val.scopeKind ==# a:root_line.kind'.
                                    \ ' && v:val.line >= a:root_line.line'
                                    \ )
                            
                              return candidates
                              " The real parent problem seemingly has been solved?
                              " return filter(candidates, 's:RealParentOf(v:val) ==# a:root_line')
                            endfunction
                            
    1              0.000005 function! s:DescendantsOfRoot(candidates, root_line) abort
                              let candidates = filter(copy(a:candidates),
                                    \ 'has_key(v:val, ''scope'')'.
                                    \ ' && s:StartWith(v:val.scope, a:root_line.name)'.
                                    \ ' && v:val.scopeKind ==# a:root_line.kind'.
                                    \ ' && v:val.line >= a:root_line.line'
                                    \ )
                            
                              return filter(candidates, 's:RealParentOf(v:val) ==# a:root_line')
                            endfunction
                            
    1              0.000007 function! s:RenderDescendants(parent_name, parent_line, descendants, rows, depth) abort
                              let depth = a:depth
                              let rows = a:rows
                            
                              " Clear the previous duplicate parent line that is about to be added.
                              "
                              " This is a little bit stupid actually :(.
                              let about_to_append = s:Assemble(a:parent_line, depth)
                              let idx = 0
                              while idx < len(rows)
                                if rows[idx] ==# about_to_append
                                  unlet rows[idx]
                                  unlet s:vlnum_cache[idx]
                                endif
                                let idx += 1
                              endwhile
                            
                              " Append the root actually
                              call s:ApplyAppend(a:parent_line, about_to_append, rows)
                            
                              let depth += 1
                            
                              " find all the children
                              let children = filter(copy(a:descendants), 'v:val.scope ==# a:parent_name')
                            
                              let grandchildren = []
                              let grandchildren_line = []
                            
                              for child in children
                                let [next_potentioal_root, next_potentioal_root_line] = s:AppendChild(child, rows, depth)
                                if !empty(next_potentioal_root)
                                  call add(grandchildren, next_potentioal_root)
                                  call add(grandchildren_line, next_potentioal_root_line)
                                endif
                              endfor
                            
                              let idx = 0
                              while idx < len(grandchildren)
                                let child_name = grandchildren[idx]
                                let child_line = grandchildren_line[idx]
                            
                                let descendants = s:DescendantsOf(t:vista.with_scope, child_line, child_name)
                            
                                if !empty(descendants)
                                  call s:RenderDescendants(child_name, child_line, descendants, a:rows, depth)
                                endif
                            
                                let idx += 1
                              endwhile
                            endfunction
                            
    1              0.000005 function! s:GetVisibility(line) abort
                              return has_key(a:line, 'access') ? get(s:visibility_icon, a:line.access, '?') : ''
                            endfunction
                            
    1              0.000005 function! s:SortCompare(i1, i2) abort
                              return a:i1.name > a:i2.name
                            endfunction
                            
    1              0.000005 function! s:RenderScopeless(scope_less, rows) abort
                              let rows = a:rows
                              let scope_less = a:scope_less
                            
                              for kind in keys(scope_less)
                                let kind_line = vista#renderer#Decorate(kind)
                                call add(rows, g:vista_fold_toggle_icons[0].' '.kind_line)
                            
                                let lines = scope_less[kind]
                            
                                if get(t:vista, 'sort', v:false)
                                  let lines = sort(copy(lines), function('s:SortCompare'))
                                endif
                            
                                for line in lines
                                  let row = vista#util#Join(
                                        \ '  '.s:GetVisibility(line),
                                        \ get(line, 'name'),
                                        \ get(line, 'signature', ''),
                                        \ ':'.line.line
                                        \ )
                            
                                  call add(rows, row)
                            
                                  let line.vlnum = len(rows) + 2
                                endfor
                            
                                call add(rows, '')
                                call add(s:vlnum_cache, '')
                              endfor
                            
                              " Remove the last line if it's empty, i.e., ''
                              if !empty(rows) && empty(rows[-1])
                                unlet rows[-1]
                              endif
                            endfunction
                            
    1              0.000004 function! s:Render() abort
                              let s:scope_seperator = t:vista.source.scope_seperator()
                            
                              let rows = []
                            
                              " s:vlnum_cache is a cache for recording which original tagline
                              " is related to the line in the vista sidebar, for we have to
                              " remove the duplicate parents which leads to reassign the lnum
                              " to the original tagline.
                              "
                              " The item of s:vlnum_cache is some original tagline dict with
                              " `vlnum` field added later.
                              let s:vlnum_cache = []
                            
                              let scope_less = {}
                            
                              let without_scope = t:vista.without_scope
                            
                              " The root of hierarchy structure doesn't have scope field.
                              for potential_root_line in without_scope
                            
                                let root_name = potential_root_line.name
                            
                                let descendants = s:DescendantsOfRoot(t:vista.with_scope, potential_root_line)
                            
                                if !empty(descendants)
                            
                                  call s:RenderDescendants(root_name, potential_root_line, descendants, rows, 0)
                            
                                  call add(rows, '')
                                  call add(s:vlnum_cache, '')
                            
                                else
                            
                                  if has_key(potential_root_line, 'kind')
                                    call s:Insert(scope_less, potential_root_line.kind, potential_root_line)
                                  endif
                            
                                endif
                            
                              endfor
                            
                              call s:RenderScopeless(scope_less, rows)
                            
                              " The original tagline is positioned in which line in the vista sidebar.
                              let idx = 0
                              while idx < len(s:vlnum_cache)
                                if !empty(s:vlnum_cache[idx])
                                  " idx is 0-based, while the line number is 1-based, and we prepend the
                                  " two lines first, so the final offset is 1+2=3
                                  let s:vlnum_cache[idx].vlnum = idx + g:vista#renderer#default#vlnum_offset
                                endif
                                let idx += 1
                              endwhile
                            
                              let t:vista.vlnum_cache = s:vlnum_cache
                            
                              return rows
                            endfunction
                            
    1              0.000006 function! vista#renderer#default#Render() abort
                              if empty(t:vista.raw)
                                return []
                              endif
                            
                              return s:Render()
                            endfunction

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/file.vim
Sourced 1 time
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
                            "=============================================
                            "    Name: file.vim
                            "    File: file.vim
                            " Summary: file operation
                            "          find /match/delete/
                            "  Author: Rykka G.F
                            "  Update: 2012-10-04
                            "=============================================
    1              0.000014 let s:cpo_save = &cpo
    1              0.000021 set cpo-=C
                            
    1              0.000006 let s:p = g:_riv_p
                            
    1              0.000005 fun! riv#file#edit(file) "{{{
                                " edit file with it's full absolute path.
                                let file = a:file
                                if riv#path#is_relative(file)
                                    let file = riv#path#join(expand('%:p:h'), file)
                                endif
                                exe "edit ".file
                            endfun "}}}
    1              0.000003 fun! riv#file#split(file) "{{{
                                let file = a:file
                                if riv#path#is_relative(file)
                                    let file = riv#path#join(expand('%:p:h'), file)
                                endif
                                exe "split " file
                            endfun "}}}
                            
                            " Helper:  "{{{1
    1              0.000002 fun! riv#file#update() "{{{
                                let s:prev = expand('%:p')
                            endfun "}}}
                            
    1              0.000003 fun! riv#file#enter() "{{{
                                let file = matchstr(getline('.'),  '\S\+$')
                                let file = s:path.file
                                if s:file.exit()
                                    call riv#file#edit(file)
                                else
                                    call riv#file#split(file)
                                endif
                            endfun "}}}
    1              0.000002 fun! riv#file#syn_hi() "{{{
                                syn clear
                                syn match rivFile '\S\+$'
                                syn match rivType '^\u\+\s'
                                hi link rivFile Function
                                hi link rivType Include
                            endfun "}}}
                            
    1              0.000007 if has("signs") "{{{
    1              0.000045     sign define riv_root text=RT texthl=Question
    1              0.000030     sign define riv_indx text=IN texthl=Question
    1              0.000026     sign define riv_prev text=PR texthl=Question
    1              0.000025     sign define riv_curr text=CR texthl=Question
    1              0.000002 endif "}}}
                            
    1              0.000006 let s:prev = exists("s:prev") ? s:prev : ''
    1              0.000005 let s:curr = exists("s:curr") ? s:curr : ''
    1              0.000005 let s:path = exists("s:path") ? s:path : ''
    1              0.000005 fun! s:load_file() "{{{
                            
                                let file = expand('%:p')
                                let s:curr=file
                                let root = riv#path#root()
                                let s:path = riv#path#directory(expand('%:p:h'))
                                let dir = riv#path#directory(fnamemodify(file, ':h'))
                                let has_sign =  has("signs") ? 1 : 0
                                let signs = []
                                try 
                                    if riv#path#is_rel_to(root, file )
                                        let files = split(glob(dir.'**/*'.riv#path#ext()),'\n')
                                        let index = riv#path#idx_file() 
                                        let index = has_sign ? index : printf("%s %s",'INDX',index)
                                        let root = riv#path#rel_to(dir,root)
                                                    \.riv#path#idx_file()
                                        let root =  has_sign ? root : printf("%s %s",'ROOT',root)
                                    else
                                        let files = split(glob(dir.'*'.riv#path#ext()),'\n')
                                    endif
                                    let cur = riv#path#rel_to(dir, file)
                                    let current = has_sign ? cur : printf("%s %s", 'CURR',cur)
                                    if has_sign
                                        let files =  map(files,'riv#path#rel_to(dir,v:val)')
                                        let files =  filter(files,'v:val!= cur')
                                    else
                                        let files =  map(files,'"     ".riv#path#rel_to(dir,v:val)')
                                        let files =  filter(files,'v:val!= "    ".cur')
                                    endif
                                    call insert(files,current)
                                    call insert(signs,'riv_curr')
                                    if !empty(s:prev)
                                        let prev = riv#path#rel_to(dir, s:prev)
                                        let prev = has_sign ? prev : printf("%s %s", 'PREV',prev)
                                        call insert(files,prev)
                                        call insert(signs,'riv_prev')
                                    endif
                                catch 
                                    if v:exception == g:_riv_e.NOT_REL_PATH
                                    endif
                                endtry
                                if exists("index")
                                    call insert(files,index)
                                    call insert(signs,'riv_indx')
                                    call insert(files,root)
                                    call insert(signs,'riv_root')
                                endif
                                return [files,signs]
                            endfun "}}}
    1              0.000006 fun! riv#file#helper() "{{{
                                if empty(&ft)
                                    call riv#warning(g:_riv_e.NOT_RST_FILE)
                                    return
                                endif
                                let [files,signs] = s:load_file()
                                let s:file = riv#helper#new()
                                let s:file.content_title = "Files"
                                let s:file.contents = [files]
                                let s:file.contents_name = ['files']
                            
                                let s:file.signs = signs
                            
                                let s:file.maps['<Enter>'] = ':cal riv#file#enter()<CR>'
                                let s:file.maps['<KEnter>'] = ':cal riv#file#enter()<CR>'
                                let s:file.maps['<2-leftmouse>'] = ':cal riv#file#enter()<CR>'
                                let s:file.syntax_func  = 'riv#file#syn_hi'
                                let s:file.input=""
                                cal s:file.win('vI')
                            endfun "}}}
                            
    1              0.000004 fun! s:find_sect(ptn) "{{{
                                if exists("b:riv_state.sectmatcher")
                                    for sect in b:riv_state.sectmatcher
                                        let line = getline(sect.bgn) 
                                        if line =~ g:_riv_p.section
                                            let line = getline(sect.bgn+1)
                                        endif
                                        if line =~ a:ptn
                                            return sect.bgn
                                        endif
                                    endfor
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#file#s_enter() "{{{
                                if foldclosed('.') != -1
                                    normal! zv
                                    return
                                endif
                                let sect = matchstr(getline('.'),  ':\s*\zs.*$')
                                if s:sect.exit()
                                    let text = substitute(riv#ptn#escape(sect),'\s\+','\\s+','g')
                                    let ptn = '^\v\c\s*'.text.'\s*$'
                                    let row = s:find_sect(ptn)
                                    if row > 0
                                        call setpos("'`",getpos('.'))
                                        call cursor(row,0)
                                        normal! zvzt
                                    endif
                                else
                                    call riv#warning(g:_riv_e.FILE_NOT_FOUND)
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#file#s_syn_hi() "{{{
                                syn clear
                                let punc = g:riv_fold_section_mark
                                exe 'syn match rivNumber `^[0-9'.punc.']\+:`'
                                syn match rivSection ':\@<=.*$'
                                hi link rivSection Include
                                hi link rivNumber Function
                                
                                setl foldmethod=expr fdl=0 foldexpr=riv#file#s_fold(v:lnum)
                                setl foldtext=getline(v:foldstart)
                            endfun "}}}
    1              0.000003 function! riv#file#s_fold(row) "{{{
                                let sect_txt = matchstr(getline(a:row),  '^\S*\ze:')
                                let level = len(split(sect_txt, g:riv_fold_section_mark))
                                return '>'.level
                            endfunction "}}}
                            
    1              0.000003 fun! s:load_sect() "{{{
                                if !exists("b:riv_state")
                                    return []
                                endif
                                let lines = []
                                let s:curr=expand('%:p')
                                for sect in b:riv_state.sectmatcher
                                    let line =  getline(sect.bgn) 
                                    if line =~ g:_riv_p.section
                                        let line = getline(sect.bgn+1)
                                    endif
                                    let line = printf("%-10s %s",sect.txt.':', line)
                                    call add(lines, line)
                                endfor
                                return lines
                            endfun "}}}
                            
    1              0.000003 fun! riv#file#section_helper() "{{{
                                if &ft!='rst'
                                    call riv#warning(g:_riv_e.NOT_RST_FILE)
                                    return
                                endif
                            
                                let sects = s:load_sect()
                                let s:sect = riv#helper#new()
                                let s:sect.content_title = "Section"
                                let s:sect.contents = [sects]
                                let s:sect.contents_name = ['Section']
                                let s:sect.signs = []
                            
                                let s:sect.maps['<Enter>'] = ':cal riv#file#s_enter()<CR>'
                                let s:sect.maps['<KEnter>'] = ':cal riv#file#s_enter()<CR>'
                                let s:sect.maps['<2-leftmouse>'] = ':cal riv#file#s_enter()<CR>'
                                let s:sect.syntax_func  = "riv#file#s_syn_hi"
                                let s:sect.input=""
                                cal s:sect.win('vI')
                                
                            endfun "}}}
                            
    1              0.000017 if expand('<sfile>:p') == expand('%:p') "{{{
                                call doctest#start()
    1              0.000002 endif "}}}
                            
    1              0.000016 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /usr/share/vim/vim81/scripts.vim
Sourced 2 times
Total time:   0.002501
 Self time:   0.002501

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2019 Jun 25
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    2              0.000013 if did_filetype()
                              finish
    2              0.000004 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    2              0.000017 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    2              0.000003 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000038 let s:cpo_save = &cpo
    2              0.000042 set cpo&vim
                            
    2              0.000016 let s:line1 = getline(1)
                            
    2              0.000015 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
    2              0.000004 else
                              " File does not start with "#!".
                            
    2              0.000009   let s:line2 = getline(2)
    2              0.000008   let s:line3 = getline(3)
    2              0.000009   let s:line4 = getline(4)
    2              0.000008   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    2              0.000011   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    2              0.000065   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    2              0.000036   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    2              0.000012   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    2              0.000011   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    2              0.000014   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    2              0.000033   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    2              0.000173   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    2              0.000012   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    2              0.000040   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    2              0.000010   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    2              0.000014   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    2              0.000013   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    2              0.000012   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    2              0.000013   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    2              0.000022   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    2              0.000010   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    2              0.000029   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    2              0.000021   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    2              0.000018   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    2              0.000009   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    2              0.000009   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    2              0.000105   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    2              0.000019   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    2              0.000028   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    2              0.000048   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    2              0.000045   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    2              0.000018   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    2              0.000021   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    2              0.000018   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    2              0.000014   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    2              0.000014   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    2              0.000081   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    2              0.000054   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    2              0.000027   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    2              0.000015   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    2              0.000011   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    2              0.000024   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    2              0.000051   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    2              0.000032    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    2              0.000033   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
    2              0.000003   else
    2              0.000008     let s:lnum = 1
    2              0.000016     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    2              0.000004     endwhile
    2              0.000015     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    2              0.000050     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    2              0.000003     endif
    2              0.000006     unlet s:lnum
                            
    2              0.000003   endif
                            
    2              0.000009   unlet s:line2 s:line3 s:line4 s:line5
                            
    2              0.000003 endif
                            
                            " Restore 'cpoptions'
    2              0.000035 let &cpo = s:cpo_save
                            
    2              0.000012 unlet s:cpo_save s:line1

SCRIPT  /home/kc/.vim/plugged/vista.vim/syntax/vista.vim
Sourced 2 times
Total time:   0.001411
 Self time:   0.001411

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
    2              0.000026 if exists('b:current_syntax') && b:current_syntax ==# 'vista'
                              finish
    2              0.000004 endif
                            
    2              0.000065 let icons = join(values(g:vista#renderer#icons), '\|')
    2              0.000111 execute 'syntax match VistaIcon' '/'.icons.'/' 'contained'
                            
    2              0.000040 syntax match VistaPublic /^\s*+\</ contained
    2              0.000033 syntax match VistaProtected /^\s*\~\</ contained
    2              0.000034 syntax match VistaPrivate /^\s*-\</ contained
                            
    2              0.000032 syntax match VistaParenthesis /(\|)/ contained
    2              0.000035 syntax match VistaArgs  /(\zs.*\ze)/
    2              0.000035 syntax match VistaColon /:\ze\d\+$/ contained
    2              0.000034 syntax match VistaLineNr /\d\+$/
    2              0.000045 syntax match VistaKind / \a*:\d*$/ contains=VistaColon,VistaLineNr
    2              0.000044 syntax match VistaScopeKind /: .*$/ contains=VistaArgs,VistaColon,VistaLineNr
    2              0.000094 syntax match VistaScope /^\S.*$/ contains=VistaPrivate,VistaProtected,VistaPublic,VistaKind,VistaIcon,VistaParenthesis
    2              0.000074 syntax region VistaTag start="^" end="$" contains=VistaPublic,VistaProtected,VistaPrivate,VistaArgs,VistaScope,VistaScopeKind,VistaLineNr,VistaColon
                            
    2              0.000085 hi default link VistaParenthesis Operator
    2              0.000067 hi default link VistaScope       Function
    2              0.000055 hi default link VistaTag         Keyword
    2              0.000054 hi default link VistaKind        Type
    2              0.000054 hi default link VistaScopeKind   Define
    2              0.000063 hi default link VistaLineNr      LineNr
    2              0.000057 hi default link VistaColon       SpecialKey
    2              0.000066 hi default link VistaIcon        StorageClass
    2              0.000055 hi default link VistaArgs        Comment
                            
    2              0.000013 hi default VistaPublic     guifg=Green  ctermfg=Green
    2              0.000008 hi default VistaProtected  guifg=Yellow ctermfg=Yellow
    2              0.000010 hi default VistaPrivate    guifg=Red    ctermfg=Red
                            
                            " Do not touch the global highlight group.
                            " hi! link Folded Function
                            
    2              0.000025 if has('nvim')
                              call setwinvar(winnr(), '&winhl', 'Folded:Function')
    2              0.000005 endif
                            
    2              0.000025 let b:current_syntax = 'vista'

SCRIPT  /home/kc/.vim/plugged/vista.vim/autoload/vista/ftplugin.vim
Sourced 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
                            " If we use ftplugin/vista.vim, ftplugin/vista_kind.vim, etc, everytime we'll
                            " need this:
                            "
                            " No usual did_ftplugin check here
                            "
                            " So we could just use a function to set the buffer local settings.
                            
    1              0.000007 function! vista#ftplugin#Set() abort
                              setlocal
                                \ nonumber
                                \ norelativenumber
                                \ nopaste
                                \ nomodeline
                                \ noswapfile
                                \ nocursorline
                                \ nocursorcolumn
                                \ colorcolumn=
                                \ nobuflisted
                                \ buftype=nofile
                                \ bufhidden=hide
                                \ nomodifiable
                                \ signcolumn=no
                                \ textwidth=0
                                \ nolist
                                \ winfixwidth
                                \ winfixheight
                                \ nospell
                                \ nofoldenable
                                \ foldcolumn=0
                                \ nowrap
                            
                              setlocal foldmethod=expr
                              setlocal foldexpr=vista#fold#Expr()
                              setlocal foldtext=vista#fold#Text()
                            
                              if !vista#statusline#ShouldDisable()
                                let &l:statusline = vista#statusline#()
                              endif
                            
                              nnoremap <buffer> <silent> q    :close<CR>
                              nnoremap <buffer> <silent> <CR> :<c-u>call vista#cursor#FoldOrJump()<CR>
                              nnoremap <buffer> <silent> s    :<c-u>call vista#Sort()<CR>
                              nnoremap <buffer> <silent> p    :<c-u>call vista#cursor#TogglePreview()<CR>
                            
                              augroup VistaCursor
                                autocmd!
                                if get(g:, 'vista_echo_cursor', 1)
                                  autocmd CursorMoved <buffer> call vista#cursor#ShowDetailWithDelay()
                                endif
                                autocmd BufLeave <buffer> call vista#floating#Close()
                              augroup END
                            
                              if !exists('#VistaMOF')
                                call vista#autocmd#InitMOF()
                              endif
                            endfunction

SCRIPT  /home/kc/.vim/plugged/vista.vim/syntax/vista_markdown.vim
Sourced 1 time
Total time:   0.000698
 Self time:   0.000698

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
    1              0.000010 if exists('b:current_syntax') && b:current_syntax ==# 'vista_markdown'
                              finish
    1              0.000002 endif
                            
    1              0.000009 syntax match VistaColon /:/ contained
    1              0.000006 syntax match VistaLineNr /\d\+$/
                            
    1              0.000048 syntax match VistaHeadNr /H1\|H2\|H3\|H4\|H5\|H6:\d\+$/ contains=VistaLineNr contained
                            
    1              0.000055 syntax match VistaH1 /.*H1/ contains=VistaColon,VistaLineNr,VistaHeadNr
    1              0.000046 syntax match VistaH2 /.*H2/ contains=VistaColon,VistaLineNr,VistaHeadNr
    1              0.000031 syntax match VistaH3 /.*H3/ contains=VistaColon,VistaLineNr,VistaHeadNr
    1              0.000034 syntax match VistaH4 /.*H4/ contains=VistaColon,VistaLineNr,VistaHeadNr
    1              0.000068 syntax match VistaH5 /.*H5/ contains=VistaColon,VistaLineNr,VistaHeadNr
    1              0.000048 syntax match VistaH6 /.*H6/ contains=VistaColon,VistaLineNr,VistaHeadNr
                            
    1              0.000031 hi default link VistaColon       SpecialKey
    1              0.000029 hi default link VistaLineNr      LineNr
    1              0.000029 hi default link VistaHeadNr      Comment
                            
    1              0.000068 highlight default link VistaH1 markdownH1
    1              0.000020 highlight default link VistaH2 markdownH2
    1              0.000018 highlight default link VistaH3 markdownH3
    1              0.000059 highlight default link VistaH4 markdownH4
    1              0.000028 highlight default link VistaH5 markdownH5
    1              0.000021 highlight default link VistaH6 markdownH6
                            
    1              0.000016 let b:current_syntax = 'vista_markdown'

SCRIPT  /home/kc/.vim/plugged/vista.vim/autoload/vista/fold.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
                            " Treat the number of heading whitespaces as indent level
    1              0.000006 function! s:HeadingWhitespaces(line) abort
                              return strlen(matchstr(a:line,'\v^\s+'))
                            endfunction
                            
    1              0.000003 function! vista#fold#Expr() abort
                              if getline(v:lnum) =~# '^$'
                                return 0
                              endif
                            
                              let cur_indent = s:HeadingWhitespaces(getline(v:lnum))
                              let next_indent = s:HeadingWhitespaces(getline(v:lnum+1))
                            
                              if cur_indent < next_indent
                                return '>'.next_indent
                              else
                                return cur_indent
                              endif
                            endfunction
                            
    1              0.000002 function! vista#fold#Text() abort
                              let line = getline(v:foldstart)
                            
                              " Foldtext ignores tabstop and shows tabs as one space,
                              " so convert tabs to 'tabstop' spaces, then text lines up.
                              let spaces = repeat(' ', &tabstop)
                              let line = substitute(line, '\t', spaces, 'g')
                              let line = substitute(line, g:vista_fold_toggle_icons[0], g:vista_fold_toggle_icons[1], '')
                            
                              return line
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/linter.vim
Sourced 1 time
Total time:   0.000694
 Self time:   0.000694

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Linter registration and lazy-loading
                            "   Retrieves linters as requested by the engine, loading them if needed.
                            
    1              0.000006 let s:runtime_loaded_map = {}
    1              0.000003 let s:linters = {}
                            
                            " Default filetype aliases.
                            " The user defined aliases will be merged with this Dictionary.
                            "
                            " NOTE: Update the g:ale_linter_aliases documentation when modifying this.
    1              0.000037 let s:default_ale_linter_aliases = {
                            \   'Dockerfile': 'dockerfile',
                            \   'csh': 'sh',
                            \   'javascriptreact': ['javascript', 'jsx'],
                            \   'plaintex': 'tex',
                            \   'rmarkdown': 'r',
                            \   'rmd': 'r',
                            \   'systemverilog': 'verilog',
                            \   'typescriptreact': ['typescript', 'tsx'],
                            \   'verilog_systemverilog': ['verilog_systemverilog', 'verilog'],
                            \   'vimwiki': 'markdown',
                            \   'vue': ['vue', 'javascript'],
                            \   'xsd': ['xsd', 'xml'],
                            \   'xslt': ['xslt', 'xml'],
                            \   'zsh': 'sh',
                            \}
                            
                            " Default linters to run for particular filetypes.
                            " The user defined linter selections will be merged with this Dictionary.
                            "
                            " No linters are used for plaintext files by default.
                            "
                            " Only cargo is enabled for Rust by default.
                            " rpmlint is disabled by default because it can result in code execution.
                            " hhast is disabled by default because it executes code in the project root.
                            "
                            " NOTE: Update the g:ale_linters documentation when modifying this.
    1              0.000027 let s:default_ale_linters = {
                            \   'csh': ['shell'],
                            \   'elixir': ['credo', 'dialyxir', 'dogma'],
                            \   'go': ['gofmt', 'golint', 'go vet'],
                            \   'hack': ['hack'],
                            \   'help': [],
                            \   'perl': ['perlcritic'],
                            \   'perl6': [],
                            \   'python': ['flake8', 'mypy', 'pylint'],
                            \   'rust': ['cargo'],
                            \   'spec': [],
                            \   'text': [],
                            \   'vue': ['eslint', 'vls'],
                            \   'zsh': ['shell'],
                            \}
                            
                            " Testing/debugging helper to unload all linters.
    1              0.000004 function! ale#linter#Reset() abort
                                let s:runtime_loaded_map = {}
                                let s:linters = {}
                            endfunction
                            
                            " Return a reference to the linters loaded.
                            " This is only for tests.
                            " Do not call this function.
    1              0.000003 function! ale#linter#GetLintersLoaded() abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                return s:linters
                            endfunction
                            
    1              0.000005 function! s:IsCallback(value) abort
                                return type(a:value) is v:t_string || type(a:value) is v:t_func
                            endfunction
                            
    1              0.000004 function! s:IsBoolean(value) abort
                                return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)
                            endfunction
                            
    1              0.000004 function! s:LanguageGetter(buffer) dict abort
                                return l:self.language
                            endfunction
                            
    1              0.000004 function! ale#linter#PreProcess(filetype, linter) abort
                                if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
                                endif
                            
                                let l:obj = {
                                \   'name': get(a:linter, 'name'),
                                \   'lsp': get(a:linter, 'lsp', ''),
                                \}
                            
                                if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
                                endif
                            
                                let l:needs_address = l:obj.lsp is# 'socket'
                                let l:needs_executable = l:obj.lsp isnot# 'socket'
                                let l:needs_command = l:obj.lsp isnot# 'socket'
                                let l:needs_lsp_details = !empty(l:obj.lsp)
                            
                                if empty(l:obj.lsp)
                                    let l:obj.callback = get(a:linter, 'callback')
                            
                                    if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
                                    endif
                                endif
                            
                                if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
                                endif
                            
                                if !l:needs_executable
                                    if has_key(a:linter, 'executable')
                                    \|| has_key(a:linter, 'executable_callback')
                                        throw '`executable` and `executable_callback` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'executable_callback')
                                    let l:obj.executable_callback = a:linter.executable_callback
                            
                                    if !s:IsCallback(l:obj.executable_callback)
                                        throw '`executable_callback` must be a callback if defined'
                                    endif
                                elseif has_key(a:linter, 'executable')
                                    let l:obj.executable = a:linter.executable
                            
                                    if type(l:obj.executable) isnot v:t_string
                                    \&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
                                    endif
                                else
                                    throw 'Either `executable` or `executable_callback` must be defined'
                                endif
                            
                                if !l:needs_command
                                    if has_key(a:linter, 'command')
                                    \|| has_key(a:linter, 'command_callback')
                                    \|| has_key(a:linter, 'command_chain')
                                        throw '`command` and `command_callback` and `command_chain` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'command_chain')
                                    let l:obj.command_chain = a:linter.command_chain
                            
                                    if type(l:obj.command_chain) isnot v:t_list
                                        throw '`command_chain` must be a List'
                                    endif
                            
                                    if empty(l:obj.command_chain)
                                        throw '`command_chain` must contain at least one item'
                                    endif
                            
                                    let l:link_index = 0
                            
                                    for l:link in l:obj.command_chain
                                        let l:err_prefix = 'The `command_chain` item ' . l:link_index . ' '
                            
                                        if !s:IsCallback(get(l:link, 'callback'))
                                            throw l:err_prefix . 'must define a `callback` function'
                                        endif
                            
                                        if has_key(l:link, 'output_stream')
                                            if type(l:link.output_stream) isnot v:t_string
                                            \|| index(['stdout', 'stderr', 'both'], l:link.output_stream) < 0
                                                throw l:err_prefix . '`output_stream` flag must be '
                                                \   . "'stdout', 'stderr', or 'both'"
                                            endif
                                        endif
                            
                                        if has_key(l:link, 'read_buffer') && !s:IsBoolean(l:link.read_buffer)
                                            throw l:err_prefix . 'value for `read_buffer` must be `0` or `1`'
                                        endif
                            
                                        let l:link_index += 1
                                    endfor
                                elseif has_key(a:linter, 'command_callback')
                                    let l:obj.command_callback = a:linter.command_callback
                            
                                    if !s:IsCallback(l:obj.command_callback)
                                        throw '`command_callback` must be a callback if defined'
                                    endif
                                elseif has_key(a:linter, 'command')
                                    let l:obj.command = a:linter.command
                            
                                    if type(l:obj.command) isnot v:t_string
                                    \&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
                                    endif
                                else
                                    throw 'Either `command`, `executable_callback`, `command_chain` '
                                    \   . 'must be defined'
                                endif
                            
                                if (
                                \   has_key(a:linter, 'command')
                                \   + has_key(a:linter, 'command_chain')
                                \   + has_key(a:linter, 'command_callback')
                                \) > 1
                                    throw 'Only one of `command`, `command_callback`, or `command_chain` '
                                    \   . 'should be set'
                                endif
                            
                                if !l:needs_address
                                    if has_key(a:linter, 'address') || has_key(a:linter, 'address_callback')
                                        throw '`address` or `address_callback` cannot be used when lsp != ''socket'''
                                    endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string
                                    \&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                                elseif has_key(a:linter, 'address_callback')
                                    let l:obj.address_callback = a:linter.address_callback
                            
                                    if !s:IsCallback(l:obj.address_callback)
                                        throw '`address_callback` must be a callback if defined'
                                    endif
                                else
                                    throw '`address` or `address_callback` must be defined for getting the LSP address'
                                endif
                            
                                if l:needs_lsp_details
                                    if has_key(a:linter, 'language_callback')
                                        if has_key(a:linter, 'language')
                                            throw 'Only one of `language` or `language_callback` '
                                            \   . 'should be set'
                                        endif
                            
                                        let l:obj.language_callback = get(a:linter, 'language_callback')
                            
                                        if !s:IsCallback(l:obj.language_callback)
                                            throw '`language_callback` must be a callback for LSP linters'
                                        endif
                                    else
                                        " Default to using the filetype as the language.
                                        let l:Language = get(a:linter, 'language', a:filetype)
                            
                                        if type(l:Language) is v:t_string
                                            " Make 'language_callback' return the 'language' value.
                                            let l:obj.language = l:Language
                                            let l:obj.language_callback = function('s:LanguageGetter')
                                        elseif type(l:Language) is v:t_func
                                            let l:obj.language_callback = l:Language
                                        else
                                            throw '`language` must be a String or Funcref'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string
                                        \&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function if defined'
                                        endif
                                    elseif has_key(a:linter, 'project_root_callback')
                                        let l:obj.project_root_callback = a:linter.project_root_callback
                            
                                        if !s:IsCallback(l:obj.project_root_callback)
                                            throw '`project_root_callback` must be a callback if defined'
                                        endif
                                    else
                                        throw '`project_root` or `project_root_callback` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options_callback')
                                        if has_key(a:linter, 'initialization_options')
                                            throw 'Only one of `initialization_options` or '
                                            \   . '`initialization_options_callback` should be set'
                                        endif
                            
                                        let l:obj.initialization_options_callback = a:linter.initialization_options_callback
                            
                                        if !s:IsCallback(l:obj.initialization_options_callback)
                                            throw '`initialization_options_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict
                                        \&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a String or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config_callback')
                                        if has_key(a:linter, 'lsp_config')
                                            throw 'Only one of `lsp_config` or `lsp_config_callback` should be set'
                                        endif
                            
                                        let l:obj.lsp_config_callback = a:linter.lsp_config_callback
                            
                                        if !s:IsCallback(l:obj.lsp_config_callback)
                                            throw '`lsp_config_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict
                                        \&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
                                endif
                            
                                let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
                                if type(l:obj.output_stream) isnot v:t_string
                                \|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
                                endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
                                let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
                                if !s:IsBoolean(l:obj.lint_file)
                                    throw '`lint_file` must be `0` or `1`'
                                endif
                            
                                " An option indicating that the buffer should be read.
                                let l:obj.read_buffer = get(a:linter, 'read_buffer', !l:obj.lint_file)
                            
                                if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
                                endif
                            
                                if l:obj.lint_file && l:obj.read_buffer
                                    throw 'Only one of `lint_file` or `read_buffer` can be `1`'
                                endif
                            
                                let l:obj.aliases = get(a:linter, 'aliases', [])
                            
                                if type(l:obj.aliases) isnot v:t_list
                                \|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
                                endif
                            
                                for l:key in filter(keys(a:linter), 'v:val[-9:] is# ''_callback'' || v:val is# ''command_chain''')
                                    if !get(g:, 'ale_ignore_2_4_warnings')
                                        execute 'echom l:key . '' is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
                                    endif
                            
                                    break
                                endfor
                            
                                return l:obj
                            endfunction
                            
    1              0.000004 function! ale#linter#Define(filetype, linter) abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
                                if !has_key(s:linters, a:filetype)
                                    let s:linters[a:filetype] = []
                                endif
                            
                                " Remove previously defined linters with the same name.
                                call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
                                call add(s:linters[a:filetype], l:new_linter)
                            endfunction
                            
                            " Prevent any linters from being loaded for a given filetype.
    1              0.000004 function! ale#linter#PreventLoading(filetype) abort
                                let s:runtime_loaded_map[a:filetype] = 1
                            endfunction
                            
    1              0.000004 function! ale#linter#GetAll(filetypes) abort
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
                                if ale#util#InSandbox()
                                    return []
                                endif
                            
                                let l:combined_linters = []
                            
                                for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
                                    if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
                                    call extend(l:combined_linters, get(s:linters, l:filetype, []))
                                endfor
                            
                                return l:combined_linters
                            endfunction
                            
    1              0.000005 function! s:GetAliasedFiletype(original_filetype) abort
                                let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
                                if type(l:buffer_aliases) is v:t_list
                                \|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
                                for l:dict in [
                                \   l:buffer_aliases,
                                \   g:ale_linter_aliases,
                                \   s:default_ale_linter_aliases,
                                \]
                                    if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
                                endfor
                            
                                return a:original_filetype
                            endfunction
                            
    1              0.000004 function! ale#linter#ResolveFiletype(original_filetype) abort
                                let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
                                if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
                                endif
                            
                                return l:filetype
                            endfunction
                            
    1              0.000004 function! s:GetLinterNames(original_filetype) abort
                                let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
                                if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
                                if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'
                            endfunction
                            
    1              0.000004 function! ale#linter#Get(original_filetypes) abort
                                let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
                                for l:original_filetype in split(a:original_filetypes, '\.')
                                    let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                                    let l:linter_names = s:GetLinterNames(l:original_filetype)
                                    let l:all_linters = ale#linter#GetAll(l:filetype)
                                    let l:filetype_linters = []
                            
                                    if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
                                    call extend(l:possibly_duplicated_linters, l:filetype_linters)
                                endfor
                            
                                let l:name_list = []
                                let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
                                for l:linter in reverse(l:possibly_duplicated_linters)
                                    if index(l:name_list, l:linter.name) < 0
                                        call add(l:name_list, l:linter.name)
                                        call add(l:combined_linters, l:linter)
                                    endif
                                endfor
                            
                                return reverse(l:combined_linters)
                            endfunction
                            
                            " Given a buffer and linter, get the executable String for the linter.
    1              0.000005 function! ale#linter#GetExecutable(buffer, linter) abort
                                let l:Executable = has_key(a:linter, 'executable_callback')
                                \   ? function(a:linter.executable_callback)
                                \   : a:linter.executable
                            
                                return type(l:Executable) is v:t_func
                                \   ? l:Executable(a:buffer)
                                \   : l:Executable
                            endfunction
                            
                            " Given a buffer and linter, get the command String for the linter.
                            " The command_chain key is not supported.
    1              0.000005 function! ale#linter#GetCommand(buffer, linter) abort
                                let l:Command = has_key(a:linter, 'command_callback')
                                \   ? function(a:linter.command_callback)
                                \   : a:linter.command
                            
                                return type(l:Command) is v:t_func
                                \   ? l:Command(a:buffer)
                                \   : l:Command
                            endfunction
                            
                            " Given a buffer and linter, get the address for connecting to the server.
    1              0.000004 function! ale#linter#GetAddress(buffer, linter) abort
                                let l:Address = has_key(a:linter, 'address_callback')
                                \   ? function(a:linter.address_callback)
                                \   : a:linter.address
                            
                                return type(l:Address) is v:t_func
                                \   ? l:Address(a:buffer)
                                \   : l:Address
                            endfunction

SCRIPT  /home/kc/.vim/plugged/vista.vim/autoload/vista/jump.vim
Sourced 1 time
Total time:   0.007261
 Self time:   0.007261

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
                            " Jump to the source line containing the given tag
    1              0.000012 function! vista#jump#TagLine(tag) abort
                              let cur_line = split(getline('.'), ':')
                            
                              " Skip if the current line or the target line is empty
                              if empty(cur_line)
                                return
                              endif
                            
                              let lnum = cur_line[-1]
                              let line = getbufline(t:vista.source.bufnr, lnum)
                            
                              if empty(line)
                                return
                              endif
                            
                              try
                                let [_, start, _] = matchstrpos(line[0], a:tag)
                              catch /^Vim\%((\a\+)\)\=:E869/
                                let start  = -1
                              endtry
                            
                              call vista#source#GotoWin()
                              " Move cursor to the column of tag located, otherwise the first column
                              call cursor(lnum, start > -1 ? start+1 : 1)
                              normal! zz
                            
                              call call('vista#util#Blink', get(g:, 'vista_top_level_blink', [2, 100]))
                            
                              call vista#GenericCloseOverlay()
                            
                              if get(g:, 'vista_close_on_jump', 0)
                                call vista#sidebar#Close()
                              endif
                            endfunction
                            
    1              0.000008 function! s:NextTopLevelLnum() abort
                              let cur_lnum = line('.')
                              let ending = line('$')
                            
                              while cur_lnum < ending
                                let cur_lnum += 1
                                if indent(cur_lnum) == 0 && !empty(getline(cur_lnum))
                                  return cur_lnum
                                endif
                              endwhile
                            
                              return 0
                            endfunction
                            
    1              0.000005 function! s:PrevTopLevelLnum() abort
                              let cur_lnum = line('.')
                            
                              " The first two lines contain no tags.
                              while cur_lnum > 2
                                let cur_lnum -= 1
                                if indent(cur_lnum) == 0 && !empty(getline(cur_lnum))
                                  return cur_lnum
                                endif
                              endwhile
                            
                              if cur_lnum == 3
                                return 3
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000005 function! s:ApplyJump(lnum) abort
                              if a:lnum > 0
                                call cursor(a:lnum, 1)
                                normal! zz
                                call call('vista#util#Blink', get(g:, 'vista_top_level_blink', [2, 100]))
                              endif
                            endfunction
                            
    1              0.000004 function! vista#jump#NextTopLevel() abort
                              call vista#GenericCloseOverlay()
                              call s:ApplyJump(s:NextTopLevelLnum())
                            endfunction
                            
    1              0.000004 function! vista#jump#PrevTopLevel() abort
                              call vista#GenericCloseOverlay()
                              call s:ApplyJump(s:PrevTopLevelLnum())
                            endfunction

SCRIPT  /home/kc/.vim/plugged/vista.vim/autoload/vista/popup.vim
Sourced 1 time
Total time:   0.000843
 Self time:   0.000843

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
    1              0.000008 let s:last_lnum = -1
    1              0.000003 let s:popup_timer = -1
    1              0.000009 let s:popup_delay = get(g:, 'vista_floating_delay', 100)
                            
    1              0.000005 function! s:ClosePopup() abort
                              if exists('s:popup_winid')
                                call popup_hide(s:popup_winid)
                                autocmd! VistaPopup
                              endif
                              let t:vista.popup_visible = v:false
                            endfunction
                            
    1              0.000006 call prop_type_delete('VistaMatch')
    1              0.000064 call prop_type_add('VistaMatch', { 'highlight': 'Search' })
                            
    1              0.000003 function! s:HiTag() abort
                              call prop_add(s:popup_lnum, s:popup_start+1, { 'length': s:popup_end - s:popup_start, 'type': 'VistaMatch' })
                            endfunction
                            
    1              0.000003 function! s:HiTagLine() abort
                              if exists('w:vista_hi_cur_tag_id')
                                call matchdelete(w:vista_hi_cur_tag_id)
                              endif
                              let w:vista_hi_cur_tag_id = matchaddpos('Search', [s:popup_lnum])
                            endfunction
                            
    1              0.000003 function! s:OpenPopup(lines) abort
                              if get(g:, 'vista_sidebar_position', 'vertical botright') =~# 'right'
                                let max_length = max(map(copy(a:lines), 'strlen(v:val)')) + 2
                                let pos_opts = {
                                      \ 'pos': 'botleft',
                                      \ 'line': 'cursor-2',
                                      \ 'col': 'cursor-'.max_length,
                                      \ 'moved': 'WORD',
                                      \ }
                              else
                                let winwidth = winwidth(0)
                                let cur_length = strlen(getline('.'))
                                let offset = min([cur_length + 4, winwidth])
                                let col = 'cursor+'.offset
                                let pos_opts = {
                                      \ 'pos': 'botleft',
                                      \ 'line': 'cursor-2',
                                      \ 'col': col,
                                      \ 'moved': 'WORD',
                                      \ }
                              endif
                            
                              if !exists('s:popup_winid')
                                let s:popup_winid = popup_create(a:lines, pos_opts)
                                let s:popup_bufnr = winbufnr(s:popup_winid)
                            
                                let filetype = getbufvar(t:vista.source.bufnr, '&ft')
                                call win_execute(s:popup_winid, 'setlocal filetype='.filetype.' nofoldenable')
                              else
                                silent call deletebufline(s:popup_bufnr, 1, '$')
                                call setbufline(s:popup_bufnr, 1, a:lines)
                                call popup_show(s:popup_winid)
                                call popup_move(s:popup_winid, pos_opts)
                              endif
                            
                              augroup VistaPopup
                                autocmd!
                                autocmd CursorMoved <buffer> call s:ClosePopup()
                                autocmd BufEnter,WinEnter,WinLeave * call s:ClosePopup()
                              augroup END
                            
                              let t:vista.popup_visible = v:true
                            endfunction
                            
    1              0.000003 function! s:DisplayRawAt(lnum, lines, vista_winid) abort
                              if win_getid() != a:vista_winid
                                return
                              endif
                            
                              call s:OpenPopup(a:lines)
                            endfunction
                            
    1              0.000003 function! s:DisplayAt(lnum, tag, vista_winid) abort
                              if win_getid() != a:vista_winid
                                return
                              endif
                            
                              let [lines, s:popup_lnum] = vista#util#GetPreviewLines(a:lnum)
                            
                              call s:OpenPopup(lines)
                            
                              let target_line = lines[s:popup_lnum - 1]
                              try
                                let [_, s:popup_start, s:popup_end] = matchstrpos(target_line, '\C'.a:tag)
                            
                                " Highlight the tag in the popup window if found.
                                if s:popup_start > -1
                                  call win_execute(s:popup_winid, 'call s:HiTag()')
                                endif
                              catch /^Vim\%((\a\+)\)\=:E869/
                                call win_execute(s:popup_winid, 'call s:HiTagLine()')
                              endtry
                            endfunction
                            
    1              0.000007 function! vista#popup#Close() abort
                              call s:ClosePopup()
                            endfunction
                            
    1              0.000008 function! s:DispatchDisplayer(Displayer, lnum, tag_or_raw_lines) abort
                              if a:lnum == s:last_lnum
                                    \ || get(t:vista, 'popup_visible', v:false)
                                return
                              endif
                            
                              silent! call timer_stop(s:popup_timer)
                            
                              let s:last_lnum = a:lnum
                            
                              let s:popup_timer = timer_start(
                                    \ s:popup_delay,
                                    \ { -> a:Displayer(a:lnum, a:tag_or_raw_lines, win_getid()) }
                                    \ )
                            endfunction
                            
    1              0.000005 function! vista#popup#DisplayAt(lnum, tag) abort
                              call s:DispatchDisplayer(function('s:DisplayAt'), a:lnum, a:tag)
                            endfunction
                            
    1              0.000005 function! vista#popup#DisplayRawAt(lnum, lines) abort
                              call s:DispatchDisplayer(function('s:DisplayRawAt'), a:lnum, a:lines)
                            endfunction

SCRIPT  /usr/share/vim/vim81/ftplugin/help.vim
Sourced 1 time
Total time:   0.000963
 Self time:   0.000963

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:             Vim help file
                            " Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:      2018-12-29
                            
    1              0.000014 if exists("b:did_ftplugin")
                              finish
    1              0.000002 endif
    1              0.000007 let b:did_ftplugin = 1
                            
    1              0.000032 let s:cpo_save = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000007 let b:undo_ftplugin = "setl fo< tw< cole< cocu< keywordprg<"
                            
    1              0.000025 setlocal formatoptions+=tcroql textwidth=78 keywordprg=:help
    1              0.000008 if has("conceal")
    1              0.000028   setlocal cole=2 cocu=nc
    1              0.000003 endif
                            
    1              0.000019 let &cpo = s:cpo_save
    1              0.000009 unlet s:cpo_save

SCRIPT  /usr/share/vim/vim81/syntax/help.vim
Sourced 1 time
Total time:   0.005281
 Self time:   0.005281

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Vim help file
                            " Maintainer:	Bram Moolenaar (Bram@vim.org)
                            " Last Change:	2019 May 12
                            
                            " Quit when a (custom) syntax file was already loaded
    1              0.000018 if exists("b:current_syntax")
                              finish
    1              0.000002 endif
                            
    1              0.000019 let s:cpo_save = &cpo
    1              0.000020 set cpo&vim
                            
    1              0.000059 syn match helpHeadline		"^[-A-Z .][-A-Z0-9 .()_]*[ \t]\+\*"me=e-1
    1              0.000035 syn match helpSectionDelim	"^===.*===$"
    1              0.000006 syn match helpSectionDelim	"^---.*--$"
    1              0.000006 if has("conceal")
    1              0.000067   syn region helpExample	matchgroup=helpIgnore start=" >$" start="^>$" end="^[^ \t]"me=e-1 end="^<" concealends
                            else
                              syn region helpExample	matchgroup=helpIgnore start=" >$" start="^>$" end="^[^ \t]"me=e-1 end="^<"
    1              0.000001 endif
    1              0.000008 if has("ebcdic")
                              syn match helpHyperTextJump	"\\\@<!|[^"*|]\+|" contains=helpBar
                              syn match helpHyperTextEntry	"\*[^"*|]\+\*\s"he=e-1 contains=helpStar
                              syn match helpHyperTextEntry	"\*[^"*|]\+\*$" contains=helpStar
    1              0.000001 else
    1              0.000034   syn match helpHyperTextJump	"\\\@<!|[#-)!+-~]\+|" contains=helpBar
    1              0.000082   syn match helpHyperTextEntry	"\*[#-)!+-~]\+\*\s"he=e-1 contains=helpStar
    1              0.000008   syn match helpHyperTextEntry	"\*[#-)!+-~]\+\*$" contains=helpStar
    1              0.000002 endif
    1              0.000004 if has("conceal")
    1              0.000006   syn match helpBar		contained "|" conceal
    1              0.000027   syn match helpBacktick	contained "`" conceal
    1              0.000005   syn match helpStar		contained "\*" conceal
                            else
                              syn match helpBar		contained "|"
                              syn match helpBacktick	contained "`"
                              syn match helpStar		contained "\*"
    1              0.000001 endif
    1              0.000029 syn match helpNormal		"|.*====*|"
    1              0.000005 syn match helpNormal		"|||"
    1              0.000005 syn match helpNormal		":|vim:|"	" for :help modeline
    1              0.000031 syn match helpVim		"\<Vim version [0-9][0-9.a-z]*"
    1              0.000006 syn match helpVim		"VIM REFERENCE.*"
    1              0.000032 syn match helpOption		"'[a-z]\{2,\}'"
    1              0.000005 syn match helpOption		"'t_..'"
    1              0.000031 syn match helpCommand		"`[^` \t]\+`"hs=s+1,he=e-1 contains=helpBacktick
    1              0.000013 syn match helpCommand		"\(^\|[^a-z"[]\)\zs`[^`]\+`\ze\([^a-z\t."']\|$\)"hs=s+1,he=e-1 contains=helpBacktick
    1              0.000031 syn match helpHeader		"\s*\zs.\{-}\ze\s\=\~$" nextgroup=helpIgnore
    1              0.000030 syn match helpGraphic		".* \ze`$" nextgroup=helpIgnore
    1              0.000004 if has("conceal")
    1              0.000005   syn match helpIgnore		"." contained conceal
                            else
                              syn match helpIgnore		"." contained
    1              0.000002 endif
    1              0.000031 syn keyword helpNote		note Note NOTE note: Note: NOTE: Notes Notes:
    1              0.000028 syn keyword helpWarning		WARNING WARNING: Warning:
    1              0.000045 syn keyword helpDeprecated	DEPRECATED DEPRECATED: Deprecated:
    1              0.000106 syn match helpSpecial		"\<N\>"
    1              0.000008 syn match helpSpecial		"\<N\.$"me=e-1
    1              0.000005 syn match helpSpecial		"\<N\.\s"me=e-2
    1              0.000004 syn match helpSpecial		"(N\>"ms=s+1
                            
    1              0.000004 syn match helpSpecial		"\[N]"
                            " avoid highlighting N  N in help.txt
    1              0.000005 syn match helpSpecial		"N  N"he=s+1
    1              0.000004 syn match helpSpecial		"Nth"me=e-2
    1              0.000004 syn match helpSpecial		"N-1"me=e-2
    1              0.000011 syn match helpSpecial		"{[-a-zA-Z0-9'"*+/:%#=[\]<>.,]\+}"
    1              0.000011 syn match helpSpecial		"\s\[[-a-z^A-Z0-9_]\{2,}]"ms=s+1
    1              0.000020 syn match helpSpecial		"<[-a-zA-Z0-9_]\+>"
    1              0.000005 syn match helpSpecial		"<[SCM]-.>"
    1              0.000004 syn match helpNormal		"<---*>"
    1              0.000005 syn match helpSpecial		"\[range]"
    1              0.000004 syn match helpSpecial		"\[line]"
    1              0.000004 syn match helpSpecial		"\[count]"
    1              0.000005 syn match helpSpecial		"\[offset]"
    1              0.000004 syn match helpSpecial		"\[cmd]"
    1              0.000004 syn match helpSpecial		"\[num]"
    1              0.000005 syn match helpSpecial		"\[+num]"
    1              0.000004 syn match helpSpecial		"\[-num]"
    1              0.000004 syn match helpSpecial		"\[+cmd]"
    1              0.000004 syn match helpSpecial		"\[++opt]"
    1              0.000005 syn match helpSpecial		"\[arg]"
    1              0.000005 syn match helpSpecial		"\[arguments]"
    1              0.000004 syn match helpSpecial		"\[ident]"
    1              0.000004 syn match helpSpecial		"\[addr]"
    1              0.000005 syn match helpSpecial		"\[group]"
                            " Don't highlight [converted] and others that do not have a tag
    1              0.000011 syn match helpNormal		"\[\(readonly\|fifo\|socket\|converted\|crypted\)]"
                            
    1              0.000005 syn match helpSpecial		"CTRL-."
    1              0.000005 syn match helpSpecial		"CTRL-Break"
    1              0.000005 syn match helpSpecial		"CTRL-PageUp"
    1              0.000006 syn match helpSpecial		"CTRL-PageDown"
    1              0.000005 syn match helpSpecial		"CTRL-Insert"
    1              0.000005 syn match helpSpecial		"CTRL-Del"
    1              0.000005 syn match helpSpecial		"CTRL-{char}"
    1              0.000065 syn region helpNotVi		start="{Vi[: ]" start="{not" start="{only" end="}" contains=helpLeadBlank,helpHyperTextJump
    1              0.000006 syn match helpLeadBlank		"^\s\+" contained
                            
                            " Highlight group items in their own color.
    1              0.000035 syn match helpComment		"\t[* ]Comment\t\+[a-z].*"
    1              0.000032 syn match helpConstant		"\t[* ]Constant\t\+[a-z].*"
    1              0.000031 syn match helpString		"\t[* ]String\t\+[a-z].*"
    1              0.000039 syn match helpCharacter		"\t[* ]Character\t\+[a-z].*"
    1              0.000030 syn match helpNumber		"\t[* ]Number\t\+[a-z].*"
    1              0.000034 syn match helpBoolean		"\t[* ]Boolean\t\+[a-z].*"
    1              0.000030 syn match helpFloat		"\t[* ]Float\t\+[a-z].*"
    1              0.000031 syn match helpIdentifier	"\t[* ]Identifier\t\+[a-z].*"
    1              0.000030 syn match helpFunction		"\t[* ]Function\t\+[a-z].*"
    1              0.000030 syn match helpStatement		"\t[* ]Statement\t\+[a-z].*"
    1              0.000031 syn match helpConditional	"\t[* ]Conditional\t\+[a-z].*"
    1              0.000030 syn match helpRepeat		"\t[* ]Repeat\t\+[a-z].*"
    1              0.000029 syn match helpLabel		"\t[* ]Label\t\+[a-z].*"
    1              0.000030 syn match helpOperator		"\t[* ]Operator\t\+["a-z].*"
    1              0.000032 syn match helpKeyword		"\t[* ]Keyword\t\+[a-z].*"
    1              0.000030 syn match helpException		"\t[* ]Exception\t\+[a-z].*"
    1              0.000030 syn match helpPreProc		"\t[* ]PreProc\t\+[a-z].*"
    1              0.000104 syn match helpInclude		"\t[* ]Include\t\+[a-z].*"
    1              0.000058 syn match helpDefine		"\t[* ]Define\t\+[a-z].*"
    1              0.000052 syn match helpMacro		"\t[* ]Macro\t\+[a-z].*"
    1              0.000038 syn match helpPreCondit		"\t[* ]PreCondit\t\+[a-z].*"
    1              0.000038 syn match helpType		"\t[* ]Type\t\+[a-z].*"
    1              0.000037 syn match helpStorageClass	"\t[* ]StorageClass\t\+[a-z].*"
    1              0.000038 syn match helpStructure		"\t[* ]Structure\t\+[a-z].*"
    1              0.000038 syn match helpTypedef		"\t[* ]Typedef\t\+[Aa-z].*"
    1              0.000009 syn match helpSpecial		"\t[* ]Special\t\+[a-z].*"
    1              0.000037 syn match helpSpecialChar	"\t[* ]SpecialChar\t\+[a-z].*"
    1              0.000036 syn match helpTag		"\t[* ]Tag\t\+[a-z].*"
    1              0.000037 syn match helpDelimiter		"\t[* ]Delimiter\t\+[a-z].*"
    1              0.000039 syn match helpSpecialComment	"\t[* ]SpecialComment\t\+[a-z].*"
    1              0.000037 syn match helpDebug		"\t[* ]Debug\t\+[a-z].*"
    1              0.000038 syn match helpUnderlined	"\t[* ]Underlined\t\+[a-z].*"
    1              0.000037 syn match helpError		"\t[* ]Error\t\+[a-z].*"
    1              0.000037 syn match helpTodo		"\t[* ]Todo\t\+[a-z].*"
                            
    1              0.000061 syn match helpURL `\v<(((https?|ftp|gopher)://|(mailto|file|news):)[^' 	<>"]+|(www|web|w3)[a-z0-9_-]*\.[a-z0-9._-]+\.[^' 	<>"]+)[a-zA-Z0-9/]`
                            
                            " Additionally load a language-specific syntax file "help_ab.vim".
    1              0.000023 let s:i = match(expand("%"), '\.\a\ax$')
    1              0.000003 if s:i > 0
                              exe "runtime syntax/help_" . strpart(expand("%"), s:i + 1, 2) . ".vim"
    1              0.000002 endif
                            
                            " Italian
    1              0.000014 if v:lang =~ '\<IT\>' || v:lang =~ '_IT\>' || v:lang =~? "italian"
                              syn keyword helpNote		nota Nota NOTA nota: Nota: NOTA: notare Notare NOTARE notare: Notare: NOTARE:
                              syn match helpSpecial		"Nma"me=e-2
                              syn match helpSpecial		"Nme"me=e-2
                              syn match helpSpecial		"Nmi"me=e-2
                              syn match helpSpecial		"Nmo"me=e-2
                              syn match helpSpecial		"\[interv.]"
                              syn region helpNotVi		start="{non" start="{solo" start="{disponibile" end="}" contains=helpLeadBlank,helpHyperTextJump
    1              0.000001 endif
                            
    1              0.000003 syn sync minlines=40
                            
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
    1              0.000029 hi def link helpIgnore		Ignore
    1              0.000027 hi def link helpHyperTextJump	Identifier
    1              0.000027 hi def link helpBar		Ignore
    1              0.000026 hi def link helpBacktick	Ignore
    1              0.000085 hi def link helpStar		Ignore
    1              0.000029 hi def link helpHyperTextEntry	String
    1              0.000029 hi def link helpHeadline	Statement
    1              0.000039 hi def link helpHeader		PreProc
    1              0.000026 hi def link helpSectionDelim	PreProc
    1              0.000026 hi def link helpVim		Identifier
    1              0.000026 hi def link helpCommand		Comment
    1              0.000026 hi def link helpExample		Comment
    1              0.000026 hi def link helpOption		Type
    1              0.000026 hi def link helpNotVi		Special
    1              0.000026 hi def link helpSpecial		Special
    1              0.000025 hi def link helpNote		Todo
    1              0.000026 hi def link helpWarning		Todo
    1              0.000026 hi def link helpDeprecated	Todo
                            
    1              0.000026 hi def link helpComment		Comment
    1              0.000026 hi def link helpConstant	Constant
    1              0.000026 hi def link helpString		String
    1              0.000025 hi def link helpCharacter	Character
    1              0.000026 hi def link helpNumber		Number
    1              0.000025 hi def link helpBoolean		Boolean
    1              0.000026 hi def link helpFloat		Float
    1              0.000025 hi def link helpIdentifier	Identifier
    1              0.000026 hi def link helpFunction	Function
    1              0.000025 hi def link helpStatement	Statement
    1              0.000025 hi def link helpConditional	Conditional
    1              0.000025 hi def link helpRepeat		Repeat
    1              0.000026 hi def link helpLabel		Label
    1              0.000025 hi def link helpOperator	Operator
    1              0.000025 hi def link helpKeyword		Keyword
    1              0.000025 hi def link helpException	Exception
    1              0.000026 hi def link helpPreProc		PreProc
    1              0.000025 hi def link helpInclude		Include
    1              0.000025 hi def link helpDefine		Define
    1              0.000025 hi def link helpMacro		Macro
    1              0.000025 hi def link helpPreCondit	PreCondit
    1              0.000113 hi def link helpType		Type
    1              0.000032 hi def link helpStorageClass	StorageClass
    1              0.000030 hi def link helpStructure	Structure
    1              0.000030 hi def link helpTypedef		Typedef
    1              0.000031 hi def link helpSpecialChar	SpecialChar
    1              0.000030 hi def link helpTag		Tag
    1              0.000031 hi def link helpDelimiter	Delimiter
    1              0.000030 hi def link helpSpecialComment	SpecialComment
    1              0.000030 hi def link helpDebug		Debug
    1              0.000036 hi def link helpUnderlined	Underlined
    1              0.000031 hi def link helpError		Error
    1              0.000030 hi def link helpTodo		Todo
    1              0.000031 hi def link helpURL		String
                            
    1              0.000007 let b:current_syntax = "help"
                            
    1              0.000026 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            " vim: ts=8 sw=2

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/help/alex.vim
Sourced 1 time
Total time:   0.007662
 Self time:   0.006325

count  total (s)   self (s)
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: alex for help files
                            
    1   0.001963   0.000626 call ale#handlers#alex#DefineLinter('help', '--text')

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/handlers/alex.vim
Sourced 1 time
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: Error handling for errors in alex output format
                            
    1              0.000007 function! ale#handlers#alex#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'alex', [
                                \   'node_modules/.bin/alex',
                                \   'node_modules/alex/cli.js',
                                \])
                            endfunction
                            
    1              0.000005 function! ale#handlers#alex#CreateCommandCallback(flags) abort
                                return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))
                                \            . ' %s '
                                \            . a:flags}
                            endfunction
                            
    1              0.000006 function! ale#handlers#alex#Handle(buffer, lines) abort
                                " Example output:
                                "       6:256-6:262  warning  Be careful with ‚Äúkilled‚Äù, it‚Äôs profane in some cases      killed           retext-profanities
                                let l:pattern = '\v^ *(\d+):(\d+)-(\d+):(\d+) +warning +(.{-})  +(.{-})  +(.{-})$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'end_lnum': l:match[3] + 0,
                                    \   'end_col': l:match[4] - 1,
                                    \   'text': l:match[5] . ' (' . (l:match[7]) . ')',
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define a linter for a specific filetype. Accept flags to adapt to the filetype.
                            "    no flags  treat input as markdown
                            "    --html    treat input as HTML
                            "    --text    treat input as plaintext
    1              0.000006 function! ale#handlers#alex#DefineLinter(filetype, flags) abort
                                call ale#Set('alex_executable', 'alex')
                                call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'alex',
                                \   'executable': function('ale#handlers#alex#GetExecutable'),
                                \   'command': ale#handlers#alex#CreateCommandCallback(a:flags),
                                \   'output_stream': 'stderr',
                                \   'callback': 'ale#handlers#alex#Handle',
                                \   'lint_file': 1,
                                \})
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/help/proselint.vim
Sourced 1 time
Total time:   0.001736
 Self time:   0.000425

count  total (s)   self (s)
                            " Author: Daniel M. Capella https://github.com/polyzen
                            " Description: proselint for Vim help files
                            
    1   0.001357   0.000046 call ale#linter#Define('help', {
                            \   'name': 'proselint',
                            \   'executable': 'proselint',
                            \   'command': 'proselint %t',
                            \   'callback': 'ale#handlers#unix#HandleAsWarning',
                            \})

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/help/writegood.vim
Sourced 1 time
Total time:   0.002428
 Self time:   0.001225

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: write-good for vim Help files
                            
    1   0.002100   0.000897 call ale#handlers#writegood#DefineLinter('help')

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/handlers/writegood.vim
Sourced 1 time
Total time:   0.000239
 Self time:   0.000144

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: Error handling for errors in the write-good format.
                            
    1              0.000011 function! ale#handlers#writegood#ResetOptions() abort
                                call ale#Set('writegood_options', '')
                                call ale#Set('writegood_executable', 'write-good')
                                call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))
                            endfunction
                            
                            " Reset the options so the tests can test how they are set.
    1   0.000121   0.000026 call ale#handlers#writegood#ResetOptions()
                            
    1              0.000005 function! ale#handlers#writegood#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'writegood', [
                                \   'node_modules/.bin/write-good',
                                \   'node_modules/write-good/bin/write-good.js',
                                \])
                            endfunction
                            
    1              0.000004 function! ale#handlers#writegood#GetCommand(buffer) abort
                                let l:executable = ale#handlers#writegood#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'writegood_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \   . (!empty(l:options) ? ' ' . l:options : '')
                                \   . ' %t'
                            endfunction
                            
    1              0.000004 function! ale#handlers#writegood#Handle(buffer, lines) abort
                                " Look for lines like the following.
                                "
                                " "it is" is wordy or unneeded on line 20 at column 53
                                " "easily" can weaken meaning on line 154 at column 29
                                let l:marks_pattern = '\v^ *(\^+) *$'
                                let l:pattern = '\v^(".*"\s.*)\son\sline\s(\d+)\sat\scolumn\s(\d+)$'
                                let l:output = []
                                let l:last_len = 0
                            
                                for l:match in ale#util#GetMatches(a:lines, [l:marks_pattern, l:pattern])
                                    if empty(l:match[2])
                                        let l:last_len = len(l:match[1])
                                    else
                                        let l:col = l:match[3] + 1
                            
                                        " Add the linter error. Note that we need to add 1 to the col because
                                        " write-good reports the column corresponding to the space before the
                                        " offending word or phrase.
                                        call add(l:output, {
                                        \   'text': l:match[1],
                                        \   'lnum': l:match[2] + 0,
                                        \   'col': l:col,
                                        \   'end_col': l:last_len ? (l:col + l:last_len - 1) : l:col,
                                        \   'type': 'W',
                                        \})
                            
                                        let l:last_len = 0
                                    endif
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define the writegood linter for a given filetype.
    1              0.000004 function! ale#handlers#writegood#DefineLinter(filetype) abort
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'writegood',
                                \   'aliases': ['write-good'],
                                \   'executable': function('ale#handlers#writegood#GetExecutable'),
                                \   'command': function('ale#handlers#writegood#GetCommand'),
                                \   'callback': 'ale#handlers#writegood#Handle',
                                \})
                            endfunction

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/insert.vim
Sourced 1 time
Total time:   0.000436
 Self time:   0.000431

count  total (s)   self (s)
                            "=============================================
                            "    Name: restin/insert.vim
                            "    File: restin/insert.vim
                            "  Author: Rykka G.Forest
                            "  Update: 2014-08-14
                            "=============================================
    1              0.000021 let s:cpo_save = &cpo
    1   0.000023   0.000021 set cpo-=C
                            
    1              0.000005 let s:p = g:_riv_p
    1              0.000007 let s:list_or_nonspace = s:p.all_list.'|^\S'
                            
    1              0.000003 let s:f_cols = []
    1              0.000004 let s:f_row = 0
    1              0.000004 let s:f_buf = 0
                            
                            
                            " NOTE:
                            " Rewrite indent behavior as #71 mentioned.
                            " https://github.com/Rykka/riv.vim/issues/71
                            "
                            " indent and shift right/left functions are used.
                            "
    1              0.000005 fun! riv#insert#indent(row) "{{{
                                " @param 
                                " row: the input row
                                " @return
                                " idt: the indent
                                
                                let row = a:row == '.' ? line('.') :
                                        \ a:row == '$' ? line('$') : a:row
                            
                                let pnb_num = prevnonblank(row - 1)
                            
                                " If above lines don't having content , return 0
                                if pnb_num == 0 | return 0 | endif
                            
                                let prev_line = getline(row - 1)
                                let pnb_line = getline(pnb_num)
                                
                                " The prev non blank line's indent
                                let ind = indent(pnb_num)
                                
                                " List-indent match the content's begin.
                                let l_ind = matchend(pnb_line, s:p.all_list)
                                if l_ind != -1 
                                    return l_ind
                                endif
                                
                                " Literal-block match the start + &sw
                                let l_ind = matchend(pnb_line, s:p.literal_block)
                                if l_ind != -1 
                                    return ind+&sw
                                endif
                            
                                " Exp markup match the start of content.
                                let l_ind = matchend(pnb_line, s:p.exp_mark)
                                if l_ind != -1
                                    return l_ind
                                endif
                                
                                return ind
                            endfun "}}}
                            
                            
    1              0.000004 fun! riv#insert#fixed_col(row,col,sft) "{{{
                            
                                " s:f_cols: store fixed columns of current line
                                "
                                " return with fix indentation with row col and direction
                                " context is the item with smaller indentation (parent)
                                " find all possible context of current row
                                
                                " using the stored fixing info
                                if s:f_row == a:row && s:f_buf == bufnr('%')
                                    return riv#ptn#fix_sfts(a:col, s:f_cols, a:sft)
                                endif
                            
                                let pnb_row = prevnonblank(a:row - 1)
                                if pnb_row == 0 | return a:col + a:sft | endif
                            
                                let f_idts = [indent(pnb_row)+1]
                            
                            
                                let blk_row = riv#ptn#get(g:_riv_p.literal_block, a:row)
                                if blk_row
                                    let f_idts += [indent(blk_row)+1+&sw]
                                endif
                            
                                let lst_row = riv#list#get_all_list(a:row)
                            
                                if lst_row 
                                    let lst_idt = indent(lst_row)+1
                                    let lst_cdt = riv#list#get_con_idt(getline(lst_row))
                                    let f_idts += [lst_idt,lst_cdt]
                                    let par_row = riv#list#get_parent(lst_row)
                                    if par_row
                                        let par_idt = indent(par_row)+1
                                        let par_cdt = riv#list#get_con_idt(getline(par_row))
                                        let f_idts += [par_idt, par_cdt]
                                    endif
                                else
                                    let exp_row = riv#ptn#get(g:_riv_p.exp_mark, a:row)
                                    let exp_cdt = riv#ptn#exp_con_idt(getline(exp_row))
                            
                            
                                    let f_idts += [exp_cdt]
                                endif
                            
                            
                                let s:f_cols = f_idts
                                let s:f_row = a:row
                                let s:f_buf = bufnr('%')
                            
                                return riv#ptn#fix_sfts(a:col, f_idts, a:sft)
                                
                            endfun "}}}
                            
                            
    1              0.000005 fun! riv#insert#fixed_sft(row,col,sft) "{{{
                                return riv#insert#fixed_col(a:row, a:col, a:sft) - a:col
                            endfun "}}}
    1              0.000102 fun! riv#insert#get_fidt() "{{{
                                return riv#insert#fixed_col(line('.'),col('.'), &sw)
                            endfun "}}}
                            
    1              0.000006 fun! riv#insert#shiftleft(row,col) "{{{
                                " shift in insert mode.
                                " should in blank line.
                                let sft = -&sw
                                let fix_sft = riv#insert#fixed_sft(a:row,a:col,sft)
                                return repeat("\<Left>\<Del>", abs(fix_sft))
                            endfun "}}}
                            
    1              0.000004 fun! riv#insert#shiftleft_bs(row,col) "{{{
                                " shift in insert mode.
                                " should in blank line.
                                let sft = -&sw
                                let fix_sft = riv#insert#fixed_sft(a:row,a:col,sft)
                                if fix_sft != sft && fix_sft!=0
                                    " NOTE:
                                    " As `<BS>` will delete all in list context.
                                    " change it to `<Del>` and:
                                    " set ww+=[,]
                                    " set bs=indent,eol,start
                                    "
                                    " return repeat("\<BS>", abs(fix_sft))
                                    return repeat("\<Left>\<Del>", abs(fix_sft))
                                else
                                    return ""
                                endif
                            endfun "}}}
                                                                        
                                                                        
    1              0.000004 fun! riv#insert#shiftright(row,col) "{{{
                                let sft = &sw
                                let fix_sft = riv#insert#fixed_sft(a:row,a:col,sft)
                                return repeat("\<Space>", abs(fix_sft))
                            endfun "}}}
                            
    1              0.000023 if expand('<sfile>:p') == expand('%:p') "{{{
                                call doctest#start()
    1              0.000003 endif "}}}
    1   0.000024   0.000021 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/alex.vim
Sourced 1 time
Total time:   0.000930
 Self time:   0.000053

count  total (s)   self (s)
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: alex for rst files
                            
    1   0.000901   0.000024 call ale#handlers#alex#DefineLinter('rst', '--text')

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/proselint.vim
Sourced 1 time
Total time:   0.000806
 Self time:   0.000033

count  total (s)   self (s)
                            " Author: Daniel M. Capella https://github.com/polyzen
                            " Description: proselint for reStructuredText files
                            
    1   0.000800   0.000027 call ale#linter#Define('rst', {
                            \   'name': 'proselint',
                            \   'executable': 'proselint',
                            \   'command': 'proselint %t',
                            \   'callback': 'ale#handlers#unix#HandleAsWarning',
                            \})

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/redpen.vim
Sourced 1 time
Total time:   0.000719
 Self time:   0.000032

count  total (s)   self (s)
                            " Author: rhysd https://rhysd.github.io
                            " Description: Redpen, a proofreading tool (http://redpen.cc)
                            
    1   0.000713   0.000026 call ale#linter#Define('rst', {
                            \   'name': 'redpen',
                            \   'executable': 'redpen',
                            \   'command': 'redpen -f rest -r json %t',
                            \   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
                            \})

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/rstcheck.vim
Sourced 1 time
Total time:   0.000786
 Self time:   0.000075

count  total (s)   self (s)
                            " Author: John Nduli https://github.com/jnduli
                            " Description: Rstcheck for reStructuredText files
                            "
                            
    1              0.000007 function! ale_linters#rst#rstcheck#Handle(buffer, lines) abort
                                " matches: 'bad_rst.rst:1: (SEVERE/4) Title overline & underline
                                " mismatch.'
                                let l:pattern = '\v^(.+):(\d*): \(([a-zA-Z]*)/\d*\) (.+)$'
                                let l:dir = expand('#' . a:buffer . ':p:h')
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
                                    \   'lnum': l:match[2] + 0,
                                    \   'col': 0,
                                    \   'type': l:match[3] is# 'SEVERE' ? 'E' : 'W',
                                    \   'text': l:match[4],
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1              0.000004 function! ale_linters#rst#rstcheck#GetCommand(buffer) abort
                                return ale#path#BufferCdString(a:buffer)
                                \   . 'rstcheck'
                                \   . ' %t'
                            endfunction
                            
                            
    1   0.000743   0.000032 call ale#linter#Define('rst', {
                            \   'name': 'rstcheck',
                            \   'executable': 'rstcheck',
                            \   'command': function('ale_linters#rst#rstcheck#GetCommand'),
                            \   'callback': 'ale_linters#rst#rstcheck#Handle',
                            \   'output_stream': 'both',
                            \})

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/textlint.vim
Sourced 1 time
Total time:   0.000861
 Self time:   0.000058

count  total (s)   self (s)
                            " Author: hokorobi <hokorobi.hokorobi@gmail.com>
                            " Description: textlint, a proofreading tool (https://textlint.github.io/)
                            
    1   0.000838   0.000035 call ale#linter#Define('rst', {
                            \   'name': 'textlint',
                            \   'executable': function('ale#handlers#textlint#GetExecutable'),
                            \   'command': function('ale#handlers#textlint#GetCommand'),
                            \   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
                            \})

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/vale.vim
Sourced 1 time
Total time:   0.001644
 Self time:   0.000053

count  total (s)   self (s)
                            " Author: chew-z https://github.com/chew-z
                            " Description: vale for RST files
                            
    1   0.001631   0.000040 call ale#linter#Define('rst', {
                            \   'name': 'vale',
                            \   'executable': 'vale',
                            \   'command': 'vale --output=JSON %t',
                            \   'callback': 'ale#handlers#vale#Handle',
                            \})

SCRIPT  /home/kc/.vim/plugged/ale/ale_linters/rst/writegood.vim
Sourced 1 time
Total time:   0.001104
 Self time:   0.000194

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: write-good for reStructuredText files
                            
    1   0.000943   0.000033 call ale#handlers#writegood#DefineLinter('rst')

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/command.vim
Sourced 1 time
Total time:   0.000459
 Self time:   0.000459

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for formatting command strings, running commands, and
                            "   managing files during linting and fixing cycles.
                            
                            " This dictionary holds lists of files and directories to remove later.
    1              0.000009 if !exists('s:buffer_data')
    1              0.000005     let s:buffer_data = {}
    1              0.000002 endif
                            
                            " Used to get the data in tests.
    1              0.000004 function! ale#command#GetData() abort
                                return deepcopy(s:buffer_data)
                            endfunction
                            
    1              0.000003 function! ale#command#ClearData() abort
                                let s:buffer_data = {}
                            endfunction
                            
    1              0.000004 function! ale#command#InitData(buffer) abort
                                if !has_key(s:buffer_data, a:buffer)
                                    let s:buffer_data[a:buffer] = {
                                    \   'jobs': {},
                                    \   'file_list': [],
                                    \   'directory_list': [],
                                    \}
                                endif
                            endfunction
                            
    1              0.000004 function! ale#command#ManageFile(buffer, file) abort
                                call ale#command#InitData(a:buffer)
                                call add(s:buffer_data[a:buffer].file_list, a:file)
                            endfunction
                            
    1              0.000004 function! ale#command#ManageDirectory(buffer, directory) abort
                                call ale#command#InitData(a:buffer)
                                call add(s:buffer_data[a:buffer].directory_list, a:directory)
                            endfunction
                            
    1              0.000004 function! ale#command#CreateFile(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP'
                                endif
                            
                                let l:temporary_file = ale#util#Tempname()
                                call ale#command#ManageFile(a:buffer, l:temporary_file)
                            
                                return l:temporary_file
                            endfunction
                            
                            " Create a new temporary directory and manage it in one go.
    1              0.000004 function! ale#command#CreateDirectory(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP_DIR'
                                endif
                            
                                let l:temporary_directory = ale#util#Tempname()
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                            
                                return l:temporary_directory
                            endfunction
                            
    1              0.000004 function! ale#command#RemoveManagedFiles(buffer) abort
                                let l:info = get(s:buffer_data, a:buffer, {})
                            
                                if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
                                    if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
                                    for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
                                    for l:directory in l:info.directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    call remove(s:buffer_data, a:buffer)
                                endif
                            endfunction
                            
    1              0.000004 function! ale#command#CreateTempFile(buffer, temporary_file, input) abort
                                if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
                                let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
                                let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
                                call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
                                call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
                                return 1
                            endfunction
                            
    1              0.000005 function! s:TemporaryFilename(buffer) abort
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
                                return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000004 function! ale#command#EscapeCommandPart(command_part) abort
                                return substitute(a:command_part, '%', '%%', 'g')
                            endfunction
                            
                            " Given a command string, replace every...
                            " %s -> with the current filename
                            " %t -> with the name of an unused file in a temporary directory
                            " %% -> with a literal %
    1              0.000006 function! ale#command#FormatCommand(buffer, executable, command, pipe_file_if_needed, input) abort
                                let l:temporary_file = ''
                                let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
                                let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
                                if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
                                endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
                                if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
                                endif
                            
                                if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
                                endif
                            
                                " Finish formatting so %% becomes %.
                                let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
                                if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
                                let l:file_created = ale#command#CreateTempFile(
                                \   a:buffer,
                                \   l:temporary_file,
                                \   a:input,
                                \)
                            
                                return [l:temporary_file, l:command, l:file_created]
                            endfunction
                            
    1              0.000004 function! ale#command#StopJobs(buffer, job_type) abort
                                let l:info = get(s:buffer_data, a:buffer, {})
                            
                                if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
                                endif
                            endfunction
                            
    1              0.000004 function! s:GatherOutput(line_list, job_id, line) abort
                                call add(a:line_list, a:line)
                            endfunction
                            
    1              0.000005 function! s:ExitCallback(buffer, line_list, Callback, data) abort
                                if !has_key(s:buffer_data, a:buffer)
                                    return
                                endif
                            
                                let l:jobs = s:buffer_data[a:buffer].jobs
                            
                                if !has_key(l:jobs, a:data.job_id)
                                    return
                                endif
                            
                                let l:job_type = remove(l:jobs, a:data.job_id)
                            
                                if g:ale_history_enabled
                                    call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
                                    if g:ale_history_log_output && a:data.log_output is 1
                                        call ale#history#RememberOutput(
                                        \   a:buffer,
                                        \   a:data.job_id,
                                        \   a:line_list[:]
                                        \)
                                    endif
                                endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
                                call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                                let l:value = a:Callback(a:buffer, a:line_list, {
                                \   'exit_code': a:data.exit_code,
                                \   'temporary_file': a:data.temporary_file,
                                \})
                            
                                let l:result = a:data.result
                                let l:result.value = l:value
                            
                                if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
                                endif
                            endfunction
                            
    1              0.000004 function! ale#command#Run(buffer, command, Callback, ...) abort
                                let l:options = get(a:000, 0, {})
                            
                                if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
                                let l:output_stream = get(l:options, 'output_stream', 'stdout')
                                let l:line_list = []
                            
                                let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(
                                \   a:buffer,
                                \   get(l:options, 'executable', ''),
                                \   a:command,
                                \   get(l:options, 'read_buffer', 0),
                                \   get(l:options, 'input', v:null),
                                \)
                                let l:command = ale#job#PrepareCommand(a:buffer, l:command)
                                let l:job_options = {
                                \   'exit_cb': {job_id, exit_code -> s:ExitCallback(
                                \       a:buffer,
                                \       l:line_list,
                                \       a:Callback,
                                \       {
                                \           'job_id': job_id,
                                \           'exit_code': exit_code,
                                \           'temporary_file': l:temporary_file,
                                \           'log_output': get(l:options, 'log_output', 1),
                                \           'result': l:result,
                                \       }
                                \   )},
                                \   'mode': 'nl',
                                \}
                            
                                if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                endif
                            
                                let l:status = 'failed'
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
                                    let l:job_id = ale#job#Start(l:command, l:job_options)
                                endif
                            
                                if l:job_id
                                    let l:status = 'started'
                                    let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
                                    call ale#command#InitData(a:buffer)
                                    let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
                                endif
                            
                                if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
                                let l:result = {
                                \   '_deferred_job_id': l:job_id,
                                \   'executable': get(l:options, 'executable', ''),
                                \   'command': a:command,
                                \}
                            
                                if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(
                                        \   g:ale_run_synchronously_callbacks,
                                        \   {exit_code, output -> [
                                        \       extend(l:line_list, output),
                                        \       l:job_options.exit_cb(l:job_id, exit_code),
                                        \   ]}
                                        \)
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(
                                        \   type(l:command) is v:t_list
                                        \       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])
                                        \       : l:command
                                        \))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')
                                        \&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(
                                        \   g:ale_run_synchronously_callbacks,
                                        \   {-> l:job_options.exit_cb(l:job_id, v:shell_error)}
                                        \)
                                    endif
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000004 function! ale#command#IsDeferred(value) abort
                                return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/history.vim
Sourced 1 time
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Tools for managing command history
                            
                            " A flag for controlling the maximum size of the command history to store.
    1              0.000011 let g:ale_max_buffer_history_size = get(g:, 'ale_max_buffer_history_size', 20)
                            
                            " Return a shallow copy of the command history for a given buffer number.
    1              0.000006 function! ale#history#Get(buffer) abort
                                return copy(getbufvar(a:buffer, 'ale_history', []))
                            endfunction
                            
    1              0.000006 function! ale#history#Add(buffer, status, job_id, command) abort
                                if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
                                let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
                                if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
                                call add(l:history, {
                                \   'status': a:status,
                                \   'job_id': a:job_id,
                                \   'command': a:command,
                                \})
                            
                                call setbufvar(a:buffer, 'ale_history', l:history)
                            endfunction
                            
    1              0.000007 function! s:FindHistoryItem(buffer, job_id) abort
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
                                for l:obj in reverse(ale#history#Get(a:buffer))
                                    if l:obj.job_id == a:job_id
                                        return l:obj
                                    endif
                                endfor
                            
                                return {}
                            endfunction
                            
                            " Set an exit code for a command which finished.
    1              0.000005 function! ale#history#SetExitCode(buffer, job_id, exit_code) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
                                let l:obj.exit_code = a:exit_code
                                let l:obj.status = 'finished'
                            endfunction
                            
                            " Set the output for a command which finished.
    1              0.000006 function! ale#history#RememberOutput(buffer, job_id, output) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                let l:obj.output = a:output
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/handlers/textlint.vim
Sourced 1 time
Total time:   0.000154
 Self time:   0.000102

count  total (s)   self (s)
                            " Author: tokida https://rouger.info, Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
                            " Description: textlint, a proofreading tool (https://textlint.github.io/)
                            
    1   0.000040   0.000019 call ale#Set('textlint_executable', 'textlint')
    1   0.000032   0.000016 call ale#Set('textlint_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000026   0.000011 call ale#Set('textlint_options', '')
                            
    1              0.000005 function! ale#handlers#textlint#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'textlint', [
                                \   'node_modules/.bin/textlint',
                                \   'node_modules/textlint/bin/textlint.js',
                                \])
                            endfunction
                            
    1              0.000004 function! ale#handlers#textlint#GetCommand(buffer) abort
                                let l:executable = ale#handlers#textlint#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'textlint_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \    . (!empty(l:options) ? ' ' . l:options : '')
                                \    . ' -f json --stdin --stdin-filename %s'
                            endfunction
                            
    1              0.000005 function! ale#handlers#textlint#HandleTextlintOutput(buffer, lines) abort
                                let l:res = get(ale#util#FuzzyJSONDecode(a:lines, []), 0, {'messages': []})
                                let l:output = []
                            
                                for l:err in l:res.messages
                                    call add(l:output, {
                                    \   'text': l:err.message,
                                    \   'type': 'W',
                                    \   'code': l:err.ruleId,
                                    \   'lnum': l:err.line,
                                    \   'col' : l:err.column
                                    \})
                                endfor
                            
                                return l:output
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/node.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000066

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for working with Node executables.
                            
    1   0.000035   0.000016 call ale#Set('windows_node_executable_path', 'node.exe')
                            
                            " Given a buffer number, a base variable name, and a list of paths to search
                            " for in ancestor directories, detect the executable path for a Node program.
                            "
                            " The use_global and executable options for the relevant program will be used.
    1              0.000005 function! ale#node#FindExecutable(buffer, base_var_name, path_list) abort
                                if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
                                for l:path in a:path_list
                                    let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
                                    if !empty(l:executable)
                                        return l:executable
                                    endif
                                endfor
                            
                                return ale#Var(a:buffer, a:base_var_name . '_executable')
                            endfunction
                            
                            " Create a executable string which executes a Node.js script command with a
                            " Node.js executable if needed.
                            "
                            " The executable string should not be escaped before passing it to this
                            " function, the executable string will be escaped when returned by this
                            " function.
                            "
                            " The executable is only prefixed for Windows machines
    1              0.000004 function! ale#node#Executable(buffer, executable) abort
                                if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
                                endif
                            
                                return ale#Escape(a:executable)
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/path.vim
Sourced 1 time
Total time:   0.000393
 Self time:   0.000329

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for working with paths in the filesystem.
                            
                            " simplify a path, and fix annoying issues with paths on Windows.
                            "
                            " Forward slashes are changed to back slashes so path equality works better
                            " on Windows. Back slashes are changed to forward slashes on Unix.
                            "
                            " Unix paths can technically contain back slashes, but in practice no path
                            " should, and replacing back slashes with forward slashes makes linters work
                            " in environments like MSYS.
                            "
                            " Paths starting with more than one forward slash are changed to only one
                            " forward slash, to prevent the paths being treated as special MSYS paths.
    1              0.000004 function! ale#path#Simplify(path) abort
                                if has('unix')
                                    let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
                                    return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks
                            endfunction
                            
                            " Given a buffer and a filename, find the nearest file by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000004 function! ale#path#FindNearestFile(buffer, filename) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer and a directory name, find the nearest directory by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000004 function! ale#path#FindNearestDirectory(buffer, directory_name) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer, a string to search for, and a global fallback for when
                            " the search fails, look for a file in parent paths, and if that fails,
                            " use the global fallback path instead.
    1              0.000004 function! ale#path#ResolveLocalPath(buffer, search_string, global_fallback) abort
                                " Search for a locally installed file first.
                                let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
                            
                                " If the search fails, try the global executable instead.
                                if empty(l:path)
                                    let l:path = a:global_fallback
                                endif
                            
                                return l:path
                            endfunction
                            
                            " Output 'cd <directory> && '
                            " This function can be used changing the directory for a linter command.
    1              0.000003 function! ale#path#CdString(directory) abort
                                if has('win32')
                                    return 'cd /d ' . ale#Escape(a:directory) . ' && '
                                else
                                    return 'cd ' . ale#Escape(a:directory) . ' && '
                                endif
                            endfunction
                            
                            " Output 'cd <buffer_filename_directory> && '
                            " This function can be used changing the directory for a linter command.
    1              0.000004 function! ale#path#BufferCdString(buffer) abort
                                return ale#path#CdString(fnamemodify(bufname(a:buffer), ':p:h'))
                            endfunction
                            
                            " Return 1 if a path is an absolute path.
    1              0.000003 function! ale#path#IsAbsolute(filename) abort
                                if has('win32') && a:filename[:0] is# '\'
                                    return 1
                                endif
                            
                                " Check for /foo and C:\foo, etc.
                                return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'
                            endfunction
                            
    1   0.000097   0.000033 let s:temp_dir = ale#path#Simplify(fnamemodify(ale#util#Tempname(), ':h'))
                            
                            " Given a filename, return 1 if the file represents some temporary file
                            " created by Vim.
    1              0.000004 function! ale#path#IsTempName(filename) abort
                                return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir
                            endfunction
                            
                            " Given a base directory, which must not have a trailing slash, and a
                            " filename, which may have an absolute path a path relative to the base
                            " directory, return the absolute path to the file.
    1              0.000005 function! ale#path#GetAbsPath(base_directory, filename) abort
                                if ale#path#IsAbsolute(a:filename)
                                    return ale#path#Simplify(a:filename)
                                endif
                            
                                let l:sep = has('win32') ? '\' : '/'
                            
                                return ale#path#Simplify(a:base_directory . l:sep . a:filename)
                            endfunction
                            
                            " Given a path, return the directory name for that path, with no trailing
                            " slashes. If the argument is empty(), return an empty string.
    1              0.000003 function! ale#path#Dirname(path) abort
                                if empty(a:path)
                                    return ''
                                endif
                            
                                " For /foo/bar/ we need :h:h to get /foo
                                if a:path[-1:] is# '/'
                                    return fnamemodify(a:path, ':h:h')
                                endif
                            
                                return fnamemodify(a:path, ':h')
                            endfunction
                            
                            " Given a buffer number and a relative or absolute path, return 1 if the
                            " two paths represent the same file on disk.
    1              0.000004 function! ale#path#IsBufferPath(buffer, complex_filename) abort
                                " If the path is one of many different names for stdin, we have a match.
                                if a:complex_filename is# '-'
                                \|| a:complex_filename is# 'stdin'
                                \|| a:complex_filename[:0] is# '<'
                                    return 1
                                endif
                            
                                let l:test_filename = ale#path#Simplify(a:complex_filename)
                            
                                if l:test_filename[:1] is# './'
                                    let l:test_filename = l:test_filename[2:]
                                endif
                            
                                if l:test_filename[:1] is# '..'
                                    " Remove ../../ etc. from the front of the path.
                                    let l:test_filename = substitute(l:test_filename, '\v^(\.\.[/\\])+', '/', '')
                                endif
                            
                                " Use the basename for temporary files, as they are likely our files.
                                if ale#path#IsTempName(l:test_filename)
                                    let l:test_filename = fnamemodify(l:test_filename, ':t')
                                endif
                            
                                let l:buffer_filename = expand('#' . a:buffer . ':p')
                            
                                return l:buffer_filename is# l:test_filename
                                \   || l:buffer_filename[-len(l:test_filename):] is# l:test_filename
                            endfunction
                            
                            " Given a path, return every component of the path, moving upwards.
    1              0.000003 function! ale#path#Upwards(path) abort
                                let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
                                let l:sep = has('win32') ? '\' : '/'
                                let l:parts = split(ale#path#Simplify(a:path), l:pattern)
                                let l:path_list = []
                            
                                while !empty(l:parts)
                                    call add(l:path_list, join(l:parts, l:sep))
                                    let l:parts = l:parts[:-2]
                                endwhile
                            
                                if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
                                    call map(l:path_list, '''/'' . v:val')
                                    call add(l:path_list, '/')
                                endif
                            
                                return l:path_list
                            endfunction
                            
                            " Convert a filesystem path to a file:// URI
                            " relatives paths will not be prefixed with the protocol.
                            " For Windows paths, the `:` in C:\ etc. will not be percent-encoded.
    1              0.000003 function! ale#path#ToURI(path) abort
                                let l:has_drive_letter = a:path[1:2] is# ':\'
                            
                                return substitute(
                                \   ((l:has_drive_letter || a:path[:0] is# '/') ? 'file://' : '')
                                \       . (l:has_drive_letter ? '/' . a:path[:2] : '')
                                \       . ale#uri#Encode(l:has_drive_letter ? a:path[3:] : a:path),
                                \   '\\',
                                \   '/',
                                \   'g',
                                \)
                            endfunction
                            
    1              0.000003 function! ale#path#FromURI(uri) abort
                                if a:uri[:6] is? 'file://'
                                    let l:encoded_path = a:uri[7:]
                                elseif a:uri[:4] is? 'file:'
                                    let l:encoded_path = a:uri[5:]
                                else
                                    let l:encoded_path = a:uri
                                endif
                            
                                let l:path = ale#uri#Decode(l:encoded_path)
                            
                                " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
                                if has('win32') && l:path =~# '^/[a-zA-Z][:|]'
                                    let l:path = substitute(l:path[1:], '/', '\\', 'g')
                                    let l:path = l:path[0] . ':' . l:path[2:]
                                endif
                            
                                return l:path
                            endfunction

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/table.vim
Sourced 1 time
Total time:   0.000573
 Self time:   0.000573

count  total (s)   self (s)
                            "=============================================
                            "    Name: table.vim
                            "    File: table.vim
                            " Summary: Grid table
                            "  Author: Rykka G.F
                            "  Update: 2012-07-16
                            " Version: 0.5
                            "=============================================
    1              0.000015 let s:cpo_save = &cpo
    1              0.000020 set cpo-=C
                            
    1              0.000003 let s:p = g:_riv_p
                            
    1              0.000004 fun! riv#table#format() "{{{
                                " if g:_riv_c.has_py
                                    " exe g:_riv_c.py ."GetTable().format_table()"
                                " else
                                    call s:get_table().format_table()
                                " endif
                            endfun "}}}
    1              0.000003 fun! riv#table#newline(type) "{{{
                                " if g:_riv_c.has_py
                                    " exe g:_riv_c.py ."GetTable().add_line(typ='".a:type."')"
                                " else
                                    call s:get_table().add_line(a:type)
                                " endif
                            endfun "}}}
                            
    1              0.000003 fun! riv#table#create() "{{{
                            
                                let row = str2nr(input('Input row number of table:'))
                                let col = str2nr(input('Input column number of table:'))
                                let cont = map(range(col),'" "')
                                let sep = ['|S']
                            
                                let list = map(range(2*row),'cont')
                                for i in range(len(list))
                                    if i % 2 == 0
                                        let list[i] = sep
                                    endif
                                endfor
                                
                                let table = s:grid_table.new(list)
                                
                                let lines = table.lines(0) 
                                if getline('.') !~ '^\s*$'
                                    let lines = [""] + lines
                                endif
                                if getline(line('.')+1) !~ '^\s*$'
                                    let lines = lines + [""]
                                endif
                                call append(line('.'),lines)
                            
                            endfun "}}}
                            
    1              0.000003 fun! riv#table#format_pos() "{{{
                                let pos = getpos('.')
                                if getline('.') =~ s:p.table
                                    noa call riv#table#format()
                                    call setpos('.',pos)
                                    " It may get folded after formating.
                                    if foldclosed(pos[1])!=-1
                                        foldopen!
                                    endif
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! riv#table#nextcell() "{{{
                                if getline('.') =~ s:p.table
                                    return searchpos(s:p.cell.'|^\s*$' ,'Wn')   
                                endif
                                return [0,0]
                            endfun "}}}
    1              0.000003 fun! riv#table#prevcell() "{{{
                                if getline('.') =~ s:p.table
                                    return searchpos(s:p.cell.'|^\s*$','Wbn')   
                                endif
                                return [0,0]
                            endfun "}}}
                            
    1              0.000004 function! riv#table#prevline() "{{{
                                let row = line('.')-1
                                call cursor(row, col('.'))
                                if getline('.') =~ s:p.table
                                    return searchpos(s:p.cell.'|^\s*$' ,'Wbnc')
                                elseif getline('.') =~ s:p.table_fence
                                    call cursor(row-1, col('.'))
                                    return searchpos(s:p.cell.'|^\s*$' ,'Wbnc')
                                else
                                    return [0,0]
                                endif
                            endfunction "}}}
    1              0.000004 function! riv#table#nextline() "{{{
                                let row = line('.')+1
                                call cursor(row, col('.'))
                                if getline('.') =~ s:p.table_line
                                    return searchpos(s:p.cell.'|^\s*$' ,'Wbnc')
                                elseif getline('.') =~ s:p.table_fence
                                    call cursor(row+1, col('.'))
                                    return searchpos(s:p.cell.'|^\s*$' ,'Wbnc')
                                else
                                    return [0,0]
                                endif
                            endfunction "}}}
                            
                            " table parse "{{{
                            
    1              0.000004 fun! s:get_table_range(row) "{{{
                                let row = a:row
                                if getline(row) !~ s:p.table
                                    return [0, 0]
                                endif
                            
                                let [bgn,end] = [row, row]
                            
                                for i in range(row,1,-1)
                                    if getline(i) =~ s:p.table
                                        let bgn = i
                                    else
                                        break
                                    endif
                                endfor
                                
                                for i in range(row,line('$'))
                                    if getline(i) =~ s:p.table
                                        let end = i
                                    else
                                        break
                                    endif
                                endfor
                                return [bgn,end]
                            endfun "}}}
    1              0.000004 fun! s:table_in_range(bgn,end) "{{{
                                " first get a list of columns of each row
                                " then convert the list to a table object.
                            
                                let max_col = 0
                                let rows = []
                                for i in range(a:bgn,a:end)
                                    let line = getline(i)
                                    if line =~ s:p.table_mline
                                        let cols = map(riv#ptn#match_obj_list(line, s:p.table_cell),'v:val.str')
                                        let c_len = len(cols)
                                        if max_col < c_len
                                            let max_col = c_len
                                        endif
                                        call add(rows,cols)
                                    elseif line =~ s:p.table_sepr
                                        call add(rows,['|S'])
                                    elseif line =~ s:p.table_head
                                        call add(rows,['|H'])
                                    endif
                                endfor
                                
                                return s:grid_table(rows)
                            endfun "}}}
                            
    1              0.000004 let s:get_table = {}
    1              0.000003 fun! s:get_table(...) "{{{
                                return a:0 ? s:get_table.new(a:1) : s:get_table.new()
                            endfun "}}}
    1              0.000003 fun! s:get_table.new(...)  dict "{{{
                                " get the table object of row
                                
                                let row = a:0 ? a:1 : line('.')
                                let [bgn, end] = s:get_table_range(row)
                                if bgn == 0
                                    let self.table = {}
                                else
                                    let self.table = s:table_in_range(bgn,end)
                                    let self.indent = indent(row)
                                endif
                                let [self.bgn, self.end] = [bgn, end]
                                return self
                            endfun "}}}
    1              0.000003 fun! s:get_table.format_table() dict "{{{
                                if empty(self.table) | return -1 | endif
                            
                                let lines = self.table.lines(self.indent)
                            
                                if empty(lines) | return -2 | endif
                                let [bgn,end] = [self.bgn, self.end]
                                let d_bgn = 0
                            
                                " only change the different lines for speed
                                for i in range(bgn, end)
                                    if !empty(lines)
                                        if getline(i) != lines[0]
                                            call setline(i, lines[0])
                                        endif
                                        call remove(lines, 0)
                                    elseif getline(i) =~ s:p.table
                                        " no lines in new table , 
                                        " should del the following lines in buffer
                                        let d_bgn = i
                                        break
                                    endif
                                endfor
                                if d_bgn
                                    exe i.",".end."del"
                                endif
                                " still lines in new table,
                                " append it to end
                                if !empty(lines)
                                    call append(end, lines)
                                endif
                            endfun "}}}
    1              0.000003 fun! s:get_table.add_line(type) dict "{{{
                                if empty(self.table) | return -1 | endif
                                let idx =  line('.') - self.bgn
                                call self.table.add_line(idx, a:type)
                                call self.format_table()
                            endfun "}}}
                            "}}}
                            
                            " grid table object. "{{{
    1              0.000003 let s:grid_table = {}
    1              0.000003 fun! s:grid_table(list) "{{{
                                return s:grid_table.new(a:list)
                            endfun "}}}
    1              0.000003 fun! s:grid_table.new(list) dict "{{{
                            
                               let self.list = s:balance_table_col(a:list)
                               let self.row = len(self.list)
                               if self.row > 0
                                   let self.col = len(self.list[0])
                               else
                                   let self.col = 0
                               endif
                                
                               call self.norm_col()
                               call self.parse_col_max_width()
                                
                               return self
                            endfun "}}}
    1              0.000002 fun! s:grid_table.norm_col() dict "{{{
                                for row in self.list
                                    for i in range(len(row))
                                        let row[i] = s:rstrip(row[i])
                                        if row[i] !~ '^\s'
                                            let row[i] = " ".row[i]
                                        endif
                                    endfor
                                endfor
                            endfun "}}}
    1              0.000003 fun! s:grid_table.parse_col_max_width() dict "{{{
                                let v_tbl = s:zip(self.list)
                                let col_max_w = []
                                for v_cols in v_tbl
                                    let max_len = 0
                                    for col in v_cols
                                        if col =~ '^ |S\|^ |H'
                                            continue
                                        endif
                                        let c_len = strwidth(col)
                                        if c_len > max_len
                                            let max_len = c_len
                                        endif
                                    endfor
                                    call add(col_max_w, max_len)
                                endfor
                                let self.col_max_w = col_max_w
                            endfun "}}}
    1              0.000003 fun! s:grid_table.lines(indent) dict "{{{
                                let idt = repeat(" ", a:indent)
                                let sepr = idt . "+" . join(map(copy(self.col_max_w),' repeat("-", v:val+1)'),"+") . "+"
                                let head = substitute(sepr, '-','=','g')
                                let lines = []
                                for row in self.list
                                    if row[0] == ' |S'
                                        call add(lines, sepr)
                                    elseif row[0] == ' |H'
                                        call add(lines, head)
                                    else
                                        let s_col = ""
                                        for i in range(len(row))
                                            let c = row[i]
                                            let s_col .= "|".c.repeat(" ", self.col_max_w[i]-strwidth(c))." "
                                        endfor
                                        let cont = idt . s_col . "|"
                                        call add(lines, cont)
                                    endif
                                endfor
                            
                                " add missing sepr at bgn/end
                                if !empty(lines)
                                    if lines[-1] != sepr
                                        call add(lines, sepr)
                                    endif
                                    if lines[0] != sepr
                                        call insert(lines, sepr, 0)
                                    endif
                                endif
                            
                                return lines
                            endfun "}}}
    1              0.000003 fun! s:grid_table.add_line(idx, type) dict "{{{
                                if a:type == 'cont' || self.list[a:idx][0] == ' |S' || self.list[a:idx][0] == ' |H'
                                    " when prev is sepr , idx+1 will insert it befor the sepr line
                                    let c = a:idx + 1
                                else
                                    let c = a:idx + 2
                                endif
                            
                                if a:type == 'sepr'
                                    call insert(self.list, [" |S"], a:idx+1)
                                elseif a:type == "head"
                                    call insert(self.list, [" |H"], a:idx+1)
                                endif
                                call insert(self.list, map(range(self.col), '" "'), c)
                                
                            endfun "}}}
                            "}}}
                            
    1              0.000004 fun! s:balance_table_col(list) "{{{
                                let balanced_list = []
                                let max_cols = 0
                            
                                " get the max max_cols of the list
                                for row in a:list "{{{
                                    if type(row) == type([])
                                        let row_len = len(row)
                                        if row_len > max_cols 
                                            let max_cols = row_len
                                        endif
                                    endif
                                endfor "}}}
                            
                                if max_cols == 0
                                    return balanced_list
                                endif
                                
                                " add a ' ' to each row
                                for i in range(len(a:list)) "{{{
                                    let row = a:list[i]
                                    if type(row) == type([])
                                        let row_len = len(row)
                                        let tmp = row[:]
                                        if max_cols > row_len
                                            call extend(tmp, map(range(max_cols - row_len), '" "'))
                                        endif
                                    else
                                        let tmp = [row]
                                        call extend(tmp, map(range(max_cols - 1), '" "'))
                                    endif
                                    call add(balanced_list, tmp)
                                endfor "}}}
                                return balanced_list
                            endfun "}}}
    1              0.000003 fun! s:rstrip(str) "{{{
                                return matchstr(a:str, '.\{-}\ze\s*$')
                            endfun "}}}
    1              0.000003 fun! s:zip(list) "{{{
                                " return a zipped list
                                " [1,2,3],[4,5,6] to [1,4] ,[2,5] ,[3,6]
                                let zipped = []
                                
                                for row in a:list
                                    for i in range(len(row))
                                        if i >= len(zipped)
                                            let list = []
                                            call add(zipped, list)
                                        else
                                            let list = zipped[i]
                                        endif
                                        call add(list, row[i])
                                    endfor
                                endfor
                                return zipped
                            endfun "}}}
                            
                            
    1              0.000003 fun! riv#table#newline(type) "{{{
                                " TODO: break a line in a table
                                call riv#breakundo()
                                let [row,col] = getpos('.')[1:2]
                                call s:get_table().add_line(a:type)
                                if a:type == 'cont'
                                    call cursor(row+1,col)
                                else
                                    call cursor(row+2,col)
                                endif
                                call search(g:_riv_p.cell.'|^\s*$' ,'Wbc')
                            endfun "}}}
                            
    1              0.000017 if expand('<sfile>:p') == expand('%:p') "{{{
                                echo s:zip([[1,2,3],[4,5,6],[7,8]])
    1              0.000003 endif "}}}
                            
    1              0.000018 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/action.vim
Sourced 1 time
Total time:   0.000523
 Self time:   0.000516

count  total (s)   self (s)
                            "=============================================
                            "    Name: action.vim
                            "    File: action.vim
                            " Summary: simulate and fix some misc actions
                            "  Author: Rykka G.Forest
                            "  Update: 2014-02-10
                            "=============================================
    1              0.000033 let s:cpo_save = &cpo
    1   0.000023   0.000021 set cpo-=C
                            
    1              0.000004 let s:p = g:_riv_p
    1              0.000006 fun! riv#action#tutor(fname, bname) "{{{
                                " Read tutor in a nofile buffer.
                                "   if not exists, create buffer
                                "   if buffer exists, load buffer.
                                let [dir, loc, size] = ['','', 12]
                                let loc = empty(loc) ? 'bot' : loc
                                silent! exec loc.' '.size.dir.'new '. a:bname
                                
                                setl buftype=nofile bufhidden=hide noswapfile
                                set ft=rst
                                let file = g:_riv_c.doc_path . a:fname . '.rst'
                                try
                                    call setline(1, readfile(file))
                                catch
                                    call riv#error('Error while reading file: '.v:exception)
                                endtry
                                update
                            
                            endfun "}}}
    1              0.000004 fun! riv#action#open(name) "{{{
                                let file = g:_riv_c.doc_path . 'riv_'.a:name.'.rst'
                                let [dir, loc, size] = ['','', 12]
                                let loc = empty(loc) ? 'bot' : loc
                                silent! exec loc.' '.size.dir.'new '. file
                                
                                    setl ro noma ft=rst
                                    update
                            endfun "}}}
                            
    1              0.000003 fun! riv#action#db_click(mouse) "{{{
                                " could not use map <expr>
                                " cause it's editing file here.
                                let row = line('.')
                                if foldclosed(row) != -1
                                    exe "normal! zv"
                                elseif riv#link#open() == 0
                                    if s:is_in_sect_title(row)
                                        exe "normal! zc"
                                        return
                                    endif
                                    let line = getline(row)
                                    let col = col('.')
                                    let [is_in,bgn,end,obj] = riv#todo#col_item(line,col)
                                    if !is_in
                                        if a:mouse== 1
                                            exe "normal! \<2-LeftMouse>"
                                        else
                                            exe "normal! \<Enter>"
                                        endif
                                    elseif is_in == 2
                                        call riv#todo#toggle()
                                    elseif is_in == 3
                                        call riv#todo#toggle_prior(0)
                                    elseif is_in == 4 || is_in == 5
                                        call riv#todo#change_datestamp()
                                    endif
                                endif
                            endfun "}}}
    1              0.000005 fun! s:is_in_sect_title(row) "{{{
                               return exists("b:riv_obj") && has_key(b:riv_obj, a:row)
                                           \ && b:riv_obj[a:row].type =='sect'
                            endfun "}}}
                            
    1              0.000005 fun! s:table_newline_cmd(row,col,typ) "{{{
                                let cmd  = "\<C-G>u\<C-O>:call riv#table#newline('".a:typ."')|"
                                if a:typ == 'cont'
                                    let cmd .= "call cursor(".(a:row+1).",".a:col.")|"
                                else
                                    let cmd .= "call cursor(".(a:row+2).",".a:col.")|"
                                endif
                                let cmd .= "call search(g:_riv_p.cell.'|^\s*$' ,'Wbc')\<CR>"
                                return cmd
                            endfun "}}}
                            
    1              0.000003 fun! riv#action#ins_enter() "{{{
                                if getline('.') =~ s:p.table
                                    call riv#table#newline('cont')
                                else
                                    " exe "norm! \<Esc>gi\<CR>\<Right>"
                                    " exe "norm! \<Esc>a\<C-G>u\<C-M>"
                                    call feedkeys("\<Esc>gi\<C-G>u\<C-M>",'n')
                                    " norm! o
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#action#ins_c_enter() "{{{
                                if getline('.') =~ s:p.table
                                    call riv#table#newline('sepr')
                                else
                                    call riv#list#new(0)
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#action#ins_s_enter() "{{{
                                if getline('.') =~ s:p.table
                                    call cursor(riv#table#nextline())
                                else
                                    call riv#list#new(1)
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#action#ins_m_enter() "{{{
                                if getline('.') =~ s:p.table
                                    call riv#table#newline('head')
                                else
                                    call riv#list#new(-1)
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! riv#action#ins_backspace() "{{{
                                let [row,col] = getpos('.')[1:2]
                                let line = getline('.')
                                if s:is_row_bgns_blank(col, line)
                                    let cmd = riv#insert#shiftleft_bs(row,col)
                                else
                                    let cmd = ""
                                endif
                                return  !empty(cmd) ? cmd : "\<BS>"
                            endfun "}}}
    1              0.000003 fun! riv#action#ins_backspace2() "{{{
                                " Test Test
                                " The
                                let [row,col] = getpos('.')[1:2]
                                let line = getline('.')
                                if s:is_row_bgns_blank(col, line)
                                    let cmd = riv#insert#shiftleft(row,col)
                                else
                                    let cmd = ""
                                endif
                                let cmd =  !empty(cmd) ? cmd : "\<BS>"
                                exe "norm! i".cmd
                            endfun "}}}
                            
                            
    1              0.000009 fun! s:is_in_list_item(col,line) "{{{
                                " it's the col before last space in list-item
                                return a:col <= matchend(a:line, s:p.all_list)
                            endfun "}}}
    1              0.000012 fun! s:is_row_bgns_blank(col,line) "{{{
                                " it's the col include last space in a line
                                return a:col <= matchend(a:line, '^\s*') + 1
                            endfun "}}}
    1              0.000005 fun! s:is_in_table(line) "{{{
                                return a:line =~ s:p.table
                            endfun "}}}
    1              0.000003 fun! riv#action#nor_tab() "{{{
                                call cursor(riv#table#nextcell())
                            endfun "}}}
    1              0.000004 fun! riv#action#ins_tab() "{{{
                            " tab for insert mode.
                            " to support other command. 
                            " the g:riv_i_tab_pum_next is used to act as '<C-N>' when pumvisible
                            " the g:riv_i_tab_user_cmd is used to execute user defined command or '\<Tab>'
                            " the g:riv_i_stab_user_cmd is used to execute user defined command 
                            
                                let [row,col] = getpos('.')[1:2]
                                let line = getline('.')
                            
                                if pumvisible() && g:riv_i_tab_pum_next
                                    return "\<C-N>"
                                elseif s:is_in_table(line)
                                    " Format the table and find the cell.
                                    return "\<C-O>:call cursor(riv#table#nextcell())\<CR>"
                                elseif s:is_in_list_item(col, line)
                                    " before the list item, shift the list
                                    return "\<C-O>:call riv#list#shift('+')\<CR>"
                                elseif s:is_row_bgns_blank(col, line)
                                    let cmd = riv#insert#shiftright(row,col)
                                else
                                    let cmd = ''
                                endif
                            
                                " We will execute user cmd only when there were no cmd context.
                                if !empty(cmd)
                                    return cmd
                                else
                                    if !empty(g:riv_i_tab_user_cmd) 
                                        return g:riv_i_tab_user_cmd
                                    else
                                        return "\<Tab>"
                                    endif
                                endif
                            endfun "}}}
    1              0.000004 fun! riv#action#ins_stab() "{{{
                                let [row,col] = getpos('.')[1:2]
                                let line = getline('.')
                            
                                if pumvisible() && g:riv_i_tab_pum_next
                                    return "\<C-P>"
                                elseif s:is_in_table(line)
                                    " Format the table and find the cell.
                                    return "\<C-O>:call cursor(riv#table#prevcell())\<CR>"
                                elseif s:is_in_list_item(col, line)
                                    " before the list item, shift the list
                                    return "\<C-O>:call riv#list#shift('-')\<CR>"
                                elseif s:is_row_bgns_blank(col, line)
                                    let cmd = riv#insert#shiftleft(row,col)
                                else
                                    let cmd = '' 
                                endif
                            
                                if !empty(cmd)
                                    return cmd
                                else
                                    if !empty(g:riv_i_stab_user_cmd) 
                                        return g:riv_i_stab_user_cmd
                                    else
                                        return "\<BS>"
                                    endif
                                endif
                            endfun "}}}
                            
    1   0.000028   0.000023 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save
                            " vim:fdm=marker:

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/create.vim
Sourced 1 time
Total time:   0.000661
 Self time:   0.000661

count  total (s)   self (s)
                            "=============================================
                            "    Name: create.vim
                            "    File: riv/create.vim
                            " Summary: Create miscellaneous things.
                            "  Author: Rykka G.Forest
                            "  Update: 2014-08-16
                            "=============================================
    1              0.000021 let s:cpo_save = &cpo
    1              0.000020 set cpo-=C
                            
    1              0.000004 let s:p = g:_riv_p
                            
    1              0.000007 let s:months = g:_riv_t.month_names
                            " link "{{{
                            
    1              0.000006 fun! s:norm_ref(str) "{{{
                                " return normalized ref name
                                if a:str !~ '\v^'.s:p.ref_name.'$'
                                    return '`'.a:str.'`_'
                                else
                                    return ''.a:str.'_'
                                endif
                            endfun "}}}
    1              0.000003 fun! s:norm_tar(str) "{{{
                                " return normalized tar name
                                " >>> echo s:norm_tar_line('ÂÖ∂‰ªñ', 'hello.rst')
                                " .. _ÂÖ∂‰ªñ: hello.rst
                                " >>> echo s:norm_tar_line('sep one.rst', 'hello.rst')
                                " .. _`sep one.rst`: hello.rst
                                if a:str !~ '\v^'.s:p.ref_name.'$'
                                    return '.. _`'.a:str.'`: '
                                else
                                    return '.. _'.a:str.': '
                                endif
                            endfun "}}}
    1              0.000003 fun! s:normal_phase(text) "{{{
                                " remove the __ `` []
                                " >>> echo s:normal_phase('`te fe | st:_`_')
                                " te fe | st:_
                                let text = substitute(a:text ,'\v(^__=|_=_$)','','g')
                                let text = substitute(text ,'\v(^`|`$)','','g')
                                let text = substitute(text ,'\v(^\[|\]$)','','g')
                                return text
                            endfun "}}}
                            
    1              0.000005 fun! s:expand_file_link(file) "{{{
                                " all with ``
                                " when file_link_style = 1
                                " the name with rst and is relative will be sub to .html
                                " the rel directory will add index.html
                                " other's unchanged
                                " when file_link_style =2
                                " the name with [xx] and is relative will be sub to .html
                                " the rel directory with [] will add index.html
                                " other unchanged.
                                let file = a:file
                                if riv#path#file_link_style() == 2 && !empty(file)
                                    let file = matchstr(file, '^\[\zs.*\ze\]$')
                                endif
                                if !riv#path#is_relative(file)
                                        let tar = file
                                        let loc = file
                                elseif riv#path#is_directory(file)
                                    let tar = file 
                                    let loc = file.'index.html'
                                else
                                    if riv#path#is_ext(file)
                                        let tar = file 
                                        let loc = fnamemodify(file, ':r').'.html' 
                                    elseif fnamemodify(file, ':e') == '' && riv#path#file_link_style() == 2
                                        let tar = file 
                                        let loc = file.'index.html'
                                    else
                                        let tar = file 
                                        let loc = file.'index.html'
                                    endif
                                endif
                                let ref = s:norm_ref(file)
                                return [ref, tar, loc]
                            endfun "}}}
                            
    1              0.000003 fun! s:expand_link(word,...) "{{{
                                " expand file, and let the refname expand
                                let word = a:word
                                if word=~ riv#ptn#link_file()
                                    return s:expand_file_link(word)
                                else
                                    if word =~ '^[[:alnum:]]\{40}$' && !a:0 
                                        " For github
                                        let loc = word
                                        let [ref, tar] = [word[:7].'_', '.. _' . word[:7].': ']
                                    elseif word =~ s:p.link_ref_footnote
                                        " footnote, remove '[' and ']'
                                        let trim = strpart(word,  0 , len(word)-1)
                                        let ref = word
                                        let loc = a:0 ? a:1 : word
                                        let tar = '.. '.trim.' '
                                    elseif word =~ s:p.link_ref_normal
                                        let trim = strpart(word,  0 , len(word)-1)
                                        let ref = word
                                        let loc = a:0 ? a:1 : trim
                                        let tar = '.. _'.trim.': '
                                    elseif word =~ s:p.link_ref_anonymous
                                        " anonymous link
                                        let ref = word
                                        let loc = a:0 ? a:1 : s:normal_phase(word)
                                        let tar = '__ '
                                    elseif word =~ s:p.link_ref_phase
                                        let trim = s:normal_phase(word)
                                        let ref = word
                                        let _tar = substitute(word, '\v(^__=|_=_$)','','g')
                                        let loc = a:0 ? a:1 : trim
                                        let tar = '.. _'._tar.': '
                                    else
                                        let loc = a:0 ? a:1 : word
                                        let ref = s:norm_ref(word)
                                        let tar = s:norm_tar(word)
                                    endif
                                    return [ref, tar, loc]
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! s:get_cWORD_obj() "{{{
                                " return current cWORD 
                                " str, start ,end
                                " NOTE: This is unicode compatible.
                                let line = getline('.')
                                let ptn = printf('\%%%dc.', col('.'))
                                let obj = {}
                                if matchstr(line, ptn)=~'\S'
                                    let ptn = '\S*'.ptn.'\S*'
                                    let obj.str = matchstr(line, ptn)
                                    let obj.start = match(line, ptn)
                                    let obj.end  = matchend(line, ptn)
                                endif
                                return obj
                            endfun "}}}
    1              0.000004 fun! s:get_phase_obj() "{{{
                                " return current `xxx xxx`__
                                let line = getline('.')
                                let col = col('.')
                                let ptn = printf('`[^`]*\%%%dc[^`]*`__\?\|\%%%dc`[^`]*`__\?', col, col)
                                let obj = {}
                                let start = match(line, ptn)
                                if start != -1
                                    let obj.start = start
                                    let obj.str = matchstr(line, ptn)
                                    let obj.end  = matchend(line, ptn)
                                endif
                                return obj
                            endfun "}}}
    1              0.000003 fun! riv#create#link(...) range "{{{
                                " TODO: add visual mode support for creating phase link.
                                " if a:0 && a:1 == 'v'
                                "     echom 'V'
                                "     let _v = @v
                                "     " get visual lines
                                "     norm! gv"vy
                                "     let vs = @v
                                "     let @v = _v
                                "     echom vs
                                " endif
                                "
                                let [row, col] = [line('.'), col('.')]
                                let line = getline(row)
                                let eof = line('$')
                            
                                let obj = s:get_phase_obj()
                                if empty(obj)
                                    let obj = s:get_cWORD_obj()
                                endif
                            
                                if !empty(obj)
                                    let word = obj.str
                                    let idx  = obj.start + 1
                                    let end  = obj.end + 1
                                else
                                    let word = input("Input link name: ")
                                    if word =~ '^\s*$' | return | endif
                                    let idx = col
                                    let end = col
                                endif
                            
                                let _loc = word
                            
                                " If it's a relative file path, then expand to PATH/index.rst
                                if riv#path#is_directory(_loc) 
                                    \ && riv#path#is_relative(_loc)
                                    let _loc = _loc . riv#path#idx_file()
                                    " remove the final slash
                                    " NOTE: removed all '/' though this should not be happended
                                    let word = substitute(word, '/\+$', '' ,'')
                                    let [ref, tar, loc] = s:expand_link(word, _loc)
                                else
                                    let [ref, tar, loc] = s:expand_link(word)
                                endif
                            
                                let loc = input("\nInput link location of '". ref . "':\n", loc, "file")
                            
                                if loc =~ '^\s*$' | return | endif
                            
                                let tar_line = tar.loc
                                
                                " Change current line with Ref
                                let line = substitute(line, '\%>'.(idx-1).'c.*\%<'.(end+1).'c', ref, '')
                                call setline(row , line)
                                
                                " Append target line
                                if g:riv_create_link_pos == '$' && tar !~ '^__'
                                    if  getline(eof) =~ '\v^\s*$|^\.\.%(\s|$)'
                                        call append(eof, [tar_line])
                                    else
                                        call append(eof, ["",tar_line])
                                    endif
                                else
                                    " anonymous line
                                    call append(row, ["",tar_line])
                                endif
                                redraw
                                call riv#echo('Link Created.')
                            
                            endfun "}}}
                            "}}}
                            
                            " scratch "{{{
    1              0.000003 fun! riv#create#scratch() "{{{
                                call riv#file#split(riv#path#scratch_path() . strftime("%Y-%m-%d") . riv#path#ext())
                            endfun "}}}
    1              0.000003 fun! s:format_src_index() "{{{
                                " category scratch by month and format it 4 items a line
                                let path = riv#path#scratch_path()
                                if !isdirectory(path)
                                    return -1
                                endif
                                let files = split(glob(path.'*'.riv#path#ext()),'\n')
                                "
                                let dates = filter(map(copy(files), 'fnamemodify(v:val,'':t:r'')'),'v:val=~''[[:digit:]_-]\+'' ')
                            
                                " create a years dictionary contains year dict, 
                                " which contains month dict, which contains days list
                                let years = {}
                                for date in dates
                                    let [_,year,month,day;rest] = matchlist(date, '\(\d\{4}\)-\(\d\{2}\)-\(\d\{2}\)')
                                    if !has_key(years, year)
                                        let years[year] = {}
                                    endif
                                    if !has_key(years[year], month)
                                        let years[year][month] = []
                                    endif
                                    call add(years[year][month], date)
                                endfor
                                
                                let lines = []
                                for year in sort(keys(years))
                                    call add(lines, "Year ".year)
                                    call add(lines, "=========")
                                    for month in sort(keys(years[year]))
                                        call add(lines, "")
                                        call add(lines, s:months[month-1])
                                        call add(lines, repeat('-', strwidth(s:months[month-1])))
                                        let line_lst = [] 
                                        for day in sort(years[year][month])
                                            if riv#path#file_link_style() == 1 
                                                let f = printf("[[%s]]",day)
                                            elseif riv#path#file_link_style() == 2 
                                                let f = printf(":doc:`%s`",day)
                                            else
                                                let f = printf("%s".riv#path#ext(),day)
                                            endif
                                            call add(line_lst, f)
                                            if len(line_lst) == 4
                                                call add(lines, join(line_lst, "    "))
                                                let line_lst = [] 
                                            endif
                                        endfor
                                        call add(lines, join(line_lst, "    "))
                                    endfor
                                    call add(lines, "")
                                endfor
                            
                                let file = path. riv#path#idx_file()
                                call writefile(lines , file)
                            endfun "}}}
                            
    1              0.000003 fun! riv#create#view_scr() "{{{
                                call s:format_src_index()
                                let path = riv#path#scratch_path()
                             
                                call riv#file#split(path . riv#path#idx_file() )
                            endfun "}}}
                            
    1              0.000003 fun! s:escape(str) "{{{
                                return escape(a:str, '.^$*[]\~')
                            endfun "}}}
    1              0.000004 fun! s:escape_file_ptn(file) "{{{
                                if riv#path#file_link_style() == 2
                                    return   '\%(^\|\s\)\zs\[' . fnamemodify(s:escape(a:file), ':t:r') 
                                                \ . '\]\ze\%(\s\|$\)'
                                else
                                    return   '\%(^\|\s\)\zs' . fnamemodify(s:escape(a:file), ':t')
                                                \ . '\ze\%(\s\|$\)'
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#create#delete() "{{{
                                let file = expand('%:p')
                                if input("Deleting '".file."'\n Continue? (y/N)?") !~?"y"
                                    return 
                                endif
                                let ptn = s:escape_file_ptn(file)
                                call delete(file)
                             
                                if riv#path#is_rel_to_root(file)
                                    let index = expand('%:p:h'). '/' . riv#path#idx_file()
                                    if filereadable(index)
                                        call riv#file#edit(index)
                                        let f_idx = filter(range(1,line('$')),'getline(v:val)=~ptn')
                                        for i in f_idx
                                            call setline(i, substitute(getline(i), ptn ,'','g'))
                                        endfor
                                        update | redraw
                                        call riv#echo(len(f_idx).' relative link in index deleted.')
                                    endif
                                endif
                            
                            endfun "}}}
                            "}}}
                            
                            " misc "{{{
    1              0.000003 fun! riv#create#foot() "{{{
                                " return a link target and ref def.
                                " DONE: 2012-06-10 get buf last footnote.
                                " DONE: 2012-06-10 they should add at different position.
                                "       current and last.
                                "   
                                " put cursor in last line and start backward search.
                                " get the last footnote and return.
                            
                                let id = riv#link#get_last_foot()[1] + 1
                                let line = getline('.') 
                            
                                if line =~ s:p.table
                                    let tar = substitute(line,'\%' . col(".") . 'c' , ' ['.id.']_ ', '')
                                elseif line =~ '\S\@<!$'
                                " have \s before eol.
                                    let tar = line."[".id."]_"
                                else
                                    let tar = line." [".id."]_"
                                endif
                                let footnote = input("[".id."]: Your footnote message is?\n")
                                if empty(footnote) | return | endif
                                let def = ".. [".id."] ".footnote
                                call setline(line('.'),tar)
                                call append(line('$'),def)
                                
                            endfun "}}}
    1              0.000002 fun! riv#create#date(...) "{{{
                                if a:0 && a:1 == 1
                                    exe "normal! a" . strftime('%H:%M:%S') . "\<ESC>"
                                else
                                    exe "normal! a" . strftime('%Y-%m-%d') . "\<ESC>"
                                endif
                            endfun "}}}
    1              0.000002 fun! riv#create#auto_mkdir() "{{{
                                let dir = expand('%:p:h')
                                if !isdirectory(dir)
                                    call mkdir(dir,'p')
                                endif
                            endfun "}}}
    1              0.000003 fun! riv#create#git_commit_url() "{{{
                                if !exists("*fugitive#repo")
                                    call riv#warning(" NO fugitive installed.")
                                    return
                                endif
                                try
                                    let sha = fugitive#repo().rev_parse('HEAD')
                                catch
                                    call riv#warning(" NOT a valid repo.")
                                    return
                                endtry
                            
                                let [ref, tar, loc] = s:expand_link(sha)
                            
                                call append(line('.'), [ref])
                            
                                if g:riv_create_link_pos == '$' 
                                    let eof = line('$')
                                    if  getline(eof) =~ '\v^\s*$|^\.\.%(\s|$)'
                                        call append(eof, [tar.loc])
                                    else
                                        call append(eof, ["",tar.loc])
                                    endif
                                else
                                    call append(line('.'), ["",tar.loc])
                                endif
                            endfun "}}}
                            
    1              0.000004 fun! riv#create#wrap_inline(sign,mode) "{{{
                                " We should consider when in visual mode and insert mode.
                                " **This** is a Test
                                let region = a:mode == 'v' ? 'gv' : 'viW' 
                                let recov = a:mode == 'v' ? "\<Esc>gv".(len(a:sign)*2).'l' : a:mode == 'n' ? "\<Esc>" : ''
                                exe 'norm!' region.'c'.a:sign."\<C-R>\"".a:sign.recov 
                            endfun "}}}
    1              0.000003 fun! riv#create#transition() "{{{
                                let lines = ['','----','']
                                call append('.',lines)
                                norm! 4j
                            endfun "}}}
    1              0.000003 fun! riv#create#hyperlink() "{{{
                                exe "norm! \<Esc>Bihttp://\<Esc>E"
                            endfun "}}}
    1              0.000002 fun! riv#create#exp_mark() "{{{
                                exe "norm! A\<Enter>\<Enter>\<Esc>A.. "
                                starti!
                            endfun "}}}
    1              0.000003 fun! riv#create#literal_block() "{{{
                                exe "norm! A::\<Enter>\<Enter>    "
                                starti!
                            endfun "}}}
                            "}}}
                            
                            " cmd helper "{{{
    1              0.000003 fun! s:load_cmd() "{{{
                                let list = items(g:riv_default.buf_maps)
                                return map(list, 'string(v:val[0]).string(v:val[1])')
                            endfun "}}}
    1              0.000003 fun! riv#create#cmd_helper() "{{{
                                " showing all cmds
                                
                                let s:cmd = riv#helper#new()
                                " let s:cmd.contents = s:load_cmd()
                                let s:cmd.maps['<Enter>'] = 'riv#create#enter'
                                " let s:cmd.maps['<KEnter>'] = 'riv#create#enter'
                                " let s:cmd.maps['<2-leftmouse>'] = 'riv#create#enter'
                                " let s:cmd.syntax_func  = "riv#create#syn_hi"
                                let s:cmd.contents = [s:load_cmd(),
                                            \filter(copy(s:cmd.contents[0]),'v:val=~s:p.todo_done '),
                                            \filter(copy(s:cmd.contents[0]),'v:val!~s:p.todo_done '),
                                            \]
                                let s:cmd.input=""
                                cal s:cmd.win()
                            endfun "}}}
                            "}}}
                            
    1              0.000019 if expand('<sfile>:p') == expand('%:p') "{{{
                                call doctest#start()
    1              0.000002 endif "}}}
                            
    1              0.000016 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/sign.vim
Sourced 1 time
Total time:   0.001717
 Self time:   0.001488

count  total (s)   self (s)
    1              0.000006 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Draws error and warning signs into signcolumn
                            
                            " This flag can be set to some integer to control the maximum number of signs
                            " that ALE will set.
    1              0.000007 let g:ale_max_signs = get(g:, 'ale_max_signs', -1)
                            " This flag can be set to 1 to enable changing the sign column colors when
                            " there are errors.
    1              0.000022 let g:ale_change_sign_column_color = get(g:, 'ale_change_sign_column_color', 0)
                            " These variables dictate what signs are used to indicate errors and warnings.
    1              0.000010 let g:ale_sign_error = get(g:, 'ale_sign_error', '>>')
    1              0.000006 let g:ale_sign_style_error = get(g:, 'ale_sign_style_error', g:ale_sign_error)
    1              0.000005 let g:ale_sign_warning = get(g:, 'ale_sign_warning', '--')
    1              0.000007 let g:ale_sign_style_warning = get(g:, 'ale_sign_style_warning', g:ale_sign_warning)
    1              0.000006 let g:ale_sign_info = get(g:, 'ale_sign_info', g:ale_sign_warning)
    1              0.000006 let g:ale_sign_priority = get(g:, 'ale_sign_priority', 30)
                            " This variable sets an offset which can be set for sign IDs.
                            " This ID can be changed depending on what IDs are set for other plugins.
                            " The dummy sign will use the ID exactly equal to the offset.
    1              0.000006 let g:ale_sign_offset = get(g:, 'ale_sign_offset', 1000000)
                            " This flag can be set to 1 to keep sign gutter always open
    1              0.000006 let g:ale_sign_column_always = get(g:, 'ale_sign_column_always', 0)
    1              0.000007 let g:ale_sign_highlight_linenrs = get(g:, 'ale_sign_highlight_linenrs', 0)
                            
    1              0.000017 let s:supports_sign_groups = has('nvim-0.4.2') || (v:version >= 801 && has('patch614'))
                            
    1              0.000040 if !hlexists('ALEErrorSign')
                                highlight link ALEErrorSign error
    1              0.000001 endif
                            
    1              0.000030 if !hlexists('ALEStyleErrorSign')
    1              0.000056     highlight link ALEStyleErrorSign ALEErrorSign
    1              0.000002 endif
                            
    1              0.000025 if !hlexists('ALEWarningSign')
                                highlight link ALEWarningSign todo
    1              0.000002 endif
                            
    1              0.000028 if !hlexists('ALEStyleWarningSign')
    1              0.000048     highlight link ALEStyleWarningSign ALEWarningSign
    1              0.000002 endif
                            
    1              0.000024 if !hlexists('ALEInfoSign')
                                highlight link ALEInfoSign ALEWarningSign
    1              0.000001 endif
                            
    1              0.000027 if !hlexists('ALESignColumnWithErrors')
    1              0.000050     highlight link ALESignColumnWithErrors error
    1              0.000001 endif
                            
    1              0.000115 function! ale#sign#SetUpDefaultColumnWithoutErrorsHighlight() abort
                                redir => l:output
                                    0verbose silent highlight SignColumn
                                redir end
                            
                                let l:highlight_syntax = join(split(l:output)[2:])
                                let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                            
                                if !empty(l:match)
                                    execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
                                elseif l:highlight_syntax isnot# 'cleared'
                                    execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
                                endif
                            endfunction
                            
    1              0.000033 if !hlexists('ALESignColumnWithoutErrors')
    1   0.000193   0.000029     call ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    1              0.000001 endif
                            
                            " Spaces and backslashes need to be escaped for signs.
    1              0.000005 function! s:EscapeSignText(sign_text) abort
                                return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')
                            endfunction
                            
                            " Signs show up on the left for error markers.
    1   0.000088   0.000072 execute 'sign define ALEErrorSign text=' . s:EscapeSignText(g:ale_sign_error)
                            \   . ' texthl=ALEErrorSign linehl=ALEErrorLine'
    1   0.000036   0.000023 execute 'sign define ALEStyleErrorSign text=' .  s:EscapeSignText(g:ale_sign_style_error)
                            \   . ' texthl=ALEStyleErrorSign linehl=ALEErrorLine'
    1   0.000079   0.000067 execute 'sign define ALEWarningSign text=' . s:EscapeSignText(g:ale_sign_warning)
                            \   . ' texthl=ALEWarningSign linehl=ALEWarningLine'
    1   0.000035   0.000023 execute 'sign define ALEStyleWarningSign text=' . s:EscapeSignText(g:ale_sign_style_warning)
                            \   . ' texthl=ALEStyleWarningSign linehl=ALEWarningLine'
    1   0.000079   0.000067 execute 'sign define ALEInfoSign text=' . s:EscapeSignText(g:ale_sign_info)
                            \   . ' texthl=ALEInfoSign linehl=ALEInfoLine'
    1              0.000003 sign define ALEDummySign
                            
    1              0.000004 if g:ale_sign_highlight_linenrs && has('nvim-0.3.2')
                                if !hlexists('ALEErrorSignLineNr')
                                    highlight link ALEErrorSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEStyleErrorSignLineNr')
                                    highlight link ALEStyleErrorSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEWarningSignLineNr')
                                    highlight link ALEWarningSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEStyleWarningSignLineNr')
                                    highlight link ALEStyleWarningSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEInfoSignLineNr')
                                    highlight link ALEInfoSignLineNr CursorLineNr
                                endif
                            
                                sign define ALEErrorSign numhl=ALEErrorSignLineNr
                                sign define ALEStyleErrorSign numhl=ALEStyleErrorSignLineNr
                                sign define ALEWarningSign numhl=ALEWarningSignLineNr
                                sign define ALEStyleWarningSign numhl=ALEStyleWarningSignLineNr
                                sign define ALEInfoSign numhl=ALEInfoSignLineNr
    1              0.000002 endif
                            
    1              0.000004 function! ale#sign#GetSignName(sublist) abort
                                let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
                                for l:item in a:sublist
                                    let l:item_priority = ale#util#GetItemPriority(l:item)
                            
                                    if l:item_priority > l:priority
                                        let l:priority = l:item_priority
                                    endif
                                endfor
                            
                                if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'
                            endfunction
                            
    1              0.000004 function! s:PriorityCmd() abort
                                if s:supports_sign_groups
                                    return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif
                            endfunction
                            
    1              0.000003 function! s:GroupCmd() abort
                                if s:supports_sign_groups
                                    return ' group=ale '
                                else
                                    return ' '
                                endif
                            endfunction
                            
                            " Read sign data for a buffer to a list of lines.
    1              0.000003 function! ale#sign#ReadSigns(buffer) abort
                                redir => l:output
                                    silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd()
                                    \ . ' buffer=' . a:buffer
                                redir end
                            
                                return split(l:output, "\n")
                            endfunction
                            
    1              0.000003 function! ale#sign#ParsePattern() abort
                                if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " —Å—Ç—Ä–æ–∫–∞=1  id=1000001  –≥—Ä—É–ø–ø–∞=ale  –∏–º—è=ALEErrorSign
                                    " Ë°å=1  Ë≠òÂà•Â≠ê=1000001  „Ç∞„É´„Éº„Éó=ale  ÂêçÂâç=ALEWarningSign
                                    " l√≠nea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " —Å—Ç—Ä–æ–∫–∞=1  id=1000001  –∏–º—è=ALEErrorSign
                                    " Ë°å=1  Ë≠òÂà•Â≠ê=1000001  ÂêçÂâç=ALEWarningSign
                                    " l√≠nea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
                                endif
                            
                                return l:pattern
                            endfunction
                            
                            " Given a list of lines for sign output, return a List of [line, id, group]
    1              0.000005 function! ale#sign#ParseSigns(line_list) abort
                                let l:pattern =ale#sign#ParsePattern()
                                let l:result = []
                                let l:is_dummy_sign_set = 0
                            
                                for l:line in a:line_list
                                    let l:match = matchlist(l:line, l:pattern)
                            
                                    if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [
                                            \   str2nr(l:match[1]),
                                            \   str2nr(l:match[2]),
                                            \   l:match[3],
                                            \])
                                        endif
                                    endif
                                endfor
                            
                                return [l:is_dummy_sign_set, l:result]
                            endfunction
                            
    1              0.000003 function! ale#sign#FindCurrentSigns(buffer) abort
                                let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                return ale#sign#ParseSigns(l:line_list)
                            endfunction
                            
                            " Given a loclist, group the List into with one List per line.
    1              0.000004 function! s:GroupLoclistItems(buffer, loclist) abort
                                let l:grouped_items = []
                                let l:last_lnum = -1
                            
                                for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
                                return l:grouped_items
                            endfunction
                            
    1              0.000005 function! s:UpdateLineNumbers(buffer, current_sign_list, loclist) abort
                                let l:line_map = {}
                                let l:line_numbers_changed = 0
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
                                for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
                                if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif
                            endfunction
                            
    1              0.000004 function! s:BuildSignMap(buffer, current_sign_list, grouped_items) abort
                                let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
                                if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
                                    let l:selected_grouped_items = a:grouped_items
                                endif
                            
                                let l:sign_map = {}
                                let l:sign_offset = g:ale_sign_offset
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(
                                    \   l:sign_info.current_name_list,
                                    \   l:sign_info.new_name
                                    \)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                return l:sign_map
                            endfunction
                            
    1              0.000007 function! ale#sign#GetSignCommands(buffer, was_sign_set, sign_map) abort
                                let l:command_list = []
                                let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
                                if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '
                                    \   .  g:ale_sign_offset
                                    \   . s:GroupCmd()
                                    \   . s:PriorityCmd()
                                    \   . ' line=1 name=ALEDummySign '
                                    \   . ' buffer=' . a:buffer
                                    \)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
                                for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '
                                            \   . (l:info.new_id)
                                            \   . s:GroupCmd()
                                            \   . s:PriorityCmd()
                                            \   . ' line=' . l:line_str
                                            \   . ' name=' . (l:info.new_name)
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
                                for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '
                                            \   . l:current_id
                                            \   . s:GroupCmd()
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endfor
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
                                if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '
                                    \   . g:ale_sign_offset
                                    \   . s:GroupCmd()
                                    \   . ' buffer=' . a:buffer
                                    \)
                                endif
                            
                                return l:command_list
                            endfunction
                            
                            " This function will set the signs which show up on the left.
    1              0.000006 function! ale#sign#SetSigns(buffer, loclist) abort
                                if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
                                let [l:is_dummy_sign_set, l:current_sign_list] =
                                \   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
                                call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
                                let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
                                let l:sign_map = s:BuildSignMap(
                                \   a:buffer,
                                \   l:current_sign_list,
                                \   l:grouped_items,
                                \)
                            
                                let l:command_list = ale#sign#GetSignCommands(
                                \   a:buffer,
                                \   l:is_dummy_sign_set,
                                \   l:sign_map,
                                \)
                            
                                " Change the sign column color if the option is on.
                                if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
                                for l:command in l:command_list
                                    silent! execute l:command
                                endfor
                            
                                " Reset the sign column color when there are no more errors.
                                if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif
                            endfunction
                            
                            " Remove all signs.
    1              0.000003 function! ale#sign#Clear() abort
                                if s:supports_sign_groups
                                    sign unplace group=ale *
                                else
                                    sign unplace *
                                endif
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/list.vim
Sourced 1 time
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
                            " Author: Bjorn Neergaard <bjorn@neersighted.com>, modified by Yann fery <yann@fery.me>
                            " Description: Manages the loclist and quickfix lists
                            
                            " This flag dictates if ale open the configured loclist
    1              0.000010 let g:ale_open_list = get(g:, 'ale_open_list', 0)
                            " This flag dictates if ale keeps open loclist even if there is no error in loclist
    1              0.000007 let g:ale_keep_list_window_open = get(g:, 'ale_keep_list_window_open', 0)
                            " This flag dictates that quickfix windows should be opened vertically
    1              0.000006 let g:ale_list_vertical = get(g:, 'ale_list_vertical', 0)
                            " The window size to set for the quickfix and loclist windows
    1              0.000006 let g:ale_list_window_size = get(g:, 'ale_list_window_size', 10)
                            " A string format for the loclist messages.
    1              0.000010 let g:ale_loclist_msg_format = get(g:, 'ale_loclist_msg_format',
                            \   get(g:, 'ale_echo_msg_format', '%code: %%s')
                            \)
                            
    1              0.000005 if !exists('s:timer_args')
    1              0.000004     let s:timer_args = {}
    1              0.000001 endif
                            
                            " Return 1 if there is a buffer with buftype == 'quickfix' in bufffer list
    1              0.000003 function! ale#list#IsQuickfixOpen() abort
                                for l:buf in range(1, bufnr('$'))
                                    if getbufvar(l:buf, '&buftype') is# 'quickfix'
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " Check if we should open the list, based on the save event being fired, and
                            " that setting being on, or the setting just being set to `1`.
    1              0.000004 function! s:ShouldOpen(buffer) abort
                                let l:val = ale#Var(a:buffer, 'open_list')
                                let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                return l:val is 1 || (l:val is# 'on_save' && l:saved)
                            endfunction
                            
    1              0.000003 function! ale#list#GetCombinedList() abort
                                let l:list = []
                            
                                for l:info in values(g:ale_buffer_info)
                                    call extend(l:list, l:info.loclist)
                                endfor
                            
                                call sort(l:list, function('ale#util#LocItemCompareWithText'))
                                call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
                                return l:list
                            endfunction
                            
    1              0.000004 function! s:FixList(buffer, list) abort
                                let l:format = ale#Var(a:buffer, 'loclist_msg_format')
                                let l:new_list = []
                            
                                for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
                                return l:new_list
                            endfunction
                            
    1              0.000003 function! s:WinFindBuf(buffer) abort
                                return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]
                            endfunction
                            
    1              0.000005 function! s:SetListsImpl(timer_id, buffer, loclist) abort
                                let l:title = expand('#' . a:buffer . ':p')
                            
                                if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
                                    let l:ids = s:WinFindBuf(a:buffer)
                            
                                    for l:id in l:ids
                                        if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
                                    endfor
                                endif
                            
                                " Save the current view before opening/closing any window
                                call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
                                if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
                                if !ale#engine#IsCheckingBuffer(a:buffer)
                                    call s:CloseWindowIfNeeded(a:buffer)
                                endif
                            endfunction
                            
                            " Try to restore the window view after closing any of the lists to avoid making
                            " the it moving around, especially useful when on insert mode
    1              0.000004 function! s:RestoreViewIfNeeded(buffer) abort
                                let l:saved_view = getbufvar(a:buffer, 'ale_winview', {})
                            
                                " Saved view is empty, can't do anything
                                if empty(l:saved_view)
                                    return
                                endif
                            
                                " Check wether the cursor has moved since linting was actually requested. If
                                " the user has indeed moved lines, do nothing
                                let l:current_view = winsaveview()
                            
                                if l:current_view['lnum'] != l:saved_view['lnum']
                                    return
                                endif
                            
                                " Anchor view by topline if the list is set to open horizontally
                                if ale#Var(a:buffer, 'list_vertical') == 0
                                    call winrestview({'topline': l:saved_view['topline']})
                                endif
                            endfunction
                            
    1              0.000004 function! ale#list#SetLists(buffer, loclist) abort
                                if get(g:, 'ale_set_lists_synchronously') == 1
                                \|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(
                                    \   0,
                                    \   function('s:SetListsImpl'),
                                    \   [a:buffer, a:loclist],
                                    \)
                                endif
                            endfunction
                            
    1              0.000005 function! s:CloseWindowIfNeeded(buffer) abort
                                if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
                                    return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            endfunction

SCRIPT  /home/kc/.vim/plugged/ale/autoload/ale/highlight.vim
Sourced 1 time
Total time:   0.000835
 Self time:   0.000835

count  total (s)   self (s)
    1              0.000005 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: This module implements error/warning highlighting.
                            
    1              0.000035 if !hlexists('ALEError')
                                highlight link ALEError SpellBad
    1              0.000002 endif
                            
    1              0.000029 if !hlexists('ALEStyleError')
    1              0.000053     highlight link ALEStyleError ALEError
    1              0.000002 endif
                            
    1              0.000025 if !hlexists('ALEWarning')
                                highlight link ALEWarning SpellCap
    1              0.000001 endif
                            
    1              0.000027 if !hlexists('ALEStyleWarning')
    1              0.000049     highlight link ALEStyleWarning ALEWarning
    1              0.000002 endif
                            
    1              0.000024 if !hlexists('ALEInfo')
                                highlight link ALEInfo ALEWarning
    1              0.000002 endif
                            
                            " The maximum number of items for the second argument of matchaddpos()
    1              0.000004 let s:MAX_POS_VALUES = 8
    1              0.000004 let s:MAX_COL_SIZE = 1073741824 " pow(2, 30)
                            
    1              0.000010 let s:has_nvim_highlight = exists('*nvim_buf_add_highlight') && exists('*nvim_buf_clear_namespace')
                            
    1              0.000003 if s:has_nvim_highlight
                                let s:ns_id = nvim_create_namespace('ale_highlight')
    1              0.000002 endif
                            
                            " Wrappers are necessary to test this functionality by faking the calls in tests.
    1              0.000007 function! ale#highlight#nvim_buf_add_highlight(buffer, ns_id, hl_group, line, col_start, col_end) abort
                                " Ignore all errors for adding highlights.
                                try
                                    call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
                                endtry
                            endfunction
                            
    1              0.000006 function! ale#highlight#nvim_buf_clear_namespace(buffer, ns_id, line_start, line_end) abort
                                call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)
                            endfunction
                            
    1              0.000005 function! ale#highlight#CreatePositions(line, col, end_line, end_col) abort
                                if a:line >= a:end_line
                                    " For single lines, just return the one position.
                                    return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =
                                \   [[a:line, a:col, s:MAX_COL_SIZE]]
                                \   + range(a:line + 1, a:end_line - 1)
                                \   + [[a:end_line, 1, a:end_col]]
                            
                                return map(
                                \   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),
                                \   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',
                                \)
                            endfunction
                            
                            " Given a loclist for current items to highlight, remove all highlights
                            " except these which have matching loclist item entries.
                            
    1              0.000004 function! ale#highlight#RemoveHighlights() abort
                                if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
                            " Same semantics of matchaddpos but will use nvim_buf_add_highlight if
                            " available. This involves iterating over the position list, switching from
                            " 1-based indexing to 0-based indexing, and translating the multiple ways
                            " that position can be specified for matchaddpos into line + col_start +
                            " col_end.
    1              0.000005 function! s:matchaddpos(group, pos_list) abort
                                if s:has_nvim_highlight
                                    for l:pos in a:pos_list
                                        let l:line = type(l:pos) == v:t_number
                                        \   ? l:pos - 1
                                        \   : l:pos[0] - 1
                            
                                        if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
                                        else
                                            let l:col_start = l:pos[1] - 1
                                            let l:col_end = l:col_start + get(l:pos, 2, 1)
                                        endif
                            
                                        call ale#highlight#nvim_buf_add_highlight(
                                        \   bufnr(''),
                                        \   s:ns_id,
                                        \   a:group,
                                        \   l:line,
                                        \   l:col_start,
                                        \   l:col_end,
                                        \)
                                    endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
                                endif
                            endfunction
                            
    1              0.000005 function! s:highlight_line(bufnr, lnum, group) abort
                                call s:matchaddpos(a:group, [a:lnum])
                            endfunction
                            
    1              0.000055 function! s:highlight_range(bufnr, range, group) abort
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
                                call map(
                                \   ale#highlight#CreatePositions(
                                \       a:range.lnum,
                                \       a:range.col,
                                \       a:range.end_lnum,
                                \       a:range.end_col
                                \   ),
                                \   's:matchaddpos(a:group, v:val)'
                                \)
                            endfunction
                            
    1              0.000004 function! ale#highlight#UpdateHighlights() abort
                                let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled
                                \   ? get(b:, 'ale_highlight_items', [])
                                \   : []
                            
                                call ale#highlight#RemoveHighlights()
                            
                                for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {
                                    \   'lnum': l:item.lnum,
                                    \   'col': l:item.col,
                                    \   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),
                                    \   'end_col': get(l:item, 'end_col', l:item.col)
                                    \}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
                                endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
                                if !g:ale_set_signs
                                    let l:available_groups = {
                                    \   'ALEWarningLine': hlexists('ALEWarningLine'),
                                    \   'ALEInfoLine': hlexists('ALEInfoLine'),
                                    \   'ALEErrorLine': hlexists('ALEErrorLine'),
                                    \}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
    1              0.000006 function! ale#highlight#BufferHidden(buffer) abort
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
                                call ale#highlight#RemoveHighlights()
                            endfunction
                            
    1              0.000010 augroup ALEHighlightBufferGroup
    1              0.000206     autocmd!
    1              0.000014     autocmd BufEnter * call ale#highlight#UpdateHighlights()
    1              0.000009     autocmd BufHidden * call ale#highlight#BufferHidden(expand('<abuf>'))
    1              0.000003 augroup END
                            
    1              0.000005 function! ale#highlight#SetHighlights(buffer, loclist) abort
                                let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled
                                \   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')
                                \   : []
                            
                                " Set the list in the buffer variable.
                                call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
                                call ale#highlight#UpdateHighlights()
                            endfunction

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/fold.vim
Sourced 1 time
Total time:   0.001279
 Self time:   0.001279

count  total (s)   self (s)
                            "=============================================
                            "    Name: fold.vim
                            "    File: fold.vim
                            "  Author: Rykka G.F
                            "  Update: 2014-02-10
                            "=============================================
    1              0.000034 let s:cpo_save = &cpo
    1              0.000021 set cpo-=C
                            
    1              0.000006 let s:p = g:_riv_p
    1              0.000006 fun! s:init_stat(...) "{{{
                                let len = line('$')
                                let b:foldlevel = g:riv_fold_level
                                if len > g:riv_auto_fold1_lines && g:riv_auto_fold_force == 1
                                    let b:foldlevel = b:foldlevel >= 1 ? 1 : 0 
                                elseif len > g:riv_auto_fold2_lines && g:riv_auto_fold_force == 1
                                    let b:foldlevel = b:foldlevel >= 2 ? 2 : 0 
                                endif
                                " To avoid stuck with necompl
                                if !exists("b:riv_flist") || ( len(b:riv_flist) != len + 1 )
                                    call s:parse_from_start()
                                endif
                                " Todo: Parse from the first modified line.
                            endfun "}}}
                            " Parse "{{{
    1              0.000006 fun! s:parse_from_start() "{{{
                                redraw
                                echo "Parsing buf ..."
                                let len = line('$')
                                let b:riv_state = { 'l_chk':[], 
                                            \'matcher':[], 'sectmatcher':[], 
                                            \'sect_root': { 'parent': 'None'  , 'child':[] ,
                                            \  'bgn': 'sect_root'} ,
                                            \'list_root': { 'parent': 'None'  , 'child':[] ,
                                            \ 'bgn': 'list_root'} ,
                                            \  'None': { 'parent': 'None'  , 'child':[] ,
                                            \ 'bgn': 'None'} ,
                                            \}
                                let b:riv_obj = {'sect_root':b:riv_state.sect_root, 
                                            \ 'list_root':b:riv_state.list_root,
                                            \ 'None': b:riv_state.None }
                                " 3%
                                let b:riv_flist = map(range(len+1),'0')
                                let b:lines= ['']+getline(1,line('$'))+['']     " [-1] and [0] are blank
                                " 75%
                                for i in range(len+1)
                                    call s:check(i)
                                endfor
                                " 20%
                                call sort(b:riv_state.matcher,"s:sort_match")
                                call s:set_obj_dict()
                                call s:set_sect_end()
                                call s:set_fdl_list()
                                call s:set_td_child(b:riv_state.list_root)
                                call garbagecollect(1)
                                echon "Done"
                            endfun "}}}
    1              0.000013 let s:tmpfile = tempname()
    1              0.000005 fun! s:get_changed_range() "{{{
                                sil exe 'w !diff % - > ' s:tmpfile
                                let changes = []
                                for line in readfile(s:tmpfile)
                                    if line =~ '^<\|^>\|^---' || line=~ '^\d\+\%(,\d\+\)\=c'
                                        continue
                                    endif 
                                    call add(changes , line)
                                endfor 
                                if len(changes) == 0
                                    return [[0]]
                                elseif len(changes) >= 5
                                    return [[-1]]
                                endif 
                                let changed_list =[]
                                for change in changes
                                    if change =~ 'a\|d'
                                        let [b,a ] = split(change,'a\|d')
                                        let b_r = split(b,',')
                                        let a_r = split(a,',')
                                        let bran = b_r[-1] - b_r[0] + 1
                                        let aran = a_r[-1] - a_r[0] + 1
                                        let changed = [b_r[0] , (aran - bran)+1]
                                        call add(changed_list, changed)
                                    endif
                                endfor
                                return changed_list
                            endfun "}}}
    1              0.000006 fun! s:add_change_range(change_list) "{{{
                                if a:change_list[0][0] == 0
                                    return
                                elseif a:change_list[0][0] == -1
                                    call s:parse_from_start()
                                    return
                                endif
                                for change in a:change_list
                                    call s:add_in_len(change[0],change[1])
                                endfor
                            endfun "}}}
    1              0.000005 fun! s:add_in_len(bgn,len) "{{{
                                call s:add_d_len(b:riv_obj, a:bgn, a:len)
                                call s:add_l_len(b:riv_flist, a:bgn, a:len)
                            endfun "}}}
    1              0.000005 fun! s:add_d_len(dict, bgn, len) "{{{
                                let changed = {}
                                if a:len > 0
                                    let changed = filter(copy(a:dict),'v:key>a:bgn')
                                    for key in reverse(sort(keys(changed),'s:sort'))
                                        let changed[key+a:len] = changed[key]
                                        let changed[key+a:len].bgn += a:len
                                    endfor
                                elseif a:len < 0
                                    let changed = filter(copy(a:dict),'v:key>(a:bgn+a:len)')
                                    for key in sort(keys(changed),'s:sort')
                                        let changed[key+a:len] = changed[key]
                                        let changed[key+a:len].bgn += a:len
                                    endfor
                                endif
                                
                                call extend(a:dict, changed)
                            endfun "}}}
    1              0.000004 fun! s:sort(i1,i2) "{{{
                                return a:i1 - a:i2
                            endfun "}}}
    1              0.000005 fun! s:add_l_len(list, bgn, len) "{{{
                                if a:len > 0 
                                    call extend(a:list,map(range(a:len),'0'),a:bgn)
                                elseif a:len < 0
                                    call remove(a:list,a:bgn,a:bgn-a:len)
                                endif
                            endfun "}}}
                            "}}}
                            " Set "{{{
    1              0.000009 let s:sect_sep = g:riv_fold_section_mark
    1              0.000005 fun! s:set_obj_dict() "{{{
                                " Set the b:riv_obj dict which contains structure infos.
                                
                                let stat = b:riv_state
                                let mat = stat.matcher
                            
                                let sec_punc_list = []      " the punctuation list used by section
                            
                                let p_s_obj = stat.sect_root   " previous section object, init with root
                                let sec_lv = 0              " the section level calced by punc_list
                                let p_sec_lv = sec_lv       
                            
                                let lst_lv = 0              " current list_level
                                let p_lst_lv = 0
                                let p_l_obj = stat.list_root   " previous list object 
                                for m in mat
                                    let f = 0
                                    if m.type == 'sect'
                                        " Sect Part "{{{
                                        let level = index(sec_punc_list,m.attr)+1
                                        if level == 0
                                            call add(sec_punc_list,m.attr)
                                            let level = len(sec_punc_list)
                                        endif
                                        let lst_lv = 0
                                        let sec_lv = level
                                        let m.level = level
                                        
                            
                                        " Add child and parent to document object.
                                        if sec_lv > p_sec_lv
                                            let sec_num = 1
                                            let m.sec_num = sec_num
                                            call s:add_child(p_s_obj,m)
                                        elseif sec_lv == p_sec_lv
                                            let sec_num = p_sec_num + 1
                                            let m.sec_num =sec_num
                                            call s:add_brother(p_s_obj,m)
                                        elseif sec_lv < p_sec_lv 
                                            " create the next older of last item.
                                            for i in range(p_sec_lv - sec_lv+1)
                                                if p_s_obj.bgn == 'sect_root'
                                                    break
                                                endif
                                                let p_s_obj = s:get_parent(p_s_obj)
                                            endfor
                                            let brother = s:get_child(p_s_obj,-1)
                                            let sec_num = brother.sec_num+1
                                            let m.sec_num = sec_num
                                            call s:add_brother(brother, m)
                                        endif
                            
                                        let p_s_obj = m
                                        let p_sec_lv = sec_lv
                                        let p_sec_num = sec_num
                                        
                                        " Get the section text like 1-1 1-2 1-2-1
                                        let t_obj = m
                                        let t_lst = []
                                        while !empty(t_obj) && t_obj.bgn != 'sect_root'
                                            call add(t_lst, t_obj['sec_num'])
                                            let t_obj = s:get_parent(t_obj)
                                        endwhile
                                        let m.txt = join(reverse(t_lst), s:sect_sep)
                                        let p_sec_txt = m.txt
                            
                                        let b:riv_obj[m.bgn]   = m
                                        let b:riv_obj[m.bgn+1] = m
                                        if m['title_rows'] == 3
                                            let b:riv_obj[m.bgn+2] = m
                                        endif
                                        " End Sect Part "}}}
                                    elseif m.type== 'list'
                                        " The List Part "{{{
                                        let lst_lv = m.level
                                        
                                        if lst_lv > p_lst_lv
                                            call s:add_child(p_l_obj,m)
                                        elseif lst_lv == p_lst_lv  
                                            call s:add_brother(p_l_obj,m)
                                        elseif lst_lv < p_lst_lv 
                                            " create the next older
                                            for i in range(p_lst_lv - lst_lv + 1)
                                                if p_l_obj.bgn == 'list_root'
                                                    break
                                                endif
                                                let p_l_obj = s:get_parent(p_l_obj)
                                            endfor
                                            let brother = s:get_child(p_l_obj,-1)
                                            call s:add_brother(brother, m)
                                        endif
                            
                                        let m.td_stat = riv#todo#stat(b:lines[m.bgn])
                            
                                        let p_l_obj = m
                                        let p_lst_lv = lst_lv
                                            
                                        let b:riv_obj[m.bgn] = m
                                        " End List Part "}}}
                                    elseif m.type == 'trans'
                                        let lst_lv = 0
                                        let b:riv_obj[m.bgn] = m
                                    else
                                        let f = 1
                                        let b:riv_obj[m.bgn] = m
                                    endif
                                    
                                    let m.fdl = sec_lv+lst_lv+f
                            
                                endfor
                                
                            endfun "}}}
    1              0.000005 fun! s:set_sect_end() "{{{
                                " Set the end line of each section.
                                let stat = b:riv_state
                                let smat = stat.sectmatcher
                                for i in range(len(smat))
                                    let m = smat[i]
                                    let bgn = m.bgn
                                    let fdl = m.fdl
                                    
                                    " We should parse section level by level.
                                    " 1~2 ~3 
                                    "  ^1
                                    " 1.1~1.2~1.3 ~ 2
                                    "    ^:2      ^: should be level 1  
                                    " 1.1.1~1.1.2
                                    "      ^:3
                                    " if have brother, then to next brother
                                    " else parent's brother's bgn
                                    "
                                    let n_b = riv#fold#get_next_brother(m)
                                    let n_p = s:get_parent(m)
                                    while empty(n_b)
                                        if (n_p.bgn == 'sect_root' )
                                            break
                                        endif 
                                        let n_b = riv#fold#get_next_brother(n_p)
                                        let n_p = s:get_parent(n_p)
                                    endwhile
                                    if empty(n_b)
                                        let n_b = {'level':0,'bgn':line('$')+1}
                                    endif
                                    
                                    if m.level > n_b.level && g:riv_fold_blank ==0
                                        if n_b.bgn != line('$')+1
                                            let m.end = prevnonblank(n_b.bgn-1)+1
                                        else
                                            let m.end = line('$')
                                        endif
                                    elseif m.level > n_b.level && g:riv_fold_blank == 1
                                        if n_b.bgn != line('$')+1
                                            let m.end = n_b.bgn-2
                                        else
                                            let m.end = line('$')
                                        endif
                                    else
                                        let m.end = n_b.bgn-1
                                    endif
                            
                                endfor
                            endfun "}}}
    1              0.000005 fun! s:set_fdl_list() "{{{
                                " Set folding list's bgn and end
                                let stat = b:riv_state
                                let mat = stat.matcher
                            
                                " fold_blank: 0,1,2 (default:0)
                                " 0     fold one blank line at the most
                                " 1     fold all but one blank line
                                " 2     fold all blank line
                                for m in mat
                                    let bgn = m.bgn
                                    let fdl = m.fdl
                                    let end = m.end
                                    if g:riv_fold_blank ==1 && b:lines[end] =~ '^\s*$'
                                        let end = end - 1
                                    elseif g:riv_fold_blank==0 && b:lines[end] =~ '^\s*$'
                                        let end = prevnonblank(end) + 1
                                    endif
                                    let  b:riv_flist[bgn : bgn] = map(b:riv_flist[bgn : bgn],'">".fdl')
                                    " if it's not a one line folding?
                                    if bgn+1 <= end
                                        let b:riv_flist[bgn+1 : end] = map(b:riv_flist[bgn+1 : end],'fdl')
                                    endif
                                endfor
                            endfun "}}}
                            "}}}
                            " Check "{{{
    1              0.000003 fun! s:check(row) "{{{
                                " check and set the state and return the value dict.
                                            
                                if b:foldlevel < 0
                                    return
                                endif
                            
                                let row = a:row
                                let line = b:lines[row]
                            
                                if has_key(b:riv_state, 's_chk')  
                                    if  s:s_checker(row)
                                        return
                                    endif
                                endif
                                
                                if line=~'^\s*$' && row != line('$')
                                    return
                                endif
                            
                                if b:foldlevel > 2 && has_key(b:riv_state, 't_chk')
                                    if s:t_checker(row)
                                        return
                                    endif
                                endif
                            
                                if b:foldlevel > 1 && !empty(b:riv_state.l_chk) && !has_key(b:riv_state, 'e_chk')
                                    call s:l_checker(row)
                                endif
                            
                                if b:foldlevel > 2
                            
                                    if has_key(b:riv_state, 'e_chk') 
                                        call s:e_checker(row)
                                    endif
                                    if has_key(b:riv_state, 'b_chk') 
                                        call s:b_checker(row)
                                    endif
                                    if has_key(b:riv_state, 'st_chk') 
                                        call s:st_checker(row)
                                    endif
                                    if has_key(b:riv_state, 'lb_chk') 
                                        call s:lb_checker(row)
                                    endif
                            
                                    if !has_key(b:riv_state, 'e_chk') && !has_key(b:riv_state, 'b_chk')  
                                        \ && line=~s:p.literal_block && b:lines[a:row+1]=~ '^\s*$'
                                        if line=~s:p.exp_mark
                                            let b:riv_state.e_chk= {'type': 'exp', 'bgn':a:row,}
                                            return 1
                                        else
                                            let b:riv_state.b_chk = {'type': 'block', 'bgn': a:row, 
                                                        \ 'indent': riv#fold#indent(line)}
                                            " the block line may be other item, so not return
                                        endif
                                    endif
                            
                                endif
                            
                                if line=~'^\s*[[:alnum:]]\+%(\s|$)'
                                    return
                                elseif b:foldlevel > 1 && !has_key(b:riv_state, 'e_chk')
                                            \ && line=~s:p.all_list
                            
                                    let idt = riv#fold#indent(line)
                                    let l_item = {'type': 'list', 'bgn': a:row, 
                                              \ 'indent': idt,
                                              \ 'child': [], 'parent': 'list_root',
                                              \ 'level': idt/2+1,
                                              \}
                            
                                    if row == line('$')
                                        let l_item.end = a:row
                                        call add(b:riv_state.matcher,l_item)
                                    else
                                        call insert(b:riv_state.l_chk, l_item, 0)
                                    endif
                                    return 1
                                elseif line=~s:p.section  && line !~ '^\.\.%(\s|$)*$'
                                    let b:riv_state.s_chk =  {'type': 'sect' , 'bgn': row, 'attr': line[0]}
                                    return 1
                                elseif line=~ '^__\s'
                                    " it's anonymous link
                                    let b:riv_state.e_chk= {'type': 'exp', 'bgn':a:row,}
                                    return 1
                                elseif line=~'^\s*\w'
                                    return
                                elseif b:foldlevel > 2 && (line =~ s:p.exp_mark )
                                    if  (line=~'^\.\.\s*$' && a:row!=line('$') 
                                                        \ && b:lines[a:row+1]=~'^\s*$')
                                        call add(b:riv_state.matcher,{'type': 'exp', 'mark': 'ignored', 
                                                \ 'bgn': a:row, 'end': a:row})
                                    else
                                        let b:riv_state.e_chk= {'type': 'exp', 'bgn':a:row,}
                                    endif
                                    return 1
                                elseif b:foldlevel > 2 && !has_key(b:riv_state, 'st_chk') && line =~ s:p.simple_table 
                                            \ && row != line('$') && b:lines[row+1] !~ '^\s*$'
                                    let b:riv_state.st_chk =  {'type': 'simple_table' , 'bgn': a:row, 'row': 0,
                                                \ 'col': len(split(line)) }
                                    return 1
                                elseif b:foldlevel > 2 && !has_key(b:riv_state, 'lb_chk') && line=~s:p.line_block 
                                    let b:riv_state.lb_chk= {'type': 'line_block' , 'bgn': a:row}
                                    return 1
                                elseif b:foldlevel > 2 && !has_key(b:riv_state, 't_chk') 
                                            \ && line=~s:p.table
                                    let b:riv_state.t_chk= {'type': 'table' , 'bgn': a:row, 'row': 0,
                                                \ 'col': len(split(line, '+',1)) - 2 }
                                    return 1
                                elseif b:foldlevel > 2 && line=~'^'
                                    call add(b:riv_state.matcher,{'type':'trans', 'bgn':a:row,'end':a:row})
                                    return 1
                                endif
                            
                            endfun "}}}
                            
    1              0.000003 fun! s:s_checker(row) "{{{
                                let chk = b:riv_state.s_chk
                                if a:row == chk.bgn+1
                                    let line = b:lines[a:row]
                                    let blank = '^\s*$'
                                    if line !~ blank  && b:lines[a:row-2] =~ blank  && a:row!=line('$')
                                        \ && b:lines[a:row+1] == b:lines[a:row-1]
                                        " 3 row title : blank ,section , noblank(cur) , section
                                        let chk.bgn = a:row-1
                                        let chk.title_rows = 3
                                        let chk.child = []
                                        let chk.parent = 'sect_root'
                                        call add(b:riv_state.matcher, chk)
                                        call add(b:riv_state.sectmatcher, chk)
                                        call remove(b:riv_state, 's_chk')
                                        return 1
                                    elseif line =~ blank && b:lines[a:row-2]=~ blank && len(b:lines[a:row-1])>=4
                                        " transition : blank, section ,blank(cur) ,len>4
                                        let chk.type = 'trans'
                                        let chk.bgn = a:row - 1
                                        let chk.end = a:row - 1
                                        call add(b:riv_state.matcher, chk)
                                        call remove(b:riv_state, 's_chk')
                                        return 
                                    elseif b:lines[a:row-2] !~ blank && b:lines[a:row-3] =~ blank
                                                \ && b:lines[a:row-1] != b:lines[a:row-2]
                                        " 2 row title : blank , noblank , section , cur
                                        let chk.bgn = a:row - 2
                                        let chk.title_rows = 2
                                        let chk.child = []
                                        let chk.parent = 'sect_root'
                                        call add(b:riv_state.matcher, chk)
                                        call add(b:riv_state.sectmatcher, chk)
                                        call remove(b:riv_state, 's_chk')
                                        return 1
                                    endif
                                endif
                            endfun "}}}
    1              0.000003 fun! s:l_checker(row) "{{{
                                " a list contain all lists.
                                " the final order should be sorted.
                                " if empty(b:riv_state.l_chk) | return | endif
                                " List can contain Explicit Markup items.
                                " if has_key(b:riv_state, 'e_chk') | return | endif
                                " NOTE: 
                                " Field list 
                                " list-item:
                                "   
                                "   list content
                                "
                                " are not folded
                                let l = b:riv_state.l_chk
                                let idt = riv#fold#indent(b:lines[a:row]) 
                                let end = line('$')
                                while !empty(l)
                                    if (idt <= l[0].indent ) 
                                        let l[0].end = a:row-1
                                        call add(b:riv_state.matcher,l[0])
                                        call remove(l , 0)
                                    elseif a:row==end
                                        let l[0].end = a:row
                                        call add(b:riv_state.matcher,l[0])
                                        call remove(l , 0)
                                    else
                                        break
                                    endif
                                endwhile
                            endfun "}}}
    1              0.000050 fun! s:e_checker(row) "{{{
                                " check end
                                if (  b:lines[a:row] =~ '^\S' )
                                    let b:riv_state.e_chk.end = a:row-1
                                    call add(b:riv_state.matcher,b:riv_state.e_chk)
                                    call remove(b:riv_state, 'e_chk')
                                elseif  a:row==line('$')
                                    let b:riv_state.e_chk.end = a:row
                                    call add(b:riv_state.matcher,b:riv_state.e_chk)
                                    call remove(b:riv_state, 'e_chk')
                                endif
                            endfun "}}}
    1              0.000005 fun! s:b_checker(row) "{{{
                                " block
                                if (  riv#fold#indent(b:lines[a:row]) <= b:riv_state.b_chk.indent )
                                    let b:riv_state.b_chk.end = a:row-1
                                    call add(b:riv_state.matcher, b:riv_state.b_chk)
                                    call remove(b:riv_state, 'b_chk')
                                elseif a:row==line('$') && b:riv_state.b_chk.bgn < a:row
                                    let b:riv_state.b_chk.end = a:row
                                    call add(b:riv_state.matcher, b:riv_state.b_chk)
                                    call remove(b:riv_state, 'b_chk')
                                endif
                            endfun "}}}
    1              0.000004 fun! s:lb_checker(row) "{{{
                                " line block
                                if b:lines[a:row] !~ s:p.line_block && b:lines[a:row-1] =~ '^\s*$'
                                    let b:riv_state.lb_chk.end = a:row-1
                                    call add(b:riv_state.matcher, b:riv_state.lb_chk)
                                    call remove(b:riv_state, 'lb_chk')
                                elseif a:row==line('$')
                                    let b:riv_state.t_chk.end = a:row
                                    call add(b:riv_state.matcher, b:riv_state.lb_chk)
                                    call remove(b:riv_state, 'lb_chk')
                                endif
                            endfun "}}}
    1              0.000004 fun! s:t_checker(row) "{{{
                                if b:lines[a:row] =~ g:_riv_p.table_fence
                                    let b:riv_state.t_chk.row += 1
                                    return 1
                                elseif (b:lines[a:row] !~ s:p.table_line )
                                    let b:riv_state.t_chk.end = a:row-1
                                    call add(b:riv_state.matcher, b:riv_state.t_chk)
                                    call remove(b:riv_state, 't_chk')
                                    return 0
                                elseif a:row==line('$')
                                    let b:riv_state.t_chk.end = a:row
                                    call add(b:riv_state.matcher, b:riv_state.t_chk)
                                    call remove(b:riv_state, 't_chk')
                                    return 0
                                endif
                            endfun "}}}
    1              0.000005 fun! s:st_checker(row) "{{{
                                if  b:lines[a:row] =~ s:p.simple_table
                                    if b:lines[a:row+1] =~ '^\s*$'
                                        let b:riv_state.st_chk.end = a:row
                                        call add(b:riv_state.matcher, b:riv_state.st_chk)
                                        call remove(b:riv_state, 'st_chk')
                                    endif
                                elseif b:lines[a:row] !~ s:p.simple_table_span
                                    let b:riv_state.st_chk.row += 1
                                endif
                            endfun "}}}
                            
                            "}}}
                            " Relation "{{{
    1              0.000005 fun! s:add_child(p,o,...) "{{{
                                call add(a:p.child, a:o.bgn )
                                let a:o.parent = a:p.bgn
                            endfun "}}}
    1              0.000005 fun! s:add_brother(b,o,...) "{{{
                                let dic = a:0 ? a:1 : b:riv_obj
                                let a:o.parent = a:b.parent
                                call add(dic[a:o.parent].child, a:o.bgn )
                            endfun "}}}
    1              0.000004 fun! s:get_child(o,i,...) "{{{
                                let dic = a:0 ? a:1 : b:riv_obj
                                return dic[a:o.child[a:i]]
                            endfun "}}}
    1              0.000004 fun! s:get_parent(o,...) "{{{
                                let dic = a:0 ? a:1 : b:riv_obj
                                return dic[a:o.parent]
                            endfun "}}}
    1              0.000007 fun! riv#fold#get_prev_brother(o) "{{{
                                for i in range(len(b:riv_obj[a:o.parent].child))
                                    if b:riv_obj[a:o.parent].child[i] == a:o.bgn
                                        if exists("b:riv_obj[a:o.parent].child[i-1]") && i != 0
                                            return b:riv_obj[b:riv_obj[a:o.parent].child[i-1]]
                                        endif
                                    endif
                                endfor
                                return {}
                            endfun "}}}
    1              0.000004 fun! riv#fold#get_next_brother(o) "{{{
                                for i in range(len(b:riv_obj[a:o.parent].child))
                                    if b:riv_obj[a:o.parent].child[i] == a:o.bgn
                                        if exists("b:riv_obj[a:o.parent].child[i+1]")
                                            return b:riv_obj[b:riv_obj[a:o.parent].child[i+1]]
                                        endif
                                    endif
                                endfor
                                return {}
                            endfun "}}}
    1              0.000003 fun! riv#fold#get_next_older(o) "{{{
                                " try to get the next item of the same level. 
                                " if not find. use it's parent's next item.
                                let n_b = riv#fold#get_next_brother(a:o)
                                let n_p = s:get_parent(a:o)
                                while empty(n_b)
                                    if (n_p.bgn == 'sect_root' || n_p.bgn== 'list_root')
                                        break
                                    endif 
                                    let n_b = riv#fold#get_next_brother(n_p)
                                    let n_p = s:get_parent(n_p)
                                endwhile
                                return n_b
                            endfun "}}}
                            "}}}
                            " Help "{{{
    1              0.000004 fun! s:set_td_child(o) "{{{
                                " Get All child's td_stat recursively
                                " and update the td_child attr.
                                let c_td = 0
                                let len = 0
                                for chd in a:o.child
                                    if empty(b:riv_obj[chd].child)
                                        if b:riv_obj[chd].td_stat != -1
                                            let c_td += b:riv_obj[chd].td_stat
                                            let len +=1
                                        endif
                                    else
                                        let d = s:set_td_child(b:riv_obj[chd])
                                        if d > 0
                                            let c_td += d
                                            let len +=1
                                        endif
                                    endif
                                endfor
                                if len !=0
                                    let c_td = (c_td+0.0)/len
                                    let a:o['td_child'] = c_td
                                else
                                    let c_td = 0
                                endif
                                return c_td
                            endfun "}}}
    1              0.000003 fun! s:sort_match(i1,i2) "{{{
                                return a:i1.bgn - a:i2.bgn
                            endfun "}}}
    1              0.000003 fun! riv#fold#indent(line) "{{{
                                return strdisplaywidth(matchstr(a:line,'^\s*'))
                            endfun "}}}
    1              0.000003 fun! s:SID() "{{{
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
                            endfun "}}}
    1              0.000003 fun! riv#fold#SID() "{{{
                                return '<SNR>'.s:SID().'_'
                            endfun "}}}
                            "}}}
                            " Main "{{{
    1              0.000003 fun! riv#fold#expr(row) "{{{
                                if a:row == 1
                                    noa call s:init_stat()
                                endif
                                return b:riv_flist[a:row]
                            endfun "}}}
    1              0.000002 fun! riv#fold#text() "{{{
                                let lnum = v:foldstart
                                let line = getline(lnum)
                                let cate = "    "
                                if has_key(b:riv_obj,lnum)
                                    if b:riv_obj[lnum].type == 'sect'
                                        let cate = " ".b:riv_obj[lnum].txt
                                        if b:riv_obj[lnum].title_rows == 3
                                            let line = getline(lnum+1)
                                        endif
                                    elseif b:riv_obj[lnum].type == 'list'
                                        if exists("b:riv_obj[lnum].td_child")
                                            let cate = printf(" %-.0f%%", 100 * b:riv_obj[lnum].td_child)
                                        elseif b:riv_obj[lnum].td_stat != -1
                                            let cate = printf(" %-.0f%%", 100 * b:riv_obj[lnum].td_stat)
                                        endif
                                    elseif b:riv_obj[lnum].type == 'table'
                                        let cate = " " . b:riv_obj[lnum].row 
                                                    \  . 'x' . b:riv_obj[lnum].col." "
                                        let line = getline(lnum+1)
                                    elseif b:riv_obj[lnum].type == 'simple_table'
                                        let cate = " " . b:riv_obj[lnum].row . '+' 
                                                    \  . b:riv_obj[lnum].col . " "
                                        let line = getline(lnum+1)
                                    elseif b:riv_obj[lnum].type == 'exp'
                                        let cate = " .."
                                    elseif b:riv_obj[lnum].type == 'block'
                                        let cate = " ::"
                                        let line = getline(lnum)
                                    elseif b:riv_obj[lnum].type == 'line_block'
                                        let cate = " | "
                                    elseif b:riv_obj[lnum].type == 'trans'
                                        let cate = " --"
                                        let line = strtrans(line)
                                    endif
                                endif
                                let max_len = winwidth(0)-20
                                " Fix east_asia_char display width in fold text
                                let dis_len = strdisplaywidth(line)
                                if dis_len > max_len
                                    " XXX we should find the screen idx of the wide str.
                                    " and want to get it in place.
                                    " WORKAROUND: truncate the string with max_len, 
                                    "             add balance for EastAsiaChar.
                                    let line = strpart(line, 0, byteidx(line, max_len-(strlen(line)-dis_len)))
                                    let dis_len = strdisplaywidth(line)
                                endif
                                let line = line."  ".repeat('-', max_len-dis_len)
                                if g:riv_fold_info_pos == 'left'
                                    return printf("%-5s|%s  %4s+ ",cate,line,(v:foldend-lnum))
                                else
                                    return printf("%s|%-5s  %4s+ ",line,cate,(v:foldend-lnum))
                                endif
                            
                            endfun "}}}
    1              0.000003 fun! riv#fold#update() "{{{
                                if &filetype!='rst' || &fdm!='expr' || g:riv_fold_auto_update == 0
                                    return
                                endif
                                normal! zx
                            endfun "}}}
    1              0.000004 let s:modified = 0
    1              0.000003 fun! riv#fold#init() "{{{
                                noa call s:init_stat()
                            endfun "}}}
                            "}}}
                            "
    1              0.000003 fun! s:parse_list() "{{{
                                " setup list object in current section
                                " should detect the indent if lines
                                
                                " check line by line, search a list or an line ,
                                " if it's indent < prev list , then it's prev's child
                                " else if it's indent == prev list , then end prev list ,
                                " elseif indent > prev list, end list to that indent.
                                " 
                                " the tree is 
                                " list_root => list_0_root( roots contain seperated 0 level list ) 
                                "           => list_0  => list_1 ...
                                
                                let row = line('.')
                                let savepos = getpos('.')
                                " get the 0_root begin.
                                " first search backward to find the begin
                                " it's a non list start with '^\S'
                                let root_obj = {'bgn':row ,'parent': 'None','child':[],'indent':0}
                                let l_chk = []
                                let l_match = []
                                let end = line('$')
                                let [row,col] = searchpos('^\S','bc',0,100)
                                while getline(row) =~ g:_riv_p.b_e_list && row != 0
                                    let [row,col] = searchpos('^\S','b',0,100)
                                endwhile
                                if row 
                                    let root_obj.bgn = row
                                    let root = row
                                endif
                                
                                " we parse from bgn and check every non empty line 
                                while 1
                            
                                    let row = nextnonblank(row+1)
                                    let idt = indent(row)
                            
                                    " check
                                    while !empty(l_chk)
                                        if idt <= l_chk[-1].indent
                                            let l_chk[-1].end = row-1
                                            call add(l_match,l_chk[-1])
                                            call remove(l_chk , -1)
                                        elseif row == end
                                            let l_chk[-1].end = row
                                            call add(l_match,l_chk[-1])
                                            call remove(l_chk , -1)
                                        else
                                            break
                                        endif
                                    endwhile
                                    
                            
                                    if row == end
                                        break
                                    endif
                            
                                    " add
                                    if getline(row) =~ g:_riv_p.b_e_list
                                        let l_obj = {'bgn':row,'indent':idt,'parent':0,'child':[]}
                                        call add(l_chk, l_obj)
                                    else
                                        if idt ==  0 
                                            break
                                        endif
                                    endif
                                endwhile
                                let root_obj.end = row
                                call sort(l_match,"s:sort_match")
                            
                                " set obj dict
                                let obj_dic = { root : root_obj , 'root': root_obj}
                                let p_obj = root_obj
                             
                                for m in l_match
                                    let idt = m.indent
                                    let end = m.end
                                    
                                    " when  idt < prev, we will find the paren tindent which <= idt
                                    if idt < p_obj.indent
                                        while idt < p_obj.indent && p_obj.parent != 'None'
                                            let p_obj = s:get_parent(p_obj, obj_dic)
                                        endwhile
                                    endif
                            
                                    if idt > p_obj.indent
                                    " if it's idt > prev one, and end <= prev end 
                                    " then it's prev's child
                                        " find prev's parent and if end <= p_end , add child
                                        while end > p_obj.end && p_obj.parent != 'None'
                                            let p_obj = s:get_parent(p_obj, obj_dic)
                                        endwhile
                                        call s:add_child(p_obj, m, obj_dic)
                                    elseif idt == p_obj.indent
                                    " if it's idt == prev one, and end <= prev's parents end 
                                    " then it's prev's brother (prev's parent's child)
                                        let p_par = p_obj 
                                        while end > p_par.end && p_par.parent != 'None'
                                            let p_par = s:get_parent(p_par, obj_dic)
                                        endwhile
                                        let m.parent = p_par.bgn
                                        call s:add_child(p_par, m, obj_dic)
                                    endif
                            
                                    let p_obj = m
                                        
                                    let obj_dic[m.bgn] = m
                                endfor
                                call setpos('.',savepos)
                                
                                let b:riv_l_dic = obj_dic
                                return obj_dic
                            
                            endfun "}}}
    1              0.000003 fun! s:dic2line(o) "{{{
                                let lines = []
                                let o = a:o
                                let dic = b:riv_l_dic
                                call add(lines, repeat(' ',dic[o].indent) . ':'. dic[o].bgn )
                                if !empty(dic[o].child)
                                    for child in dic[o].child
                                        call extend(lines, s:dic2line(child))
                                    endfor
                                endif
                                return lines
                            endfun "}}}
                            
    1              0.000019 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim
Sourced 1 time
Total time:   0.005377
 Self time:   0.002717

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
                            " EasyMotion - Vim motions on speed!
                            "
                            " Author: Kim Silkeb√¶kken <kim.silkebaekken+vim@gmail.com>
                            "         haya14busa <hayabusa1419@gmail.com>
                            " Source: https://github.com/easymotion/vim-easymotion
                            "=============================================================================
                            " Saving 'cpoptions' {{{
    1              0.000023 let s:save_cpo = &cpo
    1   0.000036   0.000031 set cpo&vim
                            " }}}
                            
    1              0.000006 let s:TRUE = !0
    1              0.000004 let s:FALSE = 0
    1              0.000012 let s:DIRECTION = { 'forward': 0, 'backward': 1, 'bidirection': 2}
                            
                            
                            " Init: {{{
    1              0.000005 let s:loaded = s:FALSE
    1              0.000007 function! EasyMotion#init()
                                if s:loaded
                                    return
                                endif
                                let s:loaded = s:TRUE
                                call EasyMotion#highlight#load()
                                " Store previous motion info
                                let s:previous = {}
                                " Store previous operator-pending motion info for '.' repeat
                                let s:dot_repeat = {}
                                " Prepare 1-key Migemo Dictionary
                                let s:migemo_dicts = {}
                                let s:EasyMotion_is_active = 0
                                call EasyMotion#reset()
                                " Anywhere regular expression: {{{
                                let re = '\v' .
                                    \    '(<.|^$)' . '|' .
                                    \    '(.>|^$)' . '|' .
                                    \    '(\l)\zs(\u)' . '|' .
                                    \    '(_\zs.)' . '|' .
                                    \    '(#\zs.)'
                                " 1. word
                                " 2. end of word
                                " 3. CamelCase
                                " 4. after '_' hoge_foo
                                " 5. after '#' hoge#foo
                                let g:EasyMotion_re_anywhere = get(g:, 'EasyMotion_re_anywhere', re)
                            
                                " Anywhere regular expression within line:
                                let re = '\v' .
                                    \    '(<.|^$)' . '|' .
                                    \    '(.>|^$)' . '|' .
                                    \    '(\l)\zs(\u)' . '|' .
                                    \    '(_\zs.)' . '|' .
                                    \    '(#\zs.)'
                                let g:EasyMotion_re_line_anywhere = get(g:, 'EasyMotion_re_line_anywhere', re)
                                "}}}
                                " For other plugin
                                let s:EasyMotion_is_cancelled = 0
                                " 0 -> Success
                                " 1 -> Cancel
                                let g:EasyMotion_ignore_exception = 0
                                return ""
                            endfunction
                            "}}}
                            " Reset: {{{
    1              0.000004 function! EasyMotion#reset()
                                let s:flag = {
                                    \ 'within_line' : 0,
                                    \ 'dot_repeat' : 0,
                                    \ 'regexp' : 0,
                                    \ 'bd_t' : 0,
                                    \ 'find_bd' : 0,
                                    \ 'linewise' : 0,
                                    \ 'count_dot_repeat' : 0,
                                    \ }
                                    " regexp: -> regular expression
                                    "   This value is used when multi input find motion. If this values is
                                    "   1, input text is treated as regexp.(Default: escaped)
                                    " bd_t: -> bi-directional 't' motion
                                    "   This value is used to re-define regexp only for bi-directional 't'
                                    "   motion
                                    " find_bd: -> bi-directional find motion
                                    "   This value is used to recheck the motion is inclusive or exclusive
                                    "   because 'f' & 't' forward find motion is inclusive, but 'F' & 'T'
                                    "   backward find motion is exclusive
                                    " count_dot_repeat: -> dot repeat with count
                                    "   https://github.com/easymotion/vim-easymotion/issues/164
                                let s:current = {
                                    \ 'is_operator' : 0,
                                    \ 'is_search' : 0,
                                    \ 'dot_repeat_target_cnt' : 0,
                                    \ 'dot_prompt_user_cnt' : 0,
                                    \ 'changedtick' : 0,
                                    \ }
                                    " \ 'start_position' : [],
                                    " \ 'cursor_position' : [],
                            
                                    " is_operator:
                                    "   Store is_operator value first because mode(1) value will be
                                    "   changed by some operation.
                                    " dot_* :
                                    "   These values are used when '.' repeat for automatically
                                    "   select marker/label characters.(Using count avoid recursive
                                    "   prompt)
                                    " changedtick:
                                    "   :h b:changedtick
                                    "   This value is used to avoid side effect of overwriting buffer text
                                    "   which will change b:changedtick value. To overwrite g:repeat_tick
                                    "   value(defined tpope/vim-repeat), I can avoid this side effect of
                                    "   conflicting with tpope/vim-repeat
                                    " start_position:
                                    "   Original, start cursor position.
                                    " cursor_position:
                                    "   Usually, this values is same with start_position, but in
                                    "   visualmode and 'n' key motion, this value could be different.
                                return ""
                            endfunction "}}}
                            
                            " Motion Functions: {{{
                            " -- Find Motion -------------------------
                            " Note: {{{
                            " num_strokes:
                            "   The number of input characters. Currently provide 1, 2, or -1.
                            "   '-1' means no limit.
                            " visualmode:
                            "   Vim script couldn't detect the function is called in visual mode by
                            "   mode(1), so tell whether it is in visual mode by argument explicitly
                            " direction:
                            "   0 -> forward
                            "   1 -> backward
                            "   2 -> bi-direction (handle forward & backward at the same time) }}}
    1              0.000004 function! EasyMotion#S(num_strokes, visualmode, direction) " {{{
                                if a:direction == 1
                                    let is_inclusive = 0
                                else
                                    " Note: Handle bi-direction later because 'f' motion is inclusive but
                                    " 'F' motion is exclusive
                                    let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                endif
                                let s:flag.find_bd = a:direction == 2 ? 1 : 0
                                let re = s:findMotion(a:num_strokes, a:direction)
                                if s:handleEmpty(re, a:visualmode) | return | endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#OverwinF(num_strokes) " {{{
                                let re = s:findMotion(a:num_strokes, s:DIRECTION.bidirection)
                                call EasyMotion#reset()
                                if re isnot# ''
                                    return EasyMotion#overwin#move(re)
                                endif
                            endfunction "}}}
    1              0.000004 function! EasyMotion#T(num_strokes, visualmode, direction) " {{{
                                if a:direction == 1
                                    let is_inclusive = 0
                                else
                                    " Note: Handle bi-direction later because 't' motion is inclusive but
                                    " 'T' motion is exclusive
                                    let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                endif
                                let s:flag.find_bd = a:direction == 2 ? 1 : 0
                                let re = s:findMotion(a:num_strokes, a:direction)
                                if s:handleEmpty(re, a:visualmode) | return | endif
                                if a:direction == 2
                                    let s:flag.bd_t = 1
                                elseif a:direction == 1
                                    let re = s:convert_t_regexp(re, 1) " backward
                                else
                                    let re = s:convert_t_regexp(re, 0) " forward
                                endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Word Motion -------------------------
    1              0.000003 function! EasyMotion#WB(visualmode, direction) " {{{
                                "FIXME: inconsistent with default vim motion
                                "FIXED: -> EasyMotion#WBK()
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion('\(\<.\|^$\)', a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#WBW(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let regex_without_file_ends = '\v(^|\s)\zs\S|^$'
                                let regex = l:regex_without_file_ends
                                            \ . (a:direction == 1 ? '' : '|%$')
                                            \ . (a:direction == 0 ? '' : '|%^')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#WBK(visualmode, direction) " {{{
                                " vim's iskeyword style word motion
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let regex_without_file_ends = '\v<|^\S|\s\zs\S|>\zs\S|^$'
                                let regex = l:regex_without_file_ends
                                            \ . (a:direction == 1 ? '' : '|%$')
                                            \ . (a:direction == 0 ? '' : '|%^')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#E(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                call s:EasyMotion('\(.\>\|^$\)', a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#EW(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                " Note: The stopping positions for 'E' and 'gE' differs. Thus, the regex
                                " for direction==2 cannot be the same in both directions. This will be
                                " ignored.
                                let regex_stub = '\v\S(\s|$)'
                                let regex = l:regex_stub
                                            \ . (a:direction == 0 ? '' : '|^$|%^')
                                            \ . (a:direction == 1 ? '' : '|%$')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#EK(visualmode, direction) " {{{
                                " vim's iskeyword style word motion
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                " Note: The stopping positions for 'e' and 'ge' differs. Thus, the regex
                                " for direction==2 cannot be the same in both directions. This will be
                                " ignored.
                                let regex_stub = '\v.\ze>|\S\ze\s*$|\S\ze\s|\k\zs>\S\ze|\S<'
                                let regex = l:regex_stub
                                            \ . (a:direction == 0 ? '' : '|^$|%^')
                                            \ . (a:direction == 1 ? '' : '|%$')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                            
                            
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- JK Motion ---------------------------
    1              0.000224 function! EasyMotion#JK(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let s:flag.linewise = 1
                            
                                if g:EasyMotion_startofline
                                    call s:EasyMotion('^\(\w\|\s*\zs\|$\)', a:direction, a:visualmode ? visualmode() : '', 0)
                                else
                                    let vcol  = EasyMotion#helper#vcol('.')
                                    let pattern = printf('^.\{-}\zs\(\%%<%dv.\%%>%dv\|$\)', vcol + 1, vcol)
                                    call s:EasyMotion(pattern, a:direction, a:visualmode ? visualmode() : '', 0)
                                endif
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000005 function! EasyMotion#Sol(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let s:flag.linewise = 1
                                call s:EasyMotion('^\(.\|$\)', a:direction, a:visualmode ? visualmode() : '', '')
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#Eol(visualmode, direction) " {{{
                                let s:flag.linewise = 1
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion('\(\w\|\s*\zs\|.\|^\)$', a:direction, a:visualmode ? visualmode() : '', '')
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Search Motion -----------------------
    1              0.000006 function! EasyMotion#Search(visualmode, direction, respect_direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let search_direction = a:respect_direction ?
                                \   (a:direction == 1 ? v:searchforward : 1-v:searchforward) :
                                \   (a:direction)
                                call s:EasyMotion(@/, search_direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- JumpToAnywhere Motion ---------------
    1              0.000004 function! EasyMotion#JumpToAnywhere(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion( g:EasyMotion_re_anywhere, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Line Motion -------------------------
    1              0.000005 function! EasyMotion#SL(num_strokes, visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#S(a:num_strokes, a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000005 function! EasyMotion#TL(num_strokes, visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#T(a:num_strokes, a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#WBL(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#WBK(a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000005 function! EasyMotion#EL(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#EK(a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000005 function! EasyMotion#LineAnywhere(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let re = g:EasyMotion_re_line_anywhere
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- User Motion -------------------------
    1              0.000028 let s:config = {
                            \   'pattern': '',
                            \   'visualmode': s:FALSE,
                            \   'direction': s:DIRECTION.forward,
                            \   'inclusive': s:FALSE,
                            \   'accept_cursor_pos': s:FALSE,
                            \   'overwin': s:FALSE
                            \ }
                            
    1              0.000007 function! s:default_config() abort
                                let c = copy(s:config)
                                let m = mode(1)
                                let c.inclusive = m ==# 'no' ? s:TRUE : s:FALSE
                                return c
                            endfunction
                            
    1              0.000004 function! EasyMotion#go(...) abort
                                let c = extend(s:default_config(), get(a:, 1, {}))
                                if c.overwin
                                    return EasyMotion#overwin#move(c.pattern)
                                else
                                    let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                    call s:EasyMotion(c.pattern, c.direction, c.visualmode ? visualmode() : '', c.inclusive, c)
                                    return s:EasyMotion_is_cancelled
                                endif
                            endfunction
    1              0.000007 function! EasyMotion#User(pattern, visualmode, direction, inclusive, ...) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? a:inclusive : 0
                                let re = a:pattern
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive, get(a:, 1, {}))
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Repeat Motion -----------------------
    1              0.000005 function! EasyMotion#Repeat(visualmode) " {{{
                                " Repeat previous motion with previous targets
                                if !has_key(s:previous, 'regexp')
                                    call s:Message("Previous targets doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                                let re = s:previous.regexp
                                let direction = s:previous.direction
                                let s:flag.within_line = s:previous.line_flag
                                let s:flag.bd_t = s:previous.bd_t_flag
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " FIXME: is_inclusive value is inappropriate but handling this value is
                                " difficult and priorities is low because this motion maybe used usually
                                " as a 'normal' motion.
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                            
                                call s:EasyMotion(re, direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#DotRepeat() " {{{
                                let cnt = v:count1 " avoid overwriting
                            
                                " Repeat previous '.' motion with previous targets and operator
                                if !has_key(s:dot_repeat, 'regexp')
                                    call s:Message("Previous motion doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                            
                                let re = s:dot_repeat.regexp
                                let direction = s:dot_repeat.direction
                                let is_inclusive = s:dot_repeat.is_inclusive
                            
                                for i in range(cnt)
                                    " s:EasyMotion() always call reset s:flag & s:current
                                    let s:flag.dot_repeat = 1
                                    let s:flag.within_line = s:dot_repeat.line_flag
                                    let s:flag.bd_t = s:dot_repeat.bd_t_flag
                                    let s:current.is_operator = 1
                            
                                    let s:flag.count_dot_repeat = (i > 0 ? 1 : 0)
                                    silent call s:EasyMotion(re, direction, 0, is_inclusive)
                                endfor
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000005 function! EasyMotion#NextPrevious(visualmode, direction) " {{{
                                " Move next/previous destination using previous motion regexp
                                let cnt = v:count1 " avoid overwriting
                                if !has_key(s:previous, 'regexp')
                                    call s:Message("Previous targets doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                                let re = s:previous.regexp
                                let search_direction = (a:direction == 1 ? 'b' : '')
                            
                                if g:EasyMotion_move_highlight
                                    call EasyMotion#highlight#attach_autocmd()
                                    call EasyMotion#highlight#add_highlight(re, g:EasyMotion_hl_move)
                                endif
                            
                                if ! empty(a:visualmode)
                                    " FIXME: blink highlight
                                    silent exec 'normal! gv'
                                endif
                            
                                " Mark jump-list
                                if cnt > 1
                                    " Consider Next/Previous motions as jump motion :h jump-motion
                                    " Note: It should add jumplist even if the count isn't given
                                    "       considering vim's default behavior of `n` & `N`, but just
                                    "       I don't want to do it without the count. Should I add a
                                    "       option?
                                    normal! m`
                                endif
                            
                                " Jump
                                " @vimlint(EVL102, 1, l:_)
                                for _ in range(cnt)
                                    keepjumps call searchpos(re, search_direction)
                                endfor
                            
                                normal! zv
                            
                                call EasyMotion#reset()
                                " -- Activate EasyMotion ----------------- {{{
                                let s:EasyMotion_is_active = 1
                                call EasyMotion#attach_active_autocmd() "}}}
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " }}}
                            " Helper Functions: {{{
                            " -- Message -----------------------------
    1              0.000005 function! s:Message(message) " {{{
                                if g:EasyMotion_verbose
                                    echo 'EasyMotion: ' . a:message
                                else
                                    " Make the current message disappear
                                    echo ''
                                    " redraw
                                endif
                            endfunction " }}}
    1              0.000004 function! s:Prompt(message) " {{{
                                echohl Question
                                echo a:message . ': '
                                echohl None
                            endfunction " }}}
    1              0.000005 function! s:Throw(message) "{{{
                                throw 'EasyMotion: ' . a:message
                            endfunction "}}}
                            
                            " -- Save & Restore values ---------------
    1              0.000005 function! s:SaveValue() "{{{
                                if ! s:current.is_search
                                    call EasyMotion#helper#VarReset('&scrolloff', 0)
                                endif
                                call EasyMotion#helper#VarReset('&modified', 0)
                                call EasyMotion#helper#VarReset('&modifiable', 1)
                                call EasyMotion#helper#VarReset('&readonly', 0)
                                call EasyMotion#helper#VarReset('&spell', 0)
                                call EasyMotion#helper#VarReset('&virtualedit', '')
                                " if &foldmethod !=# 'expr'
                                    call EasyMotion#helper#VarReset('&foldmethod', 'manual')
                                " endif
                            endfunction "}}}
    1              0.000005 function! s:RestoreValue() "{{{
                                call EasyMotion#helper#VarReset('&scrolloff')
                                call EasyMotion#helper#VarReset('&modified')
                                call EasyMotion#helper#VarReset('&modifiable')
                                call EasyMotion#helper#VarReset('&readonly')
                                call EasyMotion#helper#VarReset('&spell')
                                call EasyMotion#helper#VarReset('&virtualedit')
                                " if &foldmethod !=# 'expr'
                                    call EasyMotion#helper#VarReset('&foldmethod')
                                " endif
                            endfunction "}}}
    1              0.000005 function! s:turn_off_hl_error() "{{{
                                let s:error_hl = EasyMotion#highlight#capture('Error')
                                call EasyMotion#highlight#turn_off(s:error_hl)
                                let s:matchparen_hl = EasyMotion#highlight#capture('MatchParen')
                                call EasyMotion#highlight#turn_off(s:matchparen_hl)
                            endfunction "}}}
    1              0.000005 function! s:turn_on_hl_error() "{{{
                                if exists('s:error_hl')
                                    call EasyMotion#highlight#turn_on(s:error_hl)
                                    unlet s:error_hl
                                endif
                            
                                if exists('s:matchparen_hl')
                                    call EasyMotion#highlight#turn_on(s:matchparen_hl)
                                    unlet s:matchparen_hl
                                endif
                            endfunction "}}}
                            
                            " -- Draw --------------------------------
    1              0.000005 function! s:SetLines(lines, key) " {{{
                                for [line_num, line] in a:lines
                                    keepjumps call setline(line_num, line[a:key])
                                endfor
                            endfunction " }}}
                            
                            " -- Get characters from user input ------
    1              0.000004 function! s:GetChar(...) abort "{{{
                                let mode = get(a:, 1, 0)
                                while 1
                                    " Workaround for https://github.com/osyo-manga/vital-over/issues/53
                                    try
                                        let char = call('getchar', a:000)
                                    catch /^Vim:Interrupt$/
                                        let char = 3 " <C-c>
                                    endtry
                                    if char == 27 || char == 3
                                        " Escape or <C-c> key pressed
                                        redraw
                                        call s:Message('Cancelled')
                                        return ''
                                    endif
                                    " Workaround for the <expr> mappings
                                    if string(char) !=# "\x80\xfd`"
                                        return mode == 1 ? !!char
                                        \    : type(char) == type(0) ? nr2char(char) : char
                                    endif
                                endwhile
                            endfunction "}}}
                            
                            " -- Find Motion Helper ------------------
    1              0.000005 function! s:findMotion(num_strokes, direction) "{{{
                                " Find Motion: S,F,T
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " store cursor pos because 'n' key find motion could be jump to offscreen
                                let s:current.original_position = [line('.'), col('.')]
                                let s:current.is_search = a:num_strokes == -1 ? 1: 0
                                let s:flag.regexp = a:num_strokes == -1 ? 1 : 0 " TODO: remove?
                            
                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let s:previous['input'] = @/
                                else
                                    let s:previous['input'] = get(s:previous, 'input', '')
                                endif
                                let input = EasyMotion#command_line#GetInput(
                                                \ a:num_strokes, s:previous.input, a:direction)
                                let s:previous['input'] = input
                            
                                " Check that we have an input char
                                if empty(input)
                                    return ''
                                endif
                            
                                let re = s:convertRegep(input)
                            
                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let history_re = substitute(re, '\\c\|\\C', '', '')
                                    let @/ = history_re "For textobject: 'gn'
                                    call histadd('search', history_re)
                                endif
                            
                                return re
                            endfunction "}}}
    1              0.000005 function! s:convertRegep(input) "{{{
                                " 1. regexp
                                " 2. migemo
                                " 3. smartsign
                                " 4. smartcase
                                let use_migemo = s:should_use_migemo(a:input)
                                let re = use_migemo || s:should_use_regexp() ? a:input : s:escape_regexp_char(a:input)
                            
                                " Convert space to match only start of spaces
                                if re ==# ' '
                                    let re = '\s\+'
                                endif
                            
                                if use_migemo
                                    let re = s:convertMigemo(re)
                                endif
                            
                                if s:should_use_smartsign(a:input)
                                    let r = s:convertSmartsign(a:input)
                                    if use_migemo
                                        let re = re . '\m\|' . r
                                    else
                                        let re = r
                                    endif
                                endif
                            
                                let case_flag = EasyMotion#helper#should_case_sensitive(
                                                    \ a:input, s:current.is_search) ? '\c' : '\C'
                                let re = case_flag . re
                                return re
                            endfunction "}}}
    1              0.000005 function! s:convertMigemo(re) "{{{
                                let re = a:re
                            
                                if len(re) > 1
                                    " System cmigemo
                                    return EasyMotion#cmigemo#getMigemoPattern(re)
                                endif
                            
                                " EasyMotion migemo one key dict
                                if ! has_key(s:migemo_dicts, &l:encoding)
                                    let s:migemo_dicts[&l:encoding] = EasyMotion#helper#load_migemo_dict()
                                endif
                                return get(s:migemo_dicts[&l:encoding], re, a:re)
                            endfunction "}}}
    1              0.000005 function! s:convertSmartsign(chars) "{{{
                                " Convert given chars to smartsign string
                                " Example: 12 -> [1!][2@]
                                "          a] -> a[]}]
                            
                                " Load smartsign dictionary
                                let smart_dict = s:load_smart_dict()
                                " Prepare converted string
                                let converted_str = ''
                                " Get `upper_sign` for each given chars
                                " Split chars into list
                                for char in split(a:chars, '\zs')
                                    let upper_sign = s:get_escaped_group_char(smart_dict, char)
                                    if upper_sign ==# ''
                                        let converted_str .= s:escape_regexp_char(char)
                                    else
                                        " [1!]
                                        let converted_str .= '[' . char . upper_sign . ']'
                                    endif
                                endfor
                                return converted_str
                            endfunction "}}}
    1              0.000005 function! s:get_escaped_group_char(dict, char) "{{{
                                " Get escaped char from given dictionary
                                " return '' if char is not find
                                " Used inside `[]`
                                return escape(get(a:dict, a:char, ''), '^')
                            endfunction "}}}
    1              0.000004 function! s:escape_regexp_char(char) "{{{
                                return escape(a:char, '.$^~\[]*')
                            endfunction "}}}
    1              0.000004 function! s:convertSmartcase(re, char) "{{{
                                let re = a:re
                                if a:char =~# '\U' "nonuppercase
                                    return '\c' . re
                                else "uppercase
                                    return '\C' . re
                                endif
                            endfunction "}}}
    1              0.000004 function! s:should_use_regexp() "{{{
                                return g:EasyMotion_use_regexp == 1 && s:flag.regexp == 1
                            endfunction "}}}
    1              0.000004 function! s:should_use_migemo(char) "{{{
                                if ! g:EasyMotion_use_migemo || match(a:char, '[^!-~]') != -1
                                    return 0
                                endif
                            
                                " TODO: use direction to improve
                                if s:flag.within_line == 1
                                    let first_line = line('.')
                                    let end_line = line('.')
                                else
                                    let first_line = line('w0')
                                    let end_line = line('w$')
                                endif
                            
                                " Skip folded line and check if text include multibyte characters
                                for line in range(first_line, end_line)
                                    if EasyMotion#helper#is_folded(line)
                                        continue
                                    endif
                            
                                    if EasyMotion#helper#include_multibyte_char(getline(line)) == 1
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction "}}}
    1              0.000004 function! s:should_use_smartsign(char) "{{{
                                " Smartsign Dictionary exists?
                                " \A: non-alphabetic character
                                " Do not use smartsign for n-key find search motions
                                if (exists('g:EasyMotion_use_smartsign_us')  ||
                                \   exists('g:EasyMotion_use_smartsign_jp')) &&
                                \  match(a:char, '\A') != -1 &&
                                \ exists('s:current.is_search') && s:current.is_search == 0
                                    return 1
                                else
                                    return 0
                                endif
                            endfunction "}}}
    1              0.000005 function! s:convert_t_regexp(re, direction) "{{{
                                if a:direction == 0 "forward
                                    return '\_.\ze\('.a:re.'\)'
                                elseif a:direction == 1 "backward
                                    return '\('.a:re.'\)\@<=\_.'
                                endif
                            endfunction "}}}
                            
                            " -- Handle Visual Mode ------------------
    1              0.000006 function! s:GetVisualStartPosition(c_pos, v_start, v_end, search_direction) "{{{
                                let vmode = mode(1)
                                if vmode !~# "^[Vv\<C-v>]"
                                    call s:Throw('Unkown visual mode:'.vmode)
                                endif
                            
                                if vmode ==# 'V' "line-wise Visual
                                    " Line-wise Visual {{{
                                    if a:v_start[0] == a:v_end[0]
                                        if a:search_direction == ''
                                            return a:v_start
                                        elseif a:search_direction == 'b'
                                            return a:v_end
                                        else
                                            call s:throw('Unkown search_direction')
                                        endif
                                    else
                                        if a:c_pos[0] == a:v_start[0]
                                            return a:v_end
                                        elseif a:c_pos[0] == a:v_end[0]
                                            return a:v_start
                                        endif
                                    endif
                                    "}}}
                                else
                                    " Character-wise or Block-wise Visual"{{{
                                    if a:c_pos == a:v_start
                                        return a:v_end
                                    elseif a:c_pos == a:v_end
                                        return a:v_start
                                    endif
                            
                                    " virtualedit
                                    if a:c_pos[0] == a:v_start[0]
                                        return a:v_end
                                    elseif a:c_pos[0] == a:v_end[0]
                                        return a:v_start
                                    elseif EasyMotion#helper#is_greater_coords(a:c_pos, a:v_start) == 1
                                        return a:v_end
                                    else
                                        return a:v_start
                                    endif
                                    "}}}
                                endif
                            endfunction "}}}
                            
                            " -- Others ------------------------------
    1              0.000004 function! s:handleEmpty(input, visualmode) "{{{
                                " if empty, reselect and return 1
                                if empty(a:input)
                                    if ! empty(a:visualmode)
                                        silent exec 'normal! gv'
                                    endif
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                    return 1
                                endif
                                return 0
                            endfunction "}}}
    1              0.000004 function! s:load_smart_dict() "{{{
                                if exists('g:EasyMotion_use_smartsign_us')
                                    return g:EasyMotion#sticky_table#us
                                elseif exists('g:EasyMotion_use_smartsign_jp')
                                    return g:EasyMotion#sticky_table#jp
                                else
                                    return {}
                                endif
                            endfunction "}}}
    1              0.000003 function! EasyMotion#attach_active_autocmd() "{{{
                                " Reference: https://github.com/justinmk/vim-sneak
                                augroup plugin-easymotion-active
                                    autocmd!
                                    autocmd InsertEnter,WinLeave,BufLeave <buffer>
                                        \ let s:EasyMotion_is_active = 0
                                        \  | autocmd! plugin-easymotion-active * <buffer>
                                    autocmd CursorMoved <buffer>
                                        \ autocmd plugin-easymotion-active CursorMoved <buffer>
                                        \ let s:EasyMotion_is_active = 0
                                        \  | autocmd! plugin-easymotion-active * <buffer>
                                augroup END
                            endfunction "}}}
    1              0.000003 function! EasyMotion#is_active() "{{{
                                return s:EasyMotion_is_active
                            endfunction "}}}
    1              0.000039 function! EasyMotion#activate(is_visual) "{{{
                                let s:EasyMotion_is_active = 1
                                call EasyMotion#attach_active_autocmd()
                                call EasyMotion#highlight#add_highlight(s:previous.regexp,
                                                                      \ g:EasyMotion_hl_move)
                                call EasyMotion#highlight#attach_autocmd()
                                if a:is_visual == 1
                                    normal! gv
                                endif
                            endfunction "}}}
    1              0.000045 function! s:restore_cursor_state(visualmode) "{{{
                                " -- Restore original cursor position/selection
                                if ! empty(a:visualmode)
                                    silent exec 'normal! gv'
                                    keepjumps call cursor(s:current.cursor_position)
                                else
                                    keepjumps call cursor(s:current.original_position)
                                endif
                            endfunction " }}}
                            " Grouping Algorithms: {{{
    1              0.000015 let s:grouping_algorithms = {
                            \   1: 'SCTree'
                            \ , 2: 'Original'
                            \ }
                            " -- Single-key/closest target priority tree {{{
                            " This algorithm tries to assign one-key jumps to all the targets closest to the cursor.
                            " It works recursively and will work correctly with as few keys as two.
    1              0.000006 function! s:GroupingAlgorithmSCTree(targets, keys) "{{{
                                " Prepare variables for working
                                let targets_len = len(a:targets)
                                let keys_len = len(a:keys)
                            
                                let groups = {}
                            
                                let keys = reverse(copy(a:keys))
                            
                                " Semi-recursively count targets {{{
                                    " We need to know exactly how many child nodes (targets) this branch will have
                                    " in order to pass the correct amount of targets to the recursive function.
                            
                                    " Prepare sorted target count list {{{
                                        " This is horrible, I know. But dicts aren't sorted in vim, so we need to
                                        " work around that. That is done by having one sorted list with key counts,
                                        " and a dict which connects the key with the keys_count list.
                            
                                        let keys_count = []
                                        let keys_count_keys = {}
                            
                                        let i = 0
                                        for key in keys
                                            call add(keys_count, 0)
                            
                                            let keys_count_keys[key] = i
                            
                                            let i += 1
                                        endfor
                                    " }}}
                            
                                    let targets_left = targets_len
                                    let level = 0
                                    let i = 0
                            
                                    while targets_left > 0
                                        " Calculate the amount of child nodes based on the current level
                                        let childs_len = (level == 0 ? 1 : (keys_len - 1) )
                            
                                        for key in keys
                                            " Add child node count to the keys_count array
                                            let keys_count[keys_count_keys[key]] += childs_len
                            
                                            " Subtract the child node count
                                            let targets_left -= childs_len
                            
                                            if targets_left <= 0
                                                " Subtract the targets left if we added too many too
                                                " many child nodes to the key count
                                                let keys_count[keys_count_keys[key]] += targets_left
                            
                                                break
                                            endif
                            
                                            let i += 1
                                        endfor
                            
                                        let level += 1
                                    endwhile
                                " }}}
                                " Create group tree {{{
                                    let i = 0
                                    let key = 0
                            
                                    call reverse(keys_count)
                            
                                    for key_count in keys_count
                                        if key_count > 1
                                            " We need to create a subgroup
                                            " Recurse one level deeper
                                            let groups[a:keys[key]] = s:GroupingAlgorithmSCTree(a:targets[i : i + key_count - 1], a:keys)
                                        elseif key_count == 1
                                            " Assign single target key
                                            let groups[a:keys[key]] = a:targets[i]
                                        else
                                            " No target
                                            continue
                                        endif
                            
                                        let key += 1
                                        let i += key_count
                                    endfor
                                " }}}
                            
                                " Finally!
                                return groups
                            endfunction "}}}
                            " }}}
                            " -- Original ---------------------------- {{{
    1              0.000007 function! s:GroupingAlgorithmOriginal(targets, keys)
                                " Split targets into groups (1 level)
                                let targets_len = len(a:targets)
                                " let keys_len = len(a:keys)
                            
                                let groups = {}
                            
                                let i = 0
                                let root_group = 0
                                try
                                    while root_group < targets_len
                                        let groups[a:keys[root_group]] = {}
                            
                                        for key in a:keys
                                            let groups[a:keys[root_group]][key] = a:targets[i]
                            
                                            let i += 1
                                        endfor
                            
                                        let root_group += 1
                                    endwhile
                                catch | endtry
                            
                                " Flatten the group array
                                if len(groups) == 1
                                    let groups = groups[a:keys[0]]
                                endif
                            
                                return groups
                            endfunction
                            " }}}
                            
                            " -- Coord/key dictionary creation ------- {{{
    1              0.000005 function! s:CreateCoordKeyDict(groups, ...)
                                " Dict structure:
                                " 1,2 : a
                                " 2,3 : b
                                let sort_list = []
                                let coord_keys = {}
                                let group_key = a:0 == 1 ? a:1 : ''
                            
                                for [key, item] in items(a:groups)
                                    let key = group_key . key
                                    "let key = ( ! empty(group_key) ? group_key : key)
                            
                                    if type(item) == type([]) " List
                                        " Destination coords
                            
                                        " The key needs to be zero-padded in order to
                                        " sort correctly
                                        let dict_key = printf('%05d,%05d', item[0], item[1])
                                        let coord_keys[dict_key] = key
                            
                                        " We need a sorting list to loop correctly in
                                        " PromptUser, dicts are unsorted
                                        call add(sort_list, dict_key)
                                    else
                                        " Item is a dict (has children)
                                        let coord_key_dict = s:CreateCoordKeyDict(item, key)
                            
                                        " Make sure to extend both the sort list and the
                                        " coord key dict
                                        call extend(sort_list, coord_key_dict[0])
                                        call extend(coord_keys, coord_key_dict[1])
                                    endif
                            
                                    unlet item
                                endfor
                            
                                return [sort_list, coord_keys]
                            endfunction
                            " }}}
                            " }}}
                            "}}}
                            " Core Functions: {{{
    1              0.000004 function! s:PromptUser(groups) "{{{
                                " Recursive
                                let group_values = values(a:groups)
                            
                                " -- If only one possible match, jump directly to it {{{
                                if len(group_values) == 1
                                    if mode(1) ==# 'no'
                                        " Consider jump to first match
                                        " NOTE: matchstr() handles multibyte characters.
                                        let s:dot_repeat['target'] = matchstr(g:EasyMotion_keys, '^.')
                                    endif
                                    redraw
                                    return group_values[0]
                                endif
                                " }}}
                            
                                " -- Prepare marker lines ---------------- {{{
                                let lines = {}
                            
                                let coord_key_dict = s:CreateCoordKeyDict(a:groups)
                            
                                let prev_col_num = 0
                                for dict_key in sort(coord_key_dict[0])
                                    " NOTE: {{{
                                    " let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                                    " Perform <Plug>(easymotion-w)
                                    "
                                    " lines[line_num]['orig']:
                                    "   Lorem ipsum dolor sit amet consectetur adipisicing
                                    "
                                    " {target_char}:
                                    "   {L}orem {i}psum {d}olor {s}it {a}met {c}onsectetur {a}dipisicing
                                    "
                                    " lines[line_num]['marker'], {marker_chars}:
                                    "   {A}orem {B}psum {C}olor {D}it {E}met {F}onsectetur {G}dipisicing
                                    "   2-key-combo: {marker_chars} could be 1 or 2 chars like {AB}
                                    "
                                    " }}}
                            
                                    " Prepare original line and marker line {{{
                                    let [line_num, col_num] = split(dict_key, ',')
                            
                                    let line_num = str2nr(line_num)
                                    let col_num = str2nr(col_num)
                                    if ! has_key(lines, line_num)
                                        let current_line = getline(line_num)
                                        let lines[line_num] = {
                                            \ 'orig': current_line,
                                            \ 'marker': current_line,
                                            \ 'mb_compensation': 0,
                                            \ }
                                        " mb_compensation -> multibyte compensation
                                        let prev_col_num = 0
                                    endif "}}}
                            
                                    " Multibyte Compensation: {{{
                                    " Solve multibyte issues by matching the byte column
                                    " number instead of the visual column
                                    " Compensate for byte difference between marker
                                    " character and target character
                                    "
                                    " This has to be done in order to match the correct
                                    " column; \%c matches the byte column and not display
                                    " column.
                                    let col_num = max([prev_col_num + 1,
                                                    \  col_num - lines[line_num]['mb_compensation']])
                                    let prev_col_num = col_num
                                    "}}}
                            
                                    " Prepare marker characters {{{
                                    let marker_chars = coord_key_dict[1][dict_key]
                                    let marker_chars_len = EasyMotion#helper#strchars(marker_chars)
                                    "}}}
                            
                                    " Replace {target} with {marker} & Highlight {{{
                                    let col_add = 0 " Column add byte length
                                    " Disable two-key-combo feature?
                                    let marker_max_length = g:EasyMotion_disable_two_key_combo == 1
                                                            \ ? 1 : 2
                                    for i in range(min([marker_chars_len, marker_max_length]))
                                        let marker_char = split(marker_chars, '\zs')[i]
                                        " EOL {{{
                                        if strlen(lines[line_num]['marker']) < col_num + col_add
                                            " Append marker chars if target is EOL
                                            let lines[line_num]['marker'] .= ' '
                                        endif "}}}
                            
                                        let target_col_regexp = '\%' . (col_num + col_add) . 'c.'
                                        let target_char = matchstr(lines[line_num]['marker'],
                                                                  \ target_col_regexp)
                                        let space_len = strdisplaywidth(target_char)
                                                    \ - strdisplaywidth(marker_char)
                                        " Substitute marker character
                                        let substitute_expr = marker_char . repeat(' ', space_len)
                            
                                        let lines[line_num]['marker'] = substitute(
                                            \ lines[line_num]['marker'],
                                            \ target_col_regexp,
                                            \ escape(substitute_expr,'&'),
                                            \ '')
                            
                                        " Highlight targets {{{
                                        let _hl_group =
                                        \   (marker_chars_len == 1) ? g:EasyMotion_hl_group_target
                                        \   : (i == 0) ? g:EasyMotion_hl2_first_group_target
                                        \   : g:EasyMotion_hl2_second_group_target
                            
                                        if exists('*matchaddpos')
                                            call EasyMotion#highlight#add_pos_highlight(
                                                        \ line_num, col_num + col_add, _hl_group)
                                        else
                                            call EasyMotion#highlight#add_highlight(
                                                \ '\%' . line_num . 'l' . target_col_regexp,
                                                \ _hl_group)
                                        endif
                                        "}}}
                            
                                        " Add marker/target length difference for multibyte compensation
                                        let lines[line_num]['mb_compensation'] +=
                                            \ strlen(target_char) - strlen(substitute_expr)
                                        " Shift column
                                        let col_add += strlen(marker_char)
                                    endfor
                                    "}}}
                                endfor
                            
                                let lines_items = items(lines)
                                " }}}
                            
                                " -- Put labels on targets & Get User Input & Restore all {{{
                                " Save undo tree
                                let undo_lock = EasyMotion#undo#save()
                                try
                                    " Set lines with markers {{{
                                    call s:SetLines(lines_items, 'marker')
                                    redraw "}}}
                            
                                    " Get target character {{{
                                    call s:Prompt('Target key')
                                    let char = s:GetChar()
                                    "}}}
                            
                                    " Convert uppercase {{{
                                    if g:EasyMotion_use_upper == 1 && match(g:EasyMotion_keys, '\l') == -1
                                        let char = toupper(char)
                                    endif "}}}
                            
                                    " Jump first target when Enter or Space key is pressed "{{{
                                    if (char ==# "\<CR>" && g:EasyMotion_enter_jump_first == 1) ||
                                    \  (char ==# "\<Space>" && g:EasyMotion_space_jump_first == 1)
                                        " NOTE: matchstr() is multibyte aware.
                                        let char = matchstr(g:EasyMotion_keys, '^.')
                                    endif "}}}
                            
                                    " For dot repeat {{{
                                    if mode(1) ==# 'no'
                                        " Store previous target when operator pending mode
                                        if s:current.dot_prompt_user_cnt == 0
                                            " Store
                                            let s:dot_repeat['target'] = char
                                        else
                                            " Append target chars
                                            let s:dot_repeat['target'] .= char
                                        endif
                                    endif "}}}
                            
                                finally
                                    " Restore original lines
                                    call s:SetLines(lines_items, 'orig')
                            
                                    " Un-highlight targets {{{
                                    call EasyMotion#highlight#delete_highlight(
                                        \ g:EasyMotion_hl_group_target,
                                        \ g:EasyMotion_hl2_first_group_target,
                                        \ g:EasyMotion_hl2_second_group_target,
                                        \ )
                                    " }}}
                            
                                    " Restore undo tree
                                    call undo_lock.restore()
                            
                                    redraw
                                endtry "}}}
                            
                                " -- Check if we have an input char ------ {{{
                                if empty(char)
                                    call s:Throw('Cancelled')
                                endif
                                " }}}
                                " -- Check if the input char is valid ---- {{{
                                if ! has_key(a:groups, char)
                                    call s:Throw('Invalid target')
                                endif
                                " }}}
                            
                                let target = a:groups[char]
                            
                                if type(target) == type([])
                                    " Return target coordinates
                                    return target
                                else
                                    " Prompt for new target character
                                    let s:current.dot_prompt_user_cnt += 1
                                    return s:PromptUser(target)
                                endif
                            endfunction "}}}
    1              0.000007 function! s:DotPromptUser(groups) "{{{
                                " Get char from previous target
                                let char = s:dot_repeat.target[s:current.dot_repeat_target_cnt]
                                " For dot repeat target chars
                                let s:current.dot_repeat_target_cnt += 1
                            
                                let target = a:groups[char]
                            
                                if type(target) == type([])
                                    " Return target coordinates
                                    return target
                                else
                                    " Prompt for new target character
                                    return s:PromptUser(target)
                                endif
                            endfunction "}}}
                            
    1              0.000005 function! s:EasyMotion(regexp, direction, visualmode, is_inclusive, ...) " {{{
                                let config = extend(s:default_config(), get(a:, 1, {}))
                                " Store s:current original_position & cursor_position {{{
                                " current cursor pos.
                                let s:current.cursor_position = [line('.'), col('.')]
                                " original start position.  This value could be changed later in visual
                                " mode
                                let s:current.original_position =
                                    \ get(s:current, 'original_position', s:current.cursor_position)
                                "}}}
                            
                                let win_first_line = line('w0') " visible first line num
                                let win_last_line  = line('w$') " visible last line num
                            
                                " Store the target positions list
                                " e.g. targets = [ [line, col], [line2, col2], ...]
                                let targets = []
                            
                                " Store info for Repeat motion {{{
                                if s:flag.dot_repeat != 1
                                    " Store Regular Expression
                                    let s:previous['regexp'] = a:regexp
                                    let s:previous['direction'] = a:direction
                                    let s:previous['operator'] = v:operator
                            
                                    " Note: 'is_inclusive' value could be changed later when
                                    " bi-directional find motion depend on 'true' direction the cursor
                                    " will move.
                                    let s:previous['is_inclusive'] = a:is_inclusive
                            
                                    " For special motion flag
                                    let s:previous['line_flag'] = s:flag.within_line
                                    let s:previous['bd_t_flag'] = s:flag.bd_t " bi-directional t motion
                                endif "}}}
                            
                                " To avoid side effect of overwriting buffer for tpope/repeat
                                " store current b:changedtick. Use this value later
                                let s:current.changedtick = b:changedtick
                            
                                try
                                    " -- Reset properties -------------------- {{{
                                    " Save original value and set new value
                                    call s:SaveValue()
                                    call s:turn_off_hl_error()
                                    " }}}
                                    " Setup searchpos args {{{
                                    let search_direction = (a:direction == 1 ? 'b' : '')
                                    let search_stopline = a:direction == 1 ? win_first_line : win_last_line
                            
                                    if s:flag.within_line == 1
                                        let search_stopline = s:current.original_position[0]
                                    endif
                                    "}}}
                            
                                    " Handle visual mode {{{
                                    if ! empty(a:visualmode)
                                        " Decide at where visual mode start {{{
                                        normal! gv
                                        let v_start = [line("'<"),col("'<")] " visual_start_position
                                        let v_end   = [line("'>"),col("'>")] " visual_end_position
                            
                                        let v_original_pos = s:GetVisualStartPosition(
                                            \ s:current.cursor_position, v_start, v_end, search_direction)
                                        "}}}
                            
                                        " Reselect visual text {{{
                                        keepjumps call cursor(v_original_pos)
                                        exec "normal! " . a:visualmode
                                        keepjumps call cursor(s:current.cursor_position)
                                        "}}}
                                        " Update s:current.original_position
                                        " overwrite original start position
                                        let s:current.original_position = v_original_pos
                                    endif "}}}
                            
                                    " Handle bi-directional t motion {{{
                                    if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 0) "forward
                                    else
                                        let regexp = a:regexp
                                    endif
                                    "}}}
                            
                                    " Handle dot repeat with count
                                    if s:flag.count_dot_repeat
                                        let cursor_char = EasyMotion#helper#get_char_by_coord(s:current.cursor_position)
                                        if cursor_char =~# regexp
                                            call add(targets, s:current.cursor_position)
                                        endif
                                    endif
                            
                                    " Construct match dict {{{
                                    " Note: searchpos() has side effect which jump cursor position.
                                    "       You can disable this side effect by add 'n' flags,
                                    "       but in this case, it's better to allows jump side effect
                                    "       to gathering matched targets coordinates.
                                    let pos = searchpos(regexp, search_direction . (config.accept_cursor_pos ? 'c' : ''), search_stopline)
                                    while 1
                                        " Reached end of search range
                                        if pos == [0, 0]
                                            break
                                        endif
                            
                                        " Skip folded lines {{{
                                        if EasyMotion#helper#is_folded(pos[0])
                                            if search_direction ==# 'b'
                                                " FIXME: Hmm... I should use filter()
                                                " keepjumps call cursor(foldclosed(pos[0]), 0)
                                            else
                                                keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                            endif
                                        else
                                            call add(targets, pos)
                                        endif
                                        "}}}
                                        let pos = searchpos(regexp, search_direction, search_stopline)
                                    endwhile
                                    "}}}
                            
                                    " Handle bidirection "{{{
                                    " For bi-directional t motion {{{
                                    if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 1) "backward
                                    endif
                                    "}}}
                                    " Reconstruct match dict
                                    if a:direction == 2
                                        " Backward
                            
                                        " Jump back cursor_position
                                        keepjumps call cursor(s:current.cursor_position[0],
                                                            \ s:current.cursor_position[1])
                            
                                        let targets2 = []
                                        if s:flag.within_line == 0
                                            let search_stopline = win_first_line
                                        else
                                            let search_stopline = s:current.cursor_position[0]
                                        endif
                                        while 1
                                            " TODO: refactoring
                                            let pos = searchpos(regexp, 'b', search_stopline)
                                            " Reached end of search range
                                            if pos == [0, 0]
                                                break
                                            endif
                            
                                            " Skip folded lines {{{
                                            if EasyMotion#helper#is_folded(pos[0])
                                                " keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                                continue
                                            endif
                                            "}}}
                            
                                            call add(targets2, pos)
                                        endwhile
                                        " Merge match target dict"{{{
                                        let t1 = 0 " forward
                                        let t2 = 0 " backward
                                        let targets3 = []
                                        while t1 < len(targets) || t2 < len(targets2)
                                            " Forward -> Backward -> F -> B -> ...
                                            if t1 < len(targets)
                                                call add(targets3, targets[t1])
                                                let t1 += 1
                                            endif
                                            if t2 < len(targets2)
                                                call add(targets3, targets2[t2])
                                                let t2 += 1
                                            endif
                                        endwhile
                                        let targets = targets3
                                        "}}}
                                    endif
                                    "}}}
                                    " Handle no match"{{{
                                    let targets_len = len(targets)
                                    if targets_len == 0
                                        call s:Throw('No matches')
                                    endif
                                    "}}}
                            
                                    " Attach specific key as marker to gathered matched coordinates
                                    let GroupingFn = function('s:GroupingAlgorithm' . s:grouping_algorithms[g:EasyMotion_grouping])
                                    let groups = GroupingFn(targets, split(g:EasyMotion_keys, '\zs'))
                            
                                    " -- Shade inactive source --------------- {{{
                                    if g:EasyMotion_do_shade && targets_len != 1 && s:flag.dot_repeat != 1
                                        if a:direction == 1 " Backward
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '^.*\%#'
                                                            \ : '\%'. win_first_line .'l\_.*\%#'
                                        elseif a:direction == 0 " Forward
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '\%#.*$'
                                                            \ : '\%#\_.*\%'. win_last_line .'l'
                                        else " Both directions
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '^.*\%#.*$'
                                                            \ : '\_.*'
                                        endif
                            
                                        call EasyMotion#highlight#add_highlight(
                                            \ shade_hl_re, g:EasyMotion_hl_group_shade)
                                        if g:EasyMotion_cursor_highlight
                                            let cursor_hl_re = '\%#'
                                            call EasyMotion#highlight#add_highlight(cursor_hl_re,
                                                \ g:EasyMotion_hl_inc_cursor)
                                        endif
                                    endif
                                    " }}}
                            
                                    " -- Jump back before prompt for visual scroll {{{
                                    " Because searchpos() change current cursor position and
                                    " if you just use cursor(s:current.cursor_position) to jump back,
                                    " current line will become middle of line window
                                    if ! empty(a:visualmode)
                                        keepjumps call winrestview({'lnum' : s:current.cursor_position[0], 'topline' : win_first_line})
                                    else
                                        " for adjusting cursorline
                                        keepjumps call cursor(s:current.cursor_position)
                                    endif
                                    "}}}
                            
                                    " -- Prompt user for target group/character {{{
                                    if s:flag.dot_repeat != 1
                                        let coords = s:PromptUser(groups)
                                    else
                                        let coords = s:DotPromptUser(groups)
                                    endif
                                    "}}}
                            
                                    " -- Update cursor position -------------- {{{
                                    " First, jump back cursor to original position
                                    keepjumps call cursor(s:current.original_position)
                            
                                    " Consider EasyMotion as jump motion :h jump-motion
                                    normal! m`
                            
                                    " Update selection for visual mode {{{
                                    if ! empty(a:visualmode)
                                        exec 'normal! ' . a:visualmode
                                    endif
                                    " }}}
                            
                                    " For bi-directional motion, checking again whether the motion is
                                    " inclusive is necessary. This value will might be updated later
                                    let is_inclusive_check = a:is_inclusive
                                    " For bi-directional motion, store 'true' direction for dot repeat
                                    " to handling inclusive/exclusive motion
                                    if a:direction == 2
                                        let true_direction =
                                            \ EasyMotion#helper#is_greater_coords(
                                            \   s:current.original_position, coords) > 0 ?
                                            \ 0 : 1
                                            " forward : backward
                                    else
                                        let true_direction = a:direction
                                    endif
                            
                                    if s:flag.dot_repeat == 1
                                        " support dot repeat {{{
                                        " Use visual mode to emulate dot repeat
                                        normal! v
                            
                                        " Deal with exclusive {{{
                                        if s:dot_repeat.is_inclusive == 0
                                            " exclusive
                                            if s:dot_repeat.true_direction == 0 "Forward
                                                let coords[1] -= 1
                                            elseif s:dot_repeat.true_direction == 1 "Backward
                                                " Shift visual selection to left by making cursor one key
                                                " left.
                                                normal! hoh
                                            endif
                                        endif "}}}
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " Execute previous operator
                                        let cmd = s:dot_repeat.operator
                                        if s:dot_repeat.operator ==# 'c'
                                            let cmd .= getreg('.')
                                        endif
                                        exec 'normal! ' . cmd
                                        "}}}
                                    else
                                        " Handle inclusive & exclusive {{{
                                        " Overwrite inclusive flag for special case {{{
                                        if s:flag.find_bd == 1 && true_direction == 1
                                            " Note: For bi-directional find motion s(f) & t
                                            " If true_direction is backward, the motion is 'exclusive'
                                            let is_inclusive_check = 0 " overwrite
                                            let s:previous.is_inclusive = 0 " overwrite
                                        endif "}}}
                                        if is_inclusive_check
                                            " Note: {{{
                                            " Inclusive motion requires that we eat one more
                                            " character to the right by forcing the motion to inclusive
                                            " if we're using a forward motion because
                                            " > :h exclusive
                                            " > Note that when using ':' any motion becomes characterwise
                                            " > exclusive.
                                            " and EasyMotion use ':'
                                            " See: h: o_v }}}
                                            normal! v
                                        endif " }}}
                            
                                        if s:current.is_operator && s:flag.linewise
                                            " TODO: Is there better solution?
                                            " Maike it linewise
                                            normal! V
                                        endif
                            
                                        " Adjust screen especially for visual scroll & offscreen search {{{
                                        " Otherwise, cursor line will move middle line of window
                                        keepjumps call winrestview({'lnum' : win_first_line, 'topline' : win_first_line})
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " To avoid side effect of overwriting buffer {{{
                                        " for tpope/vim-repeat
                                        " See: :h b:changedtick
                                        if exists('g:repeat_tick')
                                            if g:repeat_tick == s:current.changedtick
                                                let g:repeat_tick = b:changedtick
                                            endif
                                        endif "}}}
                                    endif
                            
                                    " Set tpope/vim-repeat {{{
                                    if s:current.is_operator == 1 &&
                                            \ !(v:operator ==# 'y' && match(&cpo, 'y') == -1)
                                        " Store previous info for dot repeat {{{
                                        let s:dot_repeat.regexp = a:regexp
                                        let s:dot_repeat.direction = a:direction
                                        let s:dot_repeat.line_flag = s:flag.within_line
                                        let s:dot_repeat.is_inclusive = is_inclusive_check
                                        let s:dot_repeat.operator = v:operator
                                        let s:dot_repeat.bd_t_flag = s:flag.bd_t " Bidirectional t motion
                                        let s:dot_repeat.true_direction = true_direction " Check inclusive
                                        "}}}
                                        silent! call repeat#set("\<Plug>(easymotion-dotrepeat)")
                                    endif "}}}
                            
                                    " Highlight all the matches by n-key find motions {{{
                                    if s:current.is_search == 1 && s:current.is_operator == 0 && g:EasyMotion_add_search_history
                                        " It seems let &hlsearch=&hlsearch doesn't work when called
                                        " in script, so use :h feedkeys() instead.
                                        " Ref: :h v:hlsearch
                                        " FIXME: doesn't work with `c` operator
                                        call EasyMotion#helper#silent_feedkeys(
                                                                \ ":let &hlsearch=&hlsearch\<CR>",
                                                                \ 'hlsearch', 'n')
                                    endif "}}}
                            
                                    call s:Message('Jumping to [' . coords[0] . ', ' . coords[1] . ']')
                                    let s:EasyMotion_is_cancelled = 0 " Success
                                    "}}}
                                catch /^EasyMotion:.*/
                                    redraw
                            
                                    " Show exception message
                                    " The verbose option will take precedence
                                    if g:EasyMotion_verbose == 1 && g:EasyMotion_ignore_exception != 1
                                        echo v:exception
                                    endif
                            
                                    let s:previous['regexp'] = a:regexp
                                    " -- Activate EasyMotion ----------------- {{{
                                    let s:EasyMotion_is_active = 1
                                    call EasyMotion#attach_active_autocmd() "}}}
                            
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                catch
                                    call s:Message(v:exception . ' : ' . v:throwpoint)
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                finally
                                    " -- Restore properties ------------------ {{{
                                    call s:RestoreValue()
                                    call s:turn_on_hl_error()
                                    call EasyMotion#reset()
                                    " }}}
                                    " -- Remove shading ---------------------- {{{
                                    call EasyMotion#highlight#delete_highlight()
                                    " }}}
                            
                                    if s:EasyMotion_is_cancelled == 0 " Success
                                        " -- Landing Highlight ------------------- {{{
                                        if g:EasyMotion_landing_highlight
                                            call EasyMotion#highlight#add_highlight(a:regexp,
                                                                                  \ g:EasyMotion_hl_move)
                                            call EasyMotion#highlight#attach_autocmd()
                                        endif "}}}
                                        " -- Activate EasyMotion ----------------- {{{
                                        let s:EasyMotion_is_active = 1
                                        call EasyMotion#attach_active_autocmd() "}}}
                                    endif
                                endtry
                            endfunction " }}}
                            "}}}
                            " }}}
                            
    1   0.002679   0.000026 call EasyMotion#init()
                            " Restore 'cpoptions' {{{
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim
Sourced 1 time
Total time:   0.002238
 Self time:   0.000844

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: highlight.vim
                            " AUTHOR: haya14busa
                            " Reference: https://github.com/t9md/vim-smalls
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000004 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000046 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            " }}}
                            
    1              0.000003 function! EasyMotion#highlight#load()
                               "load
                            endfunction
                            
                            " -- Default highlighting ---------------- {{{
    1              0.000010 let g:EasyMotion_hl_group_target         = get(g:,
                                \ 'EasyMotion_hl_group_target', 'EasyMotionTarget')
    1              0.000009 let g:EasyMotion_hl2_first_group_target  = get(g:,
                                \ 'EasyMotion_hl2_first_group_target', 'EasyMotionTarget2First')
    1              0.000009 let g:EasyMotion_hl2_second_group_target = get(g:,
                                \ 'EasyMotion_hl2_second_group_target', 'EasyMotionTarget2Second')
    1              0.000008 let g:EasyMotion_hl_group_shade          = get(g:,
                                \ 'EasyMotion_hl_group_shade', 'EasyMotionShade')
                            
    1              0.000007 let g:EasyMotion_hl_inc_search     = get(g:,
                                \ 'EasyMotion_hl_inc_search', 'EasyMotionIncSearch')
    1              0.000008 let g:EasyMotion_hl_inc_cursor     = get(g:,
                                \ 'EasyMotion_hl_inc_cursor', 'EasyMotionIncCursor')
    1              0.000007 let g:EasyMotion_hl_move           = get(g:,
                                \ 'EasyMotion_hl_move', 'EasyMotionMoveHL')
                            
    1              0.000013 let s:target_hl_defaults = {
                                \   'gui'     : ['NONE', '#ff0000' , 'bold']
                                \ , 'cterm256': ['NONE', '196'     , 'bold']
                                \ , 'cterm'   : ['NONE', 'red'     , 'bold']
                                \ }
                            
    1              0.000012 let s:target_hl2_first_defaults = {
                                \   'gui'     : ['NONE', '#ffb400' , 'bold']
                                \ , 'cterm256': ['NONE', '11'      , 'bold']
                                \ , 'cterm'   : ['NONE', 'yellow'  , 'bold']
                                \ }
                            
    1              0.000012 let s:target_hl2_second_defaults = {
                                \   'gui'     : ['NONE', '#b98300' , 'bold']
                                \ , 'cterm256': ['NONE', '3'       , 'bold']
                                \ , 'cterm'   : ['NONE', 'yellow'  , 'bold']
                                \ }
                            
    1              0.000011 let s:shade_hl_defaults = {
                                \   'gui'     : ['NONE', '#777777' , 'NONE']
                                \ , 'cterm256': ['NONE', '242'     , 'NONE']
                                \ , 'cterm'   : ['NONE', 'grey'    , 'NONE']
                                \ }
                            
    1              0.000011 let s:shade_hl_line_defaults = {
                                \   'gui'     : ['red' , '#FFFFFF' , 'NONE']
                                \ , 'cterm256': ['red' , '242'     , 'NONE']
                                \ , 'cterm'   : ['red' , 'grey'    , 'NONE']
                                \ }
                            
    1              0.000010 let s:target_hl_inc = {
                                \   'gui'     : ['NONE', '#7fbf00' , 'bold']
                                \ , 'cterm256': ['NONE', '40'   , 'bold']
                                \ , 'cterm'   : ['NONE', 'green'   , 'bold']
                                \ }
    1              0.000011 let s:target_hl_inc_cursor = {
                                \   'gui'     : ['#ACDBDA', '#121813' , 'bold']
                                \ , 'cterm256': ['cyan'   , '232'   , 'bold']
                                \ , 'cterm'   : ['cyan'   , 'black'   , 'bold']
                                \ }
    1              0.000011 let s:target_hl_move = {
                                \   'gui'     : ['#7fbf00', '#121813' , 'bold']
                                \ , 'cterm256': ['green'  , '15'   , 'bold']
                                \ , 'cterm'   : ['green'  , 'white'   , 'bold']
                                \ }
                            " }}}
    1              0.000004 function! EasyMotion#highlight#InitHL(group, colors) " {{{
                                let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
                                let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
                                let ctermhl = &t_Co == 256
                                    \ ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2])
                                    \ : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
                                execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
                                if hlexists(a:group)
                                    redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
                                    if hlstatus !~ 'cleared'
                                        return
                                    endif
                                endif
                            
                                " No colors are defined for this group, link to defaults
                                execute printf('hi default link %s %s', a:group, group_default)
                            endfunction " }}}
    1              0.000003 function! EasyMotion#highlight#init() "{{{
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
                                if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
                                endif
                            endfunction "}}}
                            
                            " Reset highlighting after loading a new color scheme {{{
    1              0.000007 augroup EasyMotionInitHL
    1              0.000183     autocmd!
    1              0.000062     autocmd ColorScheme * call EasyMotion#highlight#init()
    1              0.000006 augroup end
                            " }}}
                            
    1   0.001425   0.000036 call EasyMotion#highlight#init()
                            " Init: {{{
    1              0.000017 let s:h = {}
    1              0.000004 let s:h.ids = {}
    1              0.000018 let s:priorities = {
                                \  g:EasyMotion_hl_group_target : 100,
                                \  g:EasyMotion_hl2_first_group_target : 100,
                                \  g:EasyMotion_hl2_second_group_target : 100,
                                \  g:EasyMotion_hl_group_shade : 0,
                                \  g:EasyMotion_hl_inc_search : 1,
                                \  g:EasyMotion_hl_inc_cursor : 2,
                                \  g:EasyMotion_hl_move : 0,
                                \ }
    8              0.000022 for s:group in keys(s:priorities)
    7              0.000024     let s:h.ids[s:group] = []
    8              0.000011 endfor
    1              0.000003 unlet s:group
                            "}}}
                            
    1              0.000005 function! EasyMotion#highlight#delete_highlight(...) "{{{
                                let groups = !empty(a:000) ? a:000 : keys(s:priorities)
                                for group in groups
                                    for id in s:h.ids[group]
                                        silent! call matchdelete(id)
                                    endfor
                                    let s:h.ids[group] = []
                                endfor
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#add_highlight(re, group) "{{{
                                call add(s:h.ids[a:group], matchadd(a:group, a:re, s:priorities[a:group]))
                            endfunction "}}}
    1              0.000005 function! EasyMotion#highlight#add_pos_highlight(line_num, col_num, group) "{{{
                                call add(s:h.ids[a:group], matchaddpos(a:group, [[a:line_num, a:col_num]], s:priorities[a:group]))
                            endfunction "}}}
    1              0.000003 function! EasyMotion#highlight#attach_autocmd() "{{{
                                " Reference: https://github.com/justinmk/vim-sneak
                                augroup plugin-easymotion
                                    autocmd!
                                    autocmd InsertEnter,WinLeave,BufLeave <buffer>
                                        \ silent! call EasyMotion#highlight#delete_highlight()
                                        \  | autocmd! plugin-easymotion * <buffer>
                                    autocmd CursorMoved <buffer>
                                        \ autocmd plugin-easymotion CursorMoved <buffer>
                                        \ silent! call EasyMotion#highlight#delete_highlight()
                                        \  | autocmd! plugin-easymotion * <buffer>
                                augroup END
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#add_color_group(new_groups) "{{{
                                let s:priorities = extend(deepcopy(s:priorities), a:new_groups)
                                for group in keys(a:new_groups)
                                    let s:h.ids[group] = []
                                endfor
                            endfunction "}}}
                            
    1              0.000003 function! EasyMotion#highlight#capture(hlname) "{{{
                                " Based On: https://github.com/t9md/vim-ezbar
                                "           https://github.com/osyo-manga/vital-over
                                let hlname = a:hlname
                                if !hlexists(hlname)
                                    return
                                endif
                                while 1
                                    let save_verbose = &verbose
                                    let &verbose = 0
                                    try
                                        redir => HL_SAVE
                                        execute 'silent! highlight ' . hlname
                                        redir END
                                    finally
                                        let &verbose = save_verbose
                                    endtry
                                    if !empty(matchstr(HL_SAVE, 'xxx cleared$'))
                                        return ''
                                    endif
                                    " follow highlight link
                                    let ml = matchlist(HL_SAVE, 'links to \zs.*')
                                    if !empty(ml)
                                        let hlname = ml[0]
                                        continue
                                    endif
                                    break
                                endwhile
                                let HL_SAVE = substitute(matchstr(HL_SAVE, 'xxx \zs.*'),
                                                       \ '[ \t\n]\+', ' ', 'g')
                                return [hlname, HL_SAVE]
                            endfunction "}}}
    1              0.000003 function! EasyMotion#highlight#turn_off(hl) "{{{
                                if type(a:hl) != type([])
                                    return
                                endif
                                execute 'highlight ' . a:hl[0] . ' NONE'
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#turn_on(hl) "{{{
                                if type(a:hl) != type([])
                                    return
                                endif
                                execute 'highlight ' . a:hl[0] . ' ' . a:hl[1]
                            endfunction "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000022   0.000019 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=4 shiftwidth=4
                            " vim: foldmethod=marker
                            " }}}

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim
Sourced 1 time
Total time:   0.036496
 Self time:   0.000935

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/EasyMotion/command_line.vim
                            " AUTHOR: haya14busa
                            " Reference: https://github.com/osyo-manga/vim-over
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000009 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000019 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            " }}}
                            
                            " CommandLine:
    1   0.001128   0.000210 let s:V = vital#easymotion#new()
    1   0.011484   0.000015 let s:cmdline = s:V.import('Over.Commandline.Base')
    1   0.000083   0.000014 let s:modules = s:V.import("Over.Commandline.Modules")
    1   0.000175   0.000016 let s:search = s:cmdline.make()
    1              0.000005 let s:search.highlights.prompt = 'Question'
                            
                            " Add Module: {{{
    1   0.000996   0.000010 call s:search.connect('Exit')
    1   0.001311   0.000023 call s:search.connect('Cancel')
    1   0.001101   0.000010 call s:search.connect('Redraw')
    1   0.001522   0.000012 call s:search.connect('DrawCommandline')
    1   0.001396   0.000008 call s:search.connect('Delete')
    1   0.001476   0.000009 call s:search.connect('CursorMove')
    1   0.001105   0.000010 call s:search.connect('Paste')
    1   0.001557   0.000008 call s:search.connect('BufferComplete')
    1   0.001386   0.000009 call s:search.connect('InsertRegister')
    1   0.001139   0.000008 call s:search.connect('ExceptionExit')
    1   0.001190   0.000045 call s:search.connect(s:modules.get('ExceptionMessage').make('EasyMotion: ', 'echom'))
    1   0.001025   0.000023 call s:search.connect(s:modules.get('History').make('/'))
    1   0.001123   0.000027 call s:search.connect(s:modules.get('NoInsert').make_special_chars())
    1   0.003211   0.000023 call s:search.connect(s:modules.get('KeyMapping').make_emacs())
    1   0.003336   0.000024 call s:search.connect(s:modules.get('Doautocmd').make('EMCommandLine'))
                            
    1              0.000006 let s:module = {
                            \   "name" : "EasyMotion",
                            \}
    1              0.000003 function! s:module.on_char_pre(cmdline)
                                if a:cmdline.is_input("<Over>(em-scroll-f)")
                                    call s:scroll(0)
                                    call a:cmdline.setchar('')
                                elseif a:cmdline.is_input("<Over>(em-scroll-b)")
                                    call s:scroll(1)
                                    call a:cmdline.setchar('')
                                elseif a:cmdline.is_input("<Over>(em-jumpback)")
                                    keepjumps call setpos('.', s:save_orig_pos)
                                    let s:orig_pos = s:save_orig_pos
                                    let s:orig_line_start = getpos('w0')
                                    let s:orig_line_end = getpos('w$')
                                    let s:direction = s:save_direction
                                    call a:cmdline.setchar('')
                                elseif a:cmdline.is_input("<Over>(em-openallfold)")
                                    " TODO: better solution
                                    normal! zR
                                    call a:cmdline.setchar('')
                                endif
                            endfunction
    1   0.000145   0.000006 call s:search.connect(s:module)
                            "}}}
                            
                            " CommandLine Keymap: {{{
                            " .keymapping() won't be remapped by user defined KeyMappings.
    1              0.000003 function! s:search.keymapping() "{{{
                                return {
                            \       "\<CR>"   : {
                            \           "key" : "<Over>(exit)",
                            \           "noremap" : 1,
                            \           "lock" : 1,
                            \       },
                            \   }
                            endfunction "}}}
                            
    1   0.000049   0.000011 call s:search.cnoremap("\<C-l>", '<Over>(buffer-complete)')
    1   0.000043   0.000009 call s:search.cnoremap("\<Tab>", '<Over>(em-scroll-f)')
    1   0.000041   0.000008 call s:search.cnoremap("\<S-Tab>", '<Over>(em-scroll-b)')
    1   0.000048   0.000007 call s:search.cnoremap("\<C-o>", '<Over>(em-jumpback)')
    1   0.000040   0.000008 call s:search.cnoremap("\<C-z>", '<Over>(em-openallfold)')
                            
                            " Fins Motion CommandLine Mapping Command: {{{
    1              0.000004 function! EasyMotion#command_line#cmap(args)
                                let lhs = s:as_keymapping(a:args[0])
                                let rhs = s:as_keymapping(a:args[1])
                                call s:search.cmap(lhs, rhs)
                            endfunction
    1              0.000004 function! EasyMotion#command_line#cnoremap(args)
                                let lhs = s:as_keymapping(a:args[0])
                                let rhs = s:as_keymapping(a:args[1])
                                call s:search.cnoremap(lhs, rhs)
                            endfunction
    1              0.000004 function! EasyMotion#command_line#cunmap(lhs)
                                let lhs = s:as_keymapping(a:lhs)
                                call s:search.cunmap(lhs)
                            endfunction
    1              0.000004 function! s:as_keymapping(key)
                                execute 'let result = "' . substitute(a:key, '\(<.\{-}>\)', '\\\1', 'g') . '"'
                                return result
                            endfunction
                            "}}}
                            "}}}
                            
                            " Event: {{{
    1              0.000003 function! s:search.on_enter(cmdline) "{{{
                                if s:num_strokes == -1
                                    call EasyMotion#highlight#delete_highlight()
                                    call EasyMotion#helper#VarReset('&scrolloff', 0)
                                    if g:EasyMotion_do_shade
                                        call EasyMotion#highlight#add_highlight('\_.*',
                                                                            \ g:EasyMotion_hl_group_shade)
                                    endif
                                endif
                                if g:EasyMotion_cursor_highlight
                                    call EasyMotion#highlight#add_highlight('\%#',
                                                                          \ g:EasyMotion_hl_inc_cursor)
                                endif
                            endfunction "}}}
    1              0.000003 function! s:search.on_leave(cmdline) "{{{
                                if s:num_strokes == -1
                                    call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
                                    if g:EasyMotion_do_shade
                                        call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_group_shade)
                                    endif
                                endif
                                if g:EasyMotion_cursor_highlight
                                    call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_cursor)
                                endif
                            endfunction "}}}
    1              0.000002 function! s:search.on_char(cmdline) "{{{
                                if s:num_strokes == -1
                                    let re = s:search.getline()
                                    if EasyMotion#helper#should_case_sensitive(re, 1)
                                        let case_flag = '\c'
                                    else
                                        let case_flag = '\C'
                                    endif
                                    let re .= case_flag
                                    if g:EasyMotion_inc_highlight
                                        call s:inc_highlight(re)
                                    endif
                                    if g:EasyMotion_off_screen_search
                                        call s:off_screen_search(re)
                                    endif
                                elseif s:search.line.length() >=  s:num_strokes
                                    call s:search.exit()
                                endif
                            endfunction "}}}
                            "}}}
                            
                            " Main:
    1              0.000005 function! EasyMotion#command_line#GetInput(num_strokes, prev, direction) "{{{
                                let s:num_strokes = a:num_strokes
                            
                                let s:prompt_base = s:getPromptMessage(a:num_strokes)
                                call s:search.set_prompt(s:prompt_base)
                            
                                " Screen: cursor position, first and last line
                                let s:orig_pos = getpos('.')
                                let s:orig_line_start = getpos('w0')
                                let s:orig_line_end = getpos('w$')
                                let s:save_orig_pos = deepcopy(s:orig_pos)
                            
                                " Direction:
                                let s:direction = a:direction == 1 ? 'b' : ''
                                let s:save_direction = deepcopy(s:direction)
                            
                                let input = s:search.get()
                                if input == '' && ! s:search.exit_code()
                                    return a:prev
                                elseif s:search.exit_code() == 1 || s:search.exit_code() == -1
                                    call s:Cancell()
                                    return ''
                                else
                                    return input
                                endif
                            endfunction "}}}
                            
                            " Helper:
    1              0.000003 function! s:Cancell() " {{{
                                call EasyMotion#highlight#delete_highlight()
                                call EasyMotion#helper#VarReset('&scrolloff')
                                keepjumps call setpos('.', s:save_orig_pos)
                                if g:EasyMotion_verbose
                                    echo 'EasyMotion: Cancelled'
                                endif
                                return ''
                            endfunction " }}}
    1              0.000004 function! s:getPromptMessage(num_strokes) "{{{
                                if a:num_strokes == 1
                                    let prompt = substitute(
                                        \ substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'),
                                        \ '(s)', '', 'g')
                                elseif a:num_strokes == -1
                                    let prompt = substitute(
                                        \ substitute(g:EasyMotion_prompt, '{n}\s\{0,1}', '', 'g'),
                                        \ '(s)', 's', 'g')
                                else
                                    let prompt = substitute(
                                        \ substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'),
                                        \ '(s)', 's', 'g')
                                endif
                                return prompt
                            endfunction "}}}
                            
    1              0.000004 function! s:off_screen_search(re) "{{{
                                " First: search within visible screen range
                                call s:adjust_screen()
                                " Error occur when '\zs' without '!'
                                silent! let pos = searchpos(a:re, s:direction . 'n', s:orig_line_end[1])
                                if pos != [0, 0]
                                    " Restore cursor posision
                                    keepjumps call setpos('.', s:orig_pos)
                                else
                                    " Second: if there were no much, search off screen
                                    silent! let pos = searchpos(a:re, s:direction)
                                    if pos != [0, 0]
                                        " Match
                                        keepjumps call setpos('.', pos)
                                        " Move cursor
                                        if s:save_direction != 'b'
                                            normal! zzH0
                                        else
                                            normal! zzL0
                                        endif
                                    else
                                        " No much
                                        call s:adjust_screen()
                                        keepjumps call setpos('.', s:orig_pos)
                                    endif
                                endif
                                " redraw
                            endfunction "}}}
    1              0.000003 function! s:adjust_screen() "{{{
                                if s:save_direction != 'b'
                                    " Forward
                                    keepjumps call setpos('.', s:orig_line_start)
                                    normal! zt
                                else
                                    " Backward
                                    keepjumps call setpos('.', s:orig_line_end)
                                    normal! zb
                                endif
                            endfunction "}}}
    1              0.000003 function! s:scroll(direction) "{{{
                                " direction: 0 -> forward, 1 -> backward
                                exec a:direction == 0 ? "normal! \<C-f>" : "normal! \<C-b>"
                                let s:orig_pos = getpos('.')
                                let s:orig_line_start = getpos('w0')
                                let s:orig_line_end = getpos('w$')
                                let s:direction = a:direction == 0 ? '' : 'b'
                            endfunction "}}}
    1              0.000003 function! s:inc_highlight(re) "{{{
                                call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
                                if s:search.line.length() > 0
                                    " Error occur when '\zs' without '!'
                                    silent! call EasyMotion#highlight#add_highlight(a:re, g:EasyMotion_hl_inc_search)
                                endif
                            endfunction "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim
Sourced 1 time
Total time:   0.000835
 Self time:   0.000778

count  total (s)   self (s)
    1              0.000012 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000008 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000008 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000006 let s:is_vital_vim = s:plugin_name is# 'vital'
                            
    1              0.000005 let s:loaded = {}
    1              0.000004 let s:cache_sid = {}
                            
                            " function() wrapper
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! s:_function(fstr) abort
                                return function(a:fstr)
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              let s:_s = '<SNR>' . s:_SID() . '_'
                              function! s:_function(fstr) abort
                                return function(substitute(a:fstr, 's:', s:_s, 'g'))
                              endfunction
    1              0.000001 endif
                            
    1              0.000006 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction
                            
    1              0.000006 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction
                            
    1              0.000004 let s:Vital = {}
                            
    1              0.000004 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction
                            
    1              0.000004 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1   0.000026   0.000017 let s:Vital.vital_files = s:_function('s:vital_files')
                            
    1              0.000004 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1   0.000018   0.000012 let s:Vital.import = s:_function('s:import')
                            
    1              0.000003 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1   0.000056   0.000050 let s:Vital.load = s:_function('s:load')
                            
    1              0.000005 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1   0.000030   0.000023 let s:Vital.unload = s:_function('s:unload')
                            
    1              0.000004 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1   0.000017   0.000011 let s:Vital.exists = s:_function('s:exists')
                            
    1              0.000003 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return s:_uniq(modules)
                            endfunction
    1   0.000029   0.000023 let s:Vital.search = s:_function('s:search')
                            
    1              0.000003 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1   0.000018   0.000012 let s:Vital.plugin_name = s:_function('s:plugin_name')
                            
    1              0.000004 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction
                            
    1              0.000004 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction
                            
    1              0.000004 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction
                            
    1              0.000007 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction
                            
                            " @param {string} name e.g. Data.List
    1              0.000004 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1   0.000017   0.000012 let s:Vital._import = s:_function('s:_import')
                            
                            " s:_get_module() returns module object wihch has all script local functions.
    1              0.000004 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              if s:_exists_autoload_func_with_source(funcname)
                                return call(funcname, [])
                              else
                                return s:_get_builtin_module(a:name)
                              endif
                            endfunction
                            
    1              0.000004 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction
                            
    1              0.000003 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = s:_function('s:_get_builtin_module')
    1              0.000002 else
    1   0.000018   0.000012   let s:Vital._get_module = s:_function('s:_get_module')
    1              0.000002 endif
                            
    1              0.000004 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction
                            
    1              0.000004 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction
                            
    1              0.000004 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction
                            
    1              0.000004 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction
                            
    1              0.000003 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction
                            
                            " It will sources autoload file if a given func is not already defined.
    1              0.000006 function! s:_exists_autoload_func_with_source(funcname) abort
                              if exists('*' . a:funcname)
                                " Return true if a given func is already defined
                                return 1
                              endif
                              " source a file which may include a given func definition and try again.
                              let path = 'autoload/' . substitute(substitute(a:funcname, '#[^#]*$', '.vim', ''), '#', '/', 'g')
                              call s:_runtime(path)
                              return exists('*' . a:funcname)
                            endfunction
                            
    1              0.000003 function! s:_runtime(path) abort
                              execute 'runtime' fnameescape(a:path)
                            endfunction
                            
    1              0.000004 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000003 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(s:_redir(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000003 function! s:_redir(cmd) abort
                              let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
                              set verbose=0 verbosefile=
                              redir => res
                                silent! execute a:cmd
                              redir END
                              let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
                              return res
                            endfunction
                            
    1              0.000022 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
                              let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
                              function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
    1              0.000002 else
    1              0.000004   function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
    1              0.000002 endif
                            
                            " copied and modified from Vim.ScriptLocal
    1              0.000053 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000005 function! s:sid2sfuncs(sid) abort
                              let fs = split(s:_redir(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction
                            
                            "" Return funcname of script local functions with SID
    1              0.000004 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction
                            
    1              0.000005 if exists('*uniq')
    1              0.000004   function! s:_uniq(list) abort
                                return uniq(a:list)
                              endfunction
                            else
                              function! s:_uniq(list) abort
                                let i = len(a:list) - 1
                                while 0 < i
                                  if a:list[i] ==# a:list[i - 1]
                                    call remove(a:list, i)
                                  endif
                                  let i -= 1
                                endwhile
                                return a:list
                              endfunction
    1              0.000003 endif

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim
Sourced 1 time
Total time:   0.000944
 Self time:   0.000934

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000009 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Base#import() abort
                                return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Base#import() abort', printf("return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000028 let s:save_cpo = &cpo
    1   0.000023   0.000019 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            	let s:Signals = s:V.import("Over.Signals")
                            	let s:Input = s:V.import("Over.Input")
                            	let s:Keymapping = s:V.import("Over.Keymapping")
                            	let s:Module = s:V.import("Over.Commandline.Modules")
                            	let s:base.variables.modules = s:Signals.make()
                            	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
                            
                            	let s:Highlight = s:V.import("Palette.Highlight")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \		"Over.Signals",
                            \		"Over.Input",
                            \		"Over.Keymapping",
                            \		"Over.Commandline.Modules",
                            \		"Palette.Highlight",
                            \	]
                            endfunction
                            
                            
    1              0.000003 function! s:make(...)
                            	let result = deepcopy(s:base)
                            	call result.set_prompt(get(a:, 1, ":"))
                            	call result.connect(result, "_")
                            	return result
                            endfunction
                            
                            
    1              0.000003 function! s:make_plain()
                            	return deepcopy(s:base)
                            endfunction
                            
                            
    1              0.000026 let s:base = {
                            \	"line" : {},
                            \	"variables" : {
                            \		"prompt" : "",
                            \		"char" : "",
                            \		"input" : "",
                            \		"tap_key" : "",
                            \		"exit" : 0,
                            \		"keymapping" : {},
                            \		"suffix" : "",
                            \		"is_setted" : 0,
                            \	},
                            \	"highlights" : {
                            \		"prompt" : "NONE",
                            \		"cursor" : "VitalOverCommandLineCursor",
                            \		"cursor_on" : "VitalOverCommandLineCursorOn",
                            \		"cursor_insert" : "VitalOverCommandLineOnCursor",
                            \	},
                            \}
                            
    1              0.000005 if exists("s:Signals")
                            	let s:base.variables.modules = s:Signals.make()
                            	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
    1              0.000001 endif
                            
                            
    1              0.000003 function! s:base.getline()
                            	return self.line.str()
                            endfunction
                            
                            
    1              0.000002 function! s:base.setline(line)
                            	return self.line.set(a:line)
                            endfunction
                            
                            
    1              0.000002 function! s:base.char()
                            	return self.variables.char
                            endfunction
                            
                            
    1              0.000003 function! s:base.setchar(char, ...)
                            	" 1 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å¶„ÇÇ‰∏äÊõ∏„Åç„Åô„Çã
                            	" 0 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞‰∏äÊõ∏„Åç„Åó„Å™„ÅÑ
                            	let overwrite = get(a:, 1, 1)
                            	if overwrite || self.variables.is_setted == 0
                            		let self.variables.input = a:char
                            		let self.variables.is_setted = 1
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:base.getpos()
                            	return self.line.pos()
                            endfunction
                            
                            
    1              0.000003 function! s:base.setpos(pos)
                            	return self.line.set_pos(a:pos)
                            endfunction
                            
                            
    1              0.000002 function! s:base.tap_keyinput(key)
                            	let self.variables.tap_key = a:key
                            endfunction
                            
                            
    1              0.000002 function! s:base.untap_keyinput(key)
                            	if self.variables.tap_key == a:key
                            		let self.variables.tap_key = ""
                            		return 1
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_tap_key()
                            	return self.variables.tap_key
                            endfunction
                            
                            
    1              0.000003 function! s:base.is_input(key, ...)
                            	let prekey = get(a:, 1, "")
                            	return self.get_tap_key() ==# prekey
                            \		&& self.char() ==# a:key
                            " \		&& self.char() == (prekey . a:key)
                            endfunction
                            
                            
    1              0.000003 function! s:base.input_key()
                            	return self.variables.input_key
                            endfunction
                            
                            
    1              0.000002 function! s:base.set_prompt(prompt)
                            	let self.variables.prompt = a:prompt
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_prompt()
                            	return self.variables.prompt
                            endfunction
                            
                            
    1              0.000003 function! s:base.set_suffix(str)
                            	let self.variables.suffix = a:str
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_suffix()
                            	return self.variables.suffix
                            endfunction
                            
                            
    1              0.000003 function! s:base.insert(word, ...)
                            	if a:0
                            		call self.line.set(a:1)
                            	endif
                            	call self.line.input(a:word)
                            endfunction
                            
    1              0.000005 function! s:base.forward()
                            	return self.line.forward()
                            endfunction
                            
    1              0.000002 function! s:base.backward()
                            	return self.line.backward()
                            endfunction
                            
                            
    1              0.000002 function! s:base.backward_word(...)
                            	let pat = get(a:, 1, '\k\+\s*\|.')
                            	return matchstr(self.backward(), '\%(' . pat . '\)$')
                            endfunction
                            
                            
    1              0.000002 function! s:base.connect(module, ...)
                            	if type(a:module) == type("")
                            		return call(self.connect, [s:Module.make(a:module)] + a:000, self)
                            	endif
                            	if empty(a:module)
                            		return
                            	endif
                            	let name = a:0 > 0 ? a:1 : a:module.name
                            	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(name))
                            	if empty(slot)
                            		call self.variables.modules.connect({ "name" : name, "module" : a:module })
                            	else
                            		let slot.slot.module = a:module
                            	endif
                            " 	let self.variables.modules[name] = a:module
                            endfunction
                            
                            
    1              0.000003 function! s:base.disconnect(name)
                            	return self.variables.modules.disconnect_by(
                            \		"get(v:val.slot, 'name', '') == " . string(a:name)
                            \	)
                            " 	unlet self.variables.modules[a:name]
                            endfunction
                            
                            
    1              0.000003 function! s:base.get_module(name)
                            	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(a:name))
                            	return empty(slot) ? {} : slot.slot.module
                            endfunction
                            
                            
    1              0.000002 function! s:base.callevent(event)
                            	call self.variables.modules.sort_by("has_key(v:val.slot.module, 'priority') ? v:val.slot.module.priority('" . a:event . "') : 0")
                            	return self.variables.modules.call(a:event, [self])
                            " 	call map(filter(copy(self.variables.modules), "has_key(v:val, a:event)"), "v:val." . a:event . "(self)")
                            endfunction
                            
                            
    1              0.000002 function! s:base.cmap(lhs, rhs)
                            	let self.variables.keymapping[a:lhs] = a:rhs
                            endfunction
                            
                            
    1              0.000003 function! s:base.cnoremap(lhs, rhs)
                            	let key = s:Keymapping.as_key_config(a:rhs)
                            	let key.noremap = 1
                            	let self.variables.keymapping[a:lhs] = key
                            endfunction
                            
                            
    1              0.000003 function! s:base.cunmap(lhs)
                            	unlet self.variables.keymapping[a:lhs]
                            endfunction
                            
                            
    1              0.000002 function! s:base.keymapping()
                            	return self.__keymapping__()
                            endfunction
                            
                            
    1              0.000003 function! s:base.__keymapping__()
                            	return {}
                            endfunction
                            
                            
    1              0.000002 function! s:base.execute(...)
                            	let command = get(a:, 1, self.getline())
                            	call self.__execute(command)
                            endfunction
                            
                            
    1              0.000002 function! s:base.draw()
                            	call self.callevent("on_draw_pre")
                            	call self.callevent("on_draw")
                            endfunction
                            
                            
    1              0.000003 function! s:base.exit(...)
                            	let self.variables.exit = 1
                            	let self.variables.exit_code = get(a:, 1, 0)
                            endfunction
                            
                            
    1              0.000002 function! s:base.enable_keymapping()
                            	let self.variables.enable_keymapping = 1
                            endfunction
                            
                            
    1              0.000002 function! s:base.disable_keymapping()
                            	let self.variables.enable_keymapping = 0
                            endfunction
                            
                            
    1              0.000002 function! s:base.is_enable_keymapping()
                            	return self.variables.enable_keymapping
                            endfunction
                            
                            " function! s:base.cancel()
                            " 	call self.exit(1)
                            " 	call self.__on_cancel()
                            " endfunction
                            
                            
    1              0.000003 function! s:base.exit_code()
                            	return self.variables.exit_code
                            endfunction
                            
                            
    1              0.000003 function! s:base.hl_cursor_on()
                            	if exists("self.variables.old_guicursor")
                            		set guicursor&
                            		let &guicursor = self.variables.old_guicursor
                            		unlet self.variables.old_guicursor
                            	endif
                            
                            	if exists("self.variables.old_t_ve")
                            		let &t_ve = self.variables.old_t_ve
                            		unlet self.variables.old_t_ve
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:base.hl_cursor_off()
                            	if exists("self.variables.old_t_ve")
                            		return
                            	endif
                            
                            	let self.variables.old_guicursor = &guicursor
                            	set guicursor=n:block-NONE
                            	let self.variables.old_t_ve = &t_ve
                            	set t_ve=
                            endfunction
                            
                            
    1              0.000002 function! s:base.start(...)
                            	let exit_code = call(self.__main, a:000, self)
                            	return exit_code
                            endfunction
                            
                            
    1              0.000002 function! s:base.__empty(...)
                            endfunction
                            
                            
    1              0.000003 function! s:base.get(...)
                            	let Old_execute = self.execute
                            	let self.execute = self.__empty
                            	try
                            		let exit_code = call(self.start, a:000, self)
                            		if exit_code == 0
                            			return self.getline()
                            		endif
                            	finally
                            		let self.execute = Old_execute
                            	endtry
                            	return ""
                            endfunction
                            
                            
    1              0.000003 function! s:base.input_key_stack()
                            	return self.variables.input_key_stack
                            endfunction
                            
                            
    1              0.000002 function! s:base.input_key_stack_string()
                            	return join(self.variables.input_key_stack, "")
                            endfunction
                            
                            
    1              0.000003 function! s:base.set_input_key_stack(stack)
                            	let self.variables.input_key_stack = a:stack
                            	return self.variables.input_key_stack
                            endfunction
                            
                            
    1              0.000003 function! s:base.input_key_stack_pop()
                            	return remove(self.input_key_stack(), 0)
                            endfunction
                            
                            
    1              0.000002 function! s:base.getchar(...)
                            	if empty(self.input_key_stack())
                            		return call(s:Input.getchar, a:000, s:Input)
                            	endif
                            	return self.input_key_stack_pop()
                            endfunction
                            
                            
    1              0.000002 function! s:base.__init_variables()
                            	let self.variables.tap_key = ""
                            	let self.variables.char = ""
                            	let self.variables.input = ""
                            	let self.variables.exit = 0
                            	let self.variables.exit_code = 1
                            	let self.variables.enable_keymapping = 1
                            	let self.variables.input_key_stack = []
                            	let self.line = deepcopy(s:String.make())
                            endfunction
                            
                            
    1              0.000004 function! s:_is_valid_highlight(name)
                            	let highlight = s:Highlight.get(a:name)
                            	if empty(highlight)
                            		return 0
                            	endif
                            
                            	if has("gui_running")
                            \	&& (has_key(highlight, "guifg") || has_key(highlight, "guibg"))
                            		return 1
                            	elseif (has_key(highlight, "ctermfg") || has_key(highlight, "ctermbg"))
                            		return 1
                            	endif
                            	return 0
                            endfunction
                            
                            
    1              0.000002 function! s:base.__init()
                            	call self.__init_variables()
                            	call self.hl_cursor_off()
                            	if !hlexists(self.highlights.cursor)
                            		if s:_is_valid_highlight("Cursor")
                            			execute "highlight link " . self.highlights.cursor . " Cursor"
                            		else
                            			" Workaround by CUI Vim Cursor Highlight
                            			" issues #92
                            			" https://github.com/osyo-manga/vital-over/issues/92
                            			execute "highlight " . self.highlights.cursor . " term=reverse cterm=reverse gui=reverse"
                            		endif
                            	endif
                            	if !hlexists(self.highlights.cursor_on)
                            		execute "highlight link " . self.highlights.cursor_on . " " . self.highlights.cursor
                            	endif
                            	if !hlexists(self.highlights.cursor_insert)
                            		execute "highlight " . self.highlights.cursor_insert . " cterm=underline term=underline gui=underline"
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:base.__execute(command)
                            	call self.callevent("on_execute_pre")
                            	try
                            		call self.__execute__(a:command)
                            	catch
                            		echohl ErrorMsg
                            		echom matchstr(v:exception, 'Vim\((\w*)\)\?:\zs.*\ze')
                            		echohl None
                            		call self.callevent("on_execute_failed")
                            	finally
                            		call self.callevent("on_execute")
                            	endtry
                            endfunction
                            
                            
    1              0.000004 function! s:base.__execute__(cmd)
                            	execute a:cmd
                            endfunction
                            
                            
    1              0.000003 function! s:base.__input_char(char)
                            	let char = a:char
                            	let self.variables.input_key = char
                            	let self.variables.char = char
                            	call self.setchar(self.variables.char)
                            	let self.variables.is_setted = 0
                            	call self.callevent("on_char_pre")
                            	call self.insert(self.variables.input)
                            	call self.callevent("on_char")
                            endfunction
                            
                            
    1              0.000004 function! s:base.__input(input, ...)
                            	if a:input == ""
                            		return
                            	endif
                            
                            	let self.variables.input_key = a:input
                            	if a:0 == 0
                            		let keymapping = self.__get_keymapping()
                            	else
                            		let keymapping = a:1
                            	endif
                            	if self.is_enable_keymapping()
                            		let key = s:Keymapping.unmapping(keymapping, a:input)
                            	else
                            		let key = a:input
                            	endif
                            	if key == ""
                            		return
                            	endif
                            
                            	call self.set_input_key_stack(s:String.split_by_keys(key))
                            	while !(empty(self.input_key_stack()) || self.is_exit())
                            		call self.__input_char(self.input_key_stack_pop())
                            	endwhile
                            endfunction
                            
                            
    1              0.000006 function! s:is_input_waiting(keymapping, input)
                            	let num = len(filter(copy(a:keymapping), 'stridx(v:key, a:input) == 0'))
                            	return num > 1 || (num == 1 && !has_key(a:keymapping, a:input))
                            endfunction
                            
                            
    1              0.000003 function! s:base.__inputting()
                            	if !self.is_enable_keymapping()
                            		return self.__input(s:Input.getchar())
                            	endif
                            
                            	let input = s:Input.getchar()
                            	let old_line = self.getline()
                            	let old_pos  = self.getpos()
                            	let keymapping = self.__get_keymapping()
                            	try
                            		let t = reltime()
                            		while s:is_input_waiting(keymapping, input)
                            \		&& str2nr(reltimestr(reltime(t))) * 1000 < &timeoutlen
                            			call self.setline(old_line)
                            			call self.insert(input)
                            			call self.setpos(old_pos)
                            			call self.draw()
                            			let input .= s:Input.getchar(0)
                            		endwhile
                            	finally
                            		call self.setline(old_line)
                            		call self.setpos(old_pos)
                            	endtry
                            	call self.__input(input, keymapping)
                            endfunction
                            
                            
    1              0.000003 function! s:base.__update()
                            " 	call self.callevent("on_update")
                            " 	if !getchar(1)
                            " 		continue
                            " 	endif
                            "
                            " 	call self.__input(s:getchar(0))
                            " 	call self.draw()
                            
                            	call self.callevent("on_update")
                            	call self.__inputting()
                            " 	call self.__input(s:Input.getchar())
                            	if self.is_exit()
                            		return -1
                            	endif
                            	call self.draw()
                            endfunction
                            
                            
    1              0.000008 function! s:base.__main(...)
                            	try
                            		call self.__init()
                            		call self.callevent("on_enter")
                            
                            		call self.__input(get(a:, 1, ""))
                            		call self.draw()
                            		while !self.is_exit()
                            			try
                            				if self.__update()
                            					break
                            				endif
                            			catch
                            				call self.callevent("on_exception")
                            			endtry
                            		endwhile
                            	catch
                            		echohl ErrorMsg | echom v:throwpoint . " " . v:exception | echohl None
                            		let self.variables.exit_code = -1
                            	finally
                            		call self.__finish()
                            		call self.callevent("on_leave")
                            	endtry
                            	return self.exit_code()
                            endfunction
                            
                            
    1              0.000004 function! s:base.__finish()
                            	call self.hl_cursor_on()
                            endfunction
                            
                            
    1              0.000003 function! s:base.__is_exit()
                            	return self.is_exit()
                            endfunction
                            
                            
    1              0.000003 function! s:base.is_exit()
                            	return self.variables.exit
                            endfunction
                            
                            
    1              0.000003 function! s:base.__get_keymapping()
                            	let result = {}
                            " 	for module in values(self.variables.modules)
                            	for module in self.variables.modules.slots()
                            		if has_key(module, "keymapping")
                            			if module isnot self
                            				call extend(result, module.keymapping(self))
                            			endif
                            		endif
                            	endfor
                            	return extend(extend(result, self.variables.keymapping), self.keymapping())
                            endfunction
                            
                            
    1   0.000030   0.000024 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim
Sourced 1 time
Total time:   0.000292
 Self time:   0.000289

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000004   function! vital#_easymotion#Over#String#import() abort
                                return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#String#import() abort', printf("return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:List = s:V.import("Data.List")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Data.List",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:_clamp(x, max, min)
                            	return min([max([a:x, a:max]), a:min])
                            endfunction
                            
                            
    1              0.000003 let s:base = {}
                            
    1              0.000002 function! s:base.set(item)
                            	return type(a:item) == type("") ? self.set_str(a:item)
                            \		 : type(a:item) == type(0)  ? self.set_pos(a:item)
                            \		 : self
                            endfunction
                            
    1              0.000002 function! s:base.str()
                            	return join(self.list, "")
                            endfunction
                            
    1              0.000002 function! s:base.set_pos(pos)
                            	let self.col = s:_clamp(a:pos, 0, self.length())
                            	return self
                            endfunction
                            
    1              0.000002 function! s:base.backward()
                            	return self.col > 0 ? join(self.list[ : self.col-1], '') : ""
                            endfunction
                            
    1              0.000003 function! s:base.forward()
                            	return join(self.list[self.col+1 : ], '')
                            endfunction
                            
    1              0.000002 function! s:base.pos_char()
                            	return get(self.list, self.col, "")
                            endfunction
                            
    1              0.000002 function! s:base.set_str(str)
                            	let self.list = split(a:str, '\zs')
                            	let self.col  = strchars(a:str)
                            	return self
                            endfunction
                            
    1              0.000002 function! s:base.pos()
                            	return self.col
                            endfunction
                            
    1              0.000002 function! s:base.input(str)
                            	call extend(self.list, split(a:str, '\zs'), self.col)
                            	let self.col += len(split(a:str, '\zs'))
                            	return self
                            endfunction
                            
    1              0.000002 function! s:base.length()
                            	return len(self.list)
                            endfunction
                            
    1              0.000002 function! s:base.next()
                            	return self.set_pos(self.col + 1)
                            endfunction
                            
    1              0.000002 function! s:base.prev()
                            	return self.set_pos(self.col - 1)
                            endfunction
                            
    1              0.000003 function! s:base.remove(index)
                            	if a:index < 0 || self.length() <= a:index
                            		return ""
                            	endif
                            	let result = self.list[a:index]
                            	unlet self.list[a:index]
                            	if a:index < self.col
                            		call self.set(self.col - 1)
                            	endif
                            	return result
                            endfunction
                            
    1              0.000002 function! s:base.remove_pos()
                            	return self.remove(self.col)
                            endfunction
                            
    1              0.000002 function! s:base.remove_prev()
                            	return self.remove(self.col - 1)
                            endfunction
                            
    1              0.000003 function! s:base.remove_next()
                            	return self.remove(self.col + 1)
                            endfunction
                            
                            
    1              0.000002 function! s:make(...)
                            	let default = get(a:, 1, "")
                            	let result = deepcopy(s:base)
                            	call result.set(default)
                            	return result
                            endfunction
                            
                            " NOTE: old regexpengine has a bug with string which contains binary
                            " :echo "\x80" =~ "\\%#=1\x80"   | " => 0
                            " But it matches correctly with :h /collection
                            " :echo "\x80" =~ "\\%#=1[\x80]" | " => 1
                            " http://lingr.com/room/vim/archives/2015/02/13#message-21261450
    1              0.000007 let s:_engine = exists("+regexpengine") ? '\%#=2' : ''
                            " \<A-]> => √õ\xfdQ
                            " \<A-@> => √Ä\xfeX
    1              0.000011 let s:_regex = exists("+regexpengine")
                            \	? "\\%(√õ\xfdQ\\|√Ä\xfeX\\|\x80\xfc.\\%(\x80..\\|.\\)\\|\x80..\\|.\\)\\zs"
                            \	: "\\%(√õ[\xfd]Q\\|√Ä[\xfe]X\\|[\x80][\xfc].\\%([\x80]..\\|.\\)\\|[\x80]..\\|.\\)\\zs"
    1              0.000004 function! s:_split_keystring(str, ...)
                            	return split(a:str, s:_engine . '\m\%(' . get(a:, 1, '') . s:_regex . '\)')
                            endfunction
                            
    1              0.000003 function! s:split_by_keys(str)
                            	return s:_split_keystring(a:str, "\\%(\<Plug>\\|<Over>\\)(.\\{-})\\zs\\|")
                            endfunction
                            
    1              0.000004 function! s:index(haystack, needle, ...)
                            	let start = get(a:, 1, 0)
                            	let ignorecase = get(a:, 2, &ignorecase)
                            	if ignorecase
                            		return stridx(tolower(a:haystack), tolower(a:needle), start)
                            	else
                            		return stridx(a:haystack, a:needle, start)
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:length(str)
                            	return len(s:split_by_keys(a:str))
                            endfunction
                            
                            
    1   0.000019   0.000018 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim
Sourced 1 time
Total time:   0.000945
 Self time:   0.000937

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000010 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Data#List#import() abort
                                return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Data#List#import() abort', printf("return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
                            " Utilities for list.
                            
    1              0.000016 let s:save_cpo = &cpo
    1   0.000023   0.000020 set cpo&vim
                            
    1              0.000004 function! s:pop(list) abort
                              return remove(a:list, -1)
                            endfunction
                            
    1              0.000004 function! s:push(list, val) abort
                              call add(a:list, a:val)
                              return a:list
                            endfunction
                            
    1              0.000004 function! s:shift(list) abort
                              return remove(a:list, 0)
                            endfunction
                            
    1              0.000005 function! s:unshift(list, val) abort
                              return insert(a:list, a:val)
                            endfunction
                            
    1              0.000004 function! s:cons(x, xs) abort
                              return [a:x] + a:xs
                            endfunction
                            
    1              0.000003 function! s:conj(xs, x) abort
                              return a:xs + [a:x]
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000003 function! s:uniq(list) abort
                              return s:uniq_by(a:list, 'v:val')
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000004 function! s:uniq_by(list, f) abort
                              let list = map(copy(a:list), printf('[v:val, %s]', a:f))
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction
                            
    1              0.000004 function! s:clear(list) abort
                              if !empty(a:list)
                                unlet! a:list[0 : len(a:list) - 1]
                              endif
                              return a:list
                            endfunction
                            
                            " Concatenates a list of lists.
                            " XXX: Should we verify the input?
    1              0.000004 function! s:concat(list) abort
                              let memo = []
                              for Value in a:list
                                let memo += Value
                              endfor
                              return memo
                            endfunction
                            
                            " Take each elements from lists to a new list.
    1              0.000004 function! s:flatten(list, ...) abort
                              let limit = a:0 > 0 ? a:1 : -1
                              let memo = []
                              if limit == 0
                                return a:list
                              endif
                              let limit -= 1
                              for Value in a:list
                                let memo +=
                                      \ type(Value) == type([]) ?
                                      \   s:flatten(Value, limit) :
                                      \   [Value]
                                unlet! Value
                              endfor
                              return memo
                            endfunction
                            
                            " Sorts a list with expression to compare each two values.
                            " a:a and a:b can be used in {expr}.
    1              0.000004 function! s:sort(list, expr) abort
                              if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
                              let s:expr = a:expr
                              return sort(a:list, 's:_compare')
                            endfunction
                            
    1              0.000017 function! s:_compare(a, b) abort
                              return eval(s:expr)
                            endfunction
                            
                            " Sorts a list using a set of keys generated by mapping the values in the list
                            " through the given expr.
                            " v:val is used in {expr}
    1              0.000004 function! s:sort_by(list, expr) abort
                              let pairs = map(a:list, printf('[v:val, %s]', a:expr))
                              return map(s:sort(pairs,
                              \      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')
                            endfunction
                            
                            " Returns a maximum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
    1              0.000004 function! s:max_by(list, expr) abort
                              if empty(a:list)
                                return 0
                              endif
                              let list = map(copy(a:list), a:expr)
                              return a:list[index(list, max(list))]
                            endfunction
                            
                            " Returns a minimum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
                            " FIXME: -0x80000000 == 0x80000000
    1              0.000004 function! s:min_by(list, expr) abort
                              return s:max_by(a:list, '-(' . a:expr . ')')
                            endfunction
                            
                            " Returns List of character sequence between [a:from, a:to]
                            " e.g.: s:char_range('a', 'c') returns ['a', 'b', 'c']
    1              0.000004 function! s:char_range(from, to) abort
                              return map(
                              \   range(char2nr(a:from), char2nr(a:to)),
                              \   'nr2char(v:val)'
                              \)
                            endfunction
                            
                            " Returns true if a:list has a:value.
                            " Returns false otherwise.
    1              0.000004 function! s:has(list, value) abort
                              return index(a:list, a:value) isnot -1
                            endfunction
                            
                            " Returns true if a:list[a:index] exists.
                            " Returns false otherwise.
                            " NOTE: Returns false when a:index is negative number.
    1              0.000005 function! s:has_index(list, index) abort
                              " Return true when negative index?
                              " let index = a:index >= 0 ? a:index : len(a:list) + a:index
                              return 0 <= a:index && a:index < len(a:list)
                            endfunction
                            
                            " similar to Haskell's Data.List.span
    1              0.000004 function! s:span(f, xs) abort
                              let border = len(a:xs)
                              for i in range(len(a:xs))
                                if !eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  let border = i
                                  break
                                endif
                              endfor
                              return border == 0 ? [[], copy(a:xs)] : [a:xs[: border - 1], a:xs[border :]]
                            endfunction
                            
                            " similar to Haskell's Data.List.break
    1              0.000004 function! s:break(f, xs) abort
                              return s:span(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Data.List.takeWhile
    1              0.000005 function! s:take_while(f, xs) abort
                              return s:span(a:f, a:xs)[0]
                            endfunction
                            
                            " similar to Haskell's Data.List.partition
    1              0.000004 function! s:partition(f, xs) abort
                              return [filter(copy(a:xs), a:f), filter(copy(a:xs), '!(' . a:f . ')')]
                            endfunction
                            
                            " similar to Haskell's Prelude.all
    1              0.000004 function! s:all(f, xs) abort
                              return !s:any(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.any
    1              0.000004 function! s:any(f, xs) abort
                              return !empty(filter(map(copy(a:xs), a:f), 'v:val'))
                            endfunction
                            
                            " similar to Haskell's Prelude.and
    1              0.000004 function! s:and(xs) abort
                              return s:all('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.or
    1              0.000003 function! s:or(xs) abort
                              return s:any('v:val', a:xs)
                            endfunction
                            
    1              0.000005 function! s:map_accum(expr, xs, init) abort
                              let memo = []
                              let init = a:init
                              for x in a:xs
                                let expr = substitute(a:expr, 'v:memo', init, 'g')
                                let expr = substitute(expr, 'v:val', x, 'g')
                                let [tmp, init] = eval(expr)
                                call add(memo, tmp)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl
    1              0.000004 function! s:foldl(f, init, xs) abort
                              let memo = a:init
                              for x in a:xs
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl1
    1              0.000004 function! s:foldl1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldl1'
                              endif
                              return s:foldl(a:f, a:xs[0], a:xs[1:])
                            endfunction
                            
                            " similar to Haskell's Prelude.foldr
    1              0.000004 function! s:foldr(f, init, xs) abort
                              return s:foldl(a:f, a:init, reverse(copy(a:xs)))
                            endfunction
                            
                            " similar to Haskell's Prelude.fold11
    1              0.000003 function! s:foldr1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldr1'
                              endif
                              return s:foldr(a:f, a:xs[-1], a:xs[0:-2])
                            endfunction
                            
                            " similar to python's zip()
    1              0.000003 function! s:zip(...) abort
                              return map(range(min(map(copy(a:000), 'len(v:val)'))), "map(copy(a:000), 'v:val['.v:val.']')")
                            endfunction
                            
                            " similar to zip(), but goes until the longer one.
    1              0.000004 function! s:zip_fill(xs, ys, filler) abort
                              if empty(a:xs) && empty(a:ys)
                                return []
                              elseif empty(a:ys)
                                return s:cons([a:xs[0], a:filler], s:zip_fill(a:xs[1 :], [], a:filler))
                              elseif empty(a:xs)
                                return s:cons([a:filler, a:ys[0]], s:zip_fill([], a:ys[1 :], a:filler))
                              else
                                return s:cons([a:xs[0], a:ys[0]], s:zip_fill(a:xs[1 :], a:ys[1: ], a:filler))
                              endif
                            endfunction
                            
                            " Inspired by Ruby's with_index method.
    1              0.000004 function! s:with_index(list, ...) abort
                              let base = a:0 > 0 ? a:1 : 0
                              return map(copy(a:list), '[v:val, v:key + base]')
                            endfunction
                            
                            " similar to Ruby's detect or Haskell's find.
    1              0.000038 function! s:find(list, default, f) abort
                              for x in a:list
                                if eval(substitute(a:f, 'v:val', string(x), 'g'))
                                  return x
                                endif
                              endfor
                              return a:default
                            endfunction
                            
                            " Returns the index of the first element which satisfies the given expr.
    1              0.000005 function! s:find_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction
                            
                            " Returns the index of the last element which satisfies the given expr.
    1              0.000005 function! s:find_last_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : len - 1
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, 0, -1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction
                            
                            " Similar to find_index but returns the list of indices satisfying the given expr.
    1              0.000004 function! s:find_indices(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let result = []
                              if start >=# len || start < 0
                                return result
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  call add(result, i)
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " Return non-zero if a:list1 and a:list2 have any common item(s).
                            " Return zero otherwise.
    1              0.000005 function! s:has_common_items(list1, list2) abort
                              return !empty(filter(copy(a:list1), 'index(a:list2, v:val) isnot -1'))
                            endfunction
                            
    1              0.000005 function! s:intersect(list1, list2) abort
                              let items = []
                              " for funcref
                              for X in a:list1
                                if index(a:list2, X) != -1 && index(items, X) == -1
                                  let items += [X]
                                endif
                              endfor
                              return items
                            endfunction
                            
                            " similar to Ruby's group_by.
    1              0.000004 function! s:group_by(xs, f) abort
                              let result = {}
                              let list = map(copy(a:xs), printf('[v:val, %s]', a:f))
                              for x in list
                                let Val = x[0]
                                let key = type(x[1]) !=# type('') ? string(x[1]) : x[1]
                                if has_key(result, key)
                                  call add(result[key], Val)
                                else
                                  let result[key] = [Val]
                                endif
                                unlet Val
                              endfor
                              return result
                            endfunction
                            
    1              0.000006 function! s:_default_compare(a, b) abort
                              return a:a <# a:b ? -1 : a:a ># a:b ? 1 : 0
                            endfunction
                            
    1              0.000005 function! s:binary_search(list, value, ...) abort
                              let Predicate = a:0 >= 1 ? a:1 : 's:_default_compare'
                              let dic = a:0 >= 2 ? a:2 : {}
                              let start = 0
                              let end = len(a:list) - 1
                            
                              while 1
                                if start > end
                                  return -1
                                endif
                            
                                let middle = (start + end) / 2
                            
                                let compared = call(Predicate, [a:value, a:list[middle]], dic)
                            
                                if compared < 0
                                  let end = middle - 1
                                elseif compared > 0
                                  let start = middle + 1
                                else
                                  return middle
                                endif
                              endwhile
                            endfunction
                            
    1              0.000007 function! s:product(lists) abort
                              let result = [[]]
                              for pool in a:lists
                                let tmp = []
                                for x in result
                                  let tmp += map(copy(pool), 'x + [v:val]')
                                endfor
                                let result = tmp
                              endfor
                              return result
                            endfunction
                            
    1              0.000005 function! s:permutations(list, ...) abort
                              if a:0 > 1
                                throw 'vital: Data.List: too many arguments'
                              endif
                              let r = a:0 == 1 ? a:1 : len(a:list)
                              if r > len(a:list)
                                return []
                              elseif r < 0
                                throw 'vital: Data.List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:product(map(range(r), 'range(n)'))
                                if len(s:uniq(indices)) == r
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction
                            
    1              0.000004 function! s:combinations(list, r) abort
                              if a:r > len(a:list)
                                return []
                              elseif a:r < 0
                                throw 'vital: Data:List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:permutations(range(n), a:r)
                                if s:sort(copy(indices), 'a:a - a:b') == indices
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction
                            
    1   0.000027   0.000022 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim
Sourced 1 time
Total time:   0.000297
 Self time:   0.000292

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000011 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Signals#import() abort
                                return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Signals#import() abort', printf("return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000003 endif
                            " ___vital___
    1              0.000005 scriptencoding utf-8
    1              0.000021 let s:save_cpo = &cpo
    1   0.000028   0.000025 set cpo&vim
                            
                            
    1              0.000006 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:L = s:V.import("Data.List")
                            endfunction
                            
                            
    1              0.000005 function! s:_vital_depends()
                            	return ["Data.List"]
                            endfunction
                            
                            
    1              0.000013 let s:base = {
                            \	"variables" : {
                            \		"slots" : [],
                            \		"counter" : 0,
                            \	}
                            \}
                            
                            
    1              0.000004 function! s:base.connect(slot)
                            	let self.variables.counter += 1
                            	let slot = { "id" : self.variables.counter, "slot" : a:slot }
                            	call add(self.variables.slots, slot)
                            	return slot
                            endfunction
                            
                            
    1              0.000005 function! s:base.disconnect(slot)
                            	if empty(a:slot)
                            		return -1
                            	endif
                            	for i in range(len(self.variables.slots))
                            		if self.variables.slots[i].id == a:slot.id
                            			unlet self.variables.slots[i]
                            			return
                            		endif
                            	endfor
                            	return -1
                            endfunction
                            
                            
    1              0.000003 function! s:base.disconnect_by(expr)
                            	return self.disconnect(self.find_first_by(a:expr))
                            endfunction
                            
                            
    1              0.000004 function! s:call(list, func, ...)
                            	let args = get(a:, 1, [])
                            	let def = get(a:, 2, 0)
                            	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")
                            endfunction
                            
    1              0.000003 function! s:base.call(func, ...)
                            	return call("s:call", [self.slots(), a:func] + a:000)
                            endfunction
                            
                            
    1              0.000002 function! s:base.find_by(expr)
                            	return filter(copy(self.variables.slots), a:expr)
                            endfunction
                            
                            
    1              0.000003 function! s:base.find_first_by(expr)
                            	return get(self.find_by(a:expr), 0, {})
                            endfunction
                            
                            
    1              0.000003 function! s:base.sort_by(expr)
                            	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_slot(val)
                            	return a:val.slot
                            endfunction
                            
                            
    1              0.000002 function! s:base.slots()
                            	return map(copy(self.variables.slots), "self.get_slot(v:val)")
                            endfunction
                            
                            
                            " function! s:base.dict()
                            " 	let result = {}
                            " 	for _ in self.variables.slots
                            " 		let result[_.id] = _.value
                            " 	endfor
                            " 	return result
                            " endfunction
                            
                            
    1              0.000003 function! s:make()
                            	let result = deepcopy(s:base)
                            	return result
                            endfunction
                            
                            
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Input.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000193

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000008 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Over#Input#import() abort
                                return map({'getchar': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Input#import() abort', printf("return map({'getchar': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000021   0.000019 set cpo&vim
                            
                            
    1              0.000003 function! s:getchar(...)
                            	let mode = get(a:, 1, 0)
                            	while 1
                            		" Workaround for https://github.com/osyo-manga/vital-over/issues/53
                            		try
                            			let char = call("getchar", a:000)
                            		catch /^Vim:Interrupt$/
                            			let char = 3 " <C-c>
                            		endtry
                            		" Workaround for the <expr> mappings
                            		if string(char) !=# "\x80\xfd`"
                            			return mode == 1 ? !!char
                            \				 : type(char) == type(0) ? nr2char(char) : char
                            		endif
                            	endwhile
                            endfunction
                            
                            
    1   0.000027   0.000025 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim
Sourced 1 time
Total time:   0.000188
 Self time:   0.000185

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Keymapping#import() abort
                                return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Keymapping#import() abort', printf("return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:as_key_config(config)
                            	let base = {
                            \		"noremap" : 0,
                            \		"lock"    : 0,
                            \		"expr"    : 0,
                            \	}
                            	return type(a:config) == type({}) ? extend(base, a:config)
                            \		 : extend(base, {
                            \		 	"key" : a:config,
                            \		 })
                            endfunction
                            
                            
    1              0.000003 function! s:match_key(keymapping, key)
                            	let keys = sort(keys(a:keymapping))
                            	return get(filter(keys, 'stridx(a:key, v:val) == 0'), -1, '')
                            endfunction
                            
                            
    1              0.000003 function! s:_safe_eval(expr, ...)
                            	call extend(l:, get(a:, 1, {}))
                            	let result = get(a:, 2, "")
                            	try
                            		let result = eval(a:expr)
                            	catch
                            		echohl ErrorMsg | echom v:exception | echohl None
                            	endtry
                            	return result
                            endfunction
                            
                            
    1              0.000004 function! s:_get_key(conf)
                            " 	call extend(l:, a:conf)
                            	let self = a:conf
                            	return get(a:conf, "expr", 0) ? s:_safe_eval(a:conf.key, l:) : a:conf.key
                            endfunction
                            
                            
    1              0.000004 function! s:unmapping(keymapping, key, ...)
                            	let is_locking = get(a:, 1, 0)
                            	let key = s:match_key(a:keymapping, a:key)
                            	if key == ""
                            		return s:String.length(a:key) <= 1 ? a:key : s:unmapping(a:keymapping, a:key[0], is_locking) . s:unmapping(a:keymapping, a:key[1:], is_locking)
                            	endif
                            
                            	let map_conf = s:as_key_config(a:keymapping[key])
                            
                            	let next_input = s:unmapping(a:keymapping, a:key[len(key) : ], is_locking)
                            	if map_conf.lock == 0 && is_locking
                            		return key . next_input
                            	elseif map_conf.lock
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), is_locking) . next_input
                            	else
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), map_conf.noremap) . next_input
                            	endif
                            endfunction
                            
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim
Sourced 1 time
Total time:   0.000126
 Self time:   0.000122

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#import() abort
                                return map({'get': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#import() abort', printf("return map({'get': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            endfunction
                            
                            
    1              0.000003 function! s:get(name)
                            	if exists("s:" . a:name)
                            		return s:{a:name}
                            	endif
                            	let s:{a:name} = s:V.import('Over.Commandline.Modules.' . a:name)
                            	return s:{a:name}
                            endfunction
                            
                            
    1              0.000003 function! s:make(name, ...)
                            	let module = s:get(a:name)
                            	return call(module.make, a:000, module)
                            endfunction
                            
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim
Sourced 1 time
Total time:   0.000274
 Self time:   0.000267

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Palette#Highlight#import() abort
                                return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Palette#Highlight#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000019 let s:save_cpo = &cpo
    1   0.000026   0.000024 set cpo&vim
                            
                            
    1              0.000006 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Message  = s:V.import("Vim.Message")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Vim.Message",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:_execute(cmd)
                            	execute a:cmd
                            endfunction
                            
                            
    1              0.000003 function! s:capture(name)
                            	if hlexists(a:name) == 0
                            		return ""
                            	endif
                            	return s:Message.capture("highlight " . a:name)
                            endfunction
                            
                            
    1              0.000003 function! s:links_to(highlight)
                            	return matchstr(a:highlight, '^\S\+\s\+xxx links to \zs.*\ze$')
                            endfunction
                            
                            
    1              0.000003 function! s:parse_to_name(highlight)
                            	return matchstr(a:highlight, '^\zs\w\+\ze')
                            endfunction
                            
                            
    1              0.000003 function! s:parse(highlight)
                            	let highlight = a:highlight
                            	
                            	if highlight !~# '^\w\+\s\+xxx\s'
                            		return {}
                            	endif
                            
                            	let name = s:parse_to_name(a:highlight)
                            	let result = { "_name" : name }
                            
                            	if highlight =~# '^\w\+\s\+xxx cleared'
                            		let result.cleared = 1
                            		return result
                            	endif
                            
                            	let link = s:links_to(highlight)
                            	if link != ""
                            		let result.link = link
                            		return result
                            	endif
                            
                            	let attrs = [
                            \		"term",
                            \		"cterm",
                            \		"ctermfg",
                            \		"ctermbg",
                            \		"gui",
                            \		"font",
                            \		"guifg",
                            \		"guibg",
                            \		"guisp",
                            \	]
                            	for attr in attrs
                            		let item = matchstr(highlight, '\s' . attr . '=\zs#\?\w\+\ze')
                            		if item != ""
                            			let result[attr] = item
                            		endif
                            	endfor
                            	return result
                            endfunction
                            
                            
    1              0.000003 function! s:get(name, ...)
                            	if !hlexists(a:name)
                            		return {}
                            	endif
                            	let result = s:parse(substitute(s:capture(a:name), "\n", "", "g"))
                            	if has_key(result, "link") && get(a:, 1, 0)
                            		return s:get(result.link, get(a:, 1, 0))
                            	else
                            		return result
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:set(name, config)
                            	if type(a:config) == type("")
                            		return s:set(a:config, s:get(a:config))
                            	endif
                            	if has_key(a:config, "cleared")
                            		return s:_execute("highlight clear " . a:name)
                            	endif
                            	if has_key(a:config, "link")
                            		return s:_execute("highlight link " . a:name . " " . a:config.link)
                            	endif
                            	return s:_execute("highlight " . a:name . " " . join(map(items(filter(a:config, "v:key !=# '_name'")), "v:val[0] . '=' . v:val[1]"), " "))
                            endfunction
                            
                            
    1              0.000003 function! s:group_list()
                            	let highlights = split(s:Message.capture("highlight"), "\n")
                            	return filter(map(highlights, "s:parse_to_name(v:val)"), "v:val != ''")
                            endfunction
                            
                            
    1   0.000023   0.000018 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Message.vim
Sourced 1 time
Total time:   0.000219
 Self time:   0.000216

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Vim#Message#import() abort
                                return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Vim#Message#import() abort', printf("return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000013 let s:save_cpo = &cpo
    1   0.000019   0.000018 set cpo&vim
                            
                            
                            
    1              0.000004 function! s:echo(hl, msg) abort
                              execute 'echohl' a:hl
                              try
                                echo a:msg
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000044 function! s:echomsg(hl, msg) abort
                              execute 'echohl' a:hl
                              try
                                for m in split(a:msg, "\n")
                                  echomsg m
                                endfor
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000005 function! s:error(msg) abort
                              call s:echomsg('ErrorMsg', a:msg)
                            endfunction
                            
    1              0.000003 function! s:warn(msg) abort
                              call s:echomsg('WarningMsg', a:msg)
                            endfunction
                            
    1              0.000003 function! s:capture(command) abort
                              try
                                redir => out
                                silent execute a:command
                              finally
                                redir END
                              endtry
                              return out
                            endfunction
                            
                            " * Get max length of |hit-enter|.
                            "   If a string length of a message is greater than the max length,
                            "   Vim waits for user input according to |hit-enter|.
                            " XXX: Those fixed values may be different between different OSes?
                            "      Currently tested on only Windows.
    1              0.000005 function! s:get_hit_enter_max_length() abort
                              let maxlen = &columns * &cmdheight - 1
                              if &ruler
                                " TODO
                              endif
                              if &showcmd
                                let maxlen -= 11
                              endif
                              return maxlen
                            endfunction
                            
                            
                            
    1   0.000021   0.000019 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim
Sourced 1 time
Total time:   0.000134
 Self time:   0.000130

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#Exit#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Exit#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
    1              0.000007 let s:module = {
                            \	"name" : "Exit",
                            \	"exit_code" : 0
                            \}
                            
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(exit)")
                            		call a:cmdline.setchar("")
                            		call a:cmdline.exit(self.exit_code)
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim
Sourced 1 time
Total time:   0.000249
 Self time:   0.000242

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000012 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000008   function! vital#_easymotion#Over#Commandline#Modules#Cancel#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Cancel#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000020 let s:save_cpo = &cpo
    1   0.000026   0.000023 set cpo&vim
                            
    1              0.000055 let s:module = {
                            \	"name" : "Cancel"
                            \}
                            
    1              0.000005 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<Esc>")
                            \	|| a:cmdline.is_input("\<C-c>")
                            " 		call a:cmdline.cancel()
                            		call a:cmdline.exit(1)
                            		call a:cmdline.setchar("")
                            	endif
                            endfunction
                            
                            
    1              0.000012 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000025   0.000021 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim
Sourced 1 time
Total time:   0.000160
 Self time:   0.000156

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Over#Commandline#Modules#Redraw#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Redraw#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000002 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "Redraw",
                            \}
                            
    1              0.000003 function! s:module.on_execute_pre(cmdline)
                            	call self.redraw(a:cmdline)
                            endfunction
                            
    1              0.000003 function! s:module.on_enter(...)
                            	let self.is_execute = 0
                            endfunction
                            
    1              0.000002 function! s:module.on_execute(...)
                            	let self.is_execute = 1
                            endfunction
                            
    1              0.000002 function! s:module.on_execute_failed(...)
                            	let self.is_execute = 0
                            endfunction
                            
    1              0.000002 function! s:module.on_leave(cmdline)
                            	if self.is_execute == 0 && a:cmdline.exit_code() != -1
                            		call self.redraw(a:cmdline)
                            	endif
                            endfunction
                            
                            
                            " function! s:module.on_draw_pre(cmdline)
                            " 	call self.redraw(a:cmdline)
                            " endfunction
                            
                            
    1              0.000002 function! s:module.redraw(cmdline)
                            	redraw
                            	" Workaround for the :set cedit=<C-c>
                            	" https://github.com/osyo-manga/vital-over/issues/52
                            	" https://github.com/Lokaltog/vim-easymotion/issues/177#issuecomment-53663431
                            	if &cedit != "<C-c>"
                            \	||(v:version > 704 || v:version == 704 && has("patch441"))
                            		normal! :
                            	else
                            		execute "normal! :\<Esc>"
                            	endif
                            endfunction
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000016   0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim
Sourced 1 time
Total time:   0.000355
 Self time:   0.000331

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000009 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000024   function! vital#_easymotion#Over#Commandline#Modules#DrawCommandline#import() abort
                                return map({'suffix': '', 'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#DrawCommandline#import() abort', printf("return map({'suffix': '', 'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000042   0.000020 set cpo&vim
                            
    1              0.000007 let s:module = {
                            \	"name" : "DrawCommandline"
                            \}
                            
    1              0.000003 let s:cmdheight = {}
                            
    1              0.000003 function! s:cmdheight.save()
                            	if has_key(self, "value")
                            		return
                            	endif
                            	let self.value = &cmdheight
                            endfunction
                            
    1              0.000003 function! s:cmdheight.restore()
                            	if has_key(self, "value")
                            		let &cmdheight = self.value
                            		unlet self.value
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:cmdheight.get()
                            	return self.value
                            endfunction
                            
                            
    1              0.000004 function! s:suffix(left, suffix)
                            	let left_len = strdisplaywidth(a:left)
                            	let len = &columns - left_len % &columns
                            	let len = len + (&columns * (strdisplaywidth(a:suffix) > (len - 1))) - 1
                            	return repeat(" ", len - strdisplaywidth(a:suffix)) . a:suffix
                            " 	return printf("%" . len . "S", a:suffix)
                            endfunction
                            
                            
    1              0.000004 let s:old_width = 0
    1              0.000003 function! s:_redraw(cmdline)
                            	let left = a:cmdline.get_prompt() . a:cmdline.getline() . (empty(a:cmdline.line.pos_char()) ? " " : "")
                            	let width = len(left) + 1
                            
                            	if a:cmdline.get_suffix() != ""
                            		let width += len(s:suffix(left, a:cmdline.get_suffix())) - 1
                            	endif
                            
                            	if &columns >= width && &columns <= s:old_width && s:old_width >= width
                            		redraw
                            		normal! :
                            	elseif &columns <= width
                            		normal! :
                            	else
                            		redraw
                            	endif
                            	let s:old_width = width
                            
                            	call s:cmdheight.save()
                            	let height = max([(width - 1) / (&columns) + 1, s:cmdheight.get()])
                            	if height > &cmdheight || &cmdheight > height
                            		let &cmdheight = height
                            		redraw
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:_as_echon(str)
                            	return "echon " . strtrans(string(a:str))
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_draw_pre(cmdline)
                            	if empty(a:cmdline.line.pos_char())
                            		let cursor = "echohl " . a:cmdline.highlights.cursor . " | echon ' '"
                            	else
                            		let cursor = "echohl " . a:cmdline.highlights.cursor_on . " | " . s:_as_echon(a:cmdline.line.pos_char())
                            	endif
                            	let suffix = ""
                            	if	a:cmdline.get_suffix() != ""
                            		let suffix = s:_as_echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            	endif
                            	let self.draw_command  = join([
                            \		"echohl " . a:cmdline.highlights.prompt,
                            \		s:_as_echon(a:cmdline.get_prompt()),
                            \		"echohl NONE",
                            \		s:_as_echon(a:cmdline.backward()),
                            \		cursor,
                            \		"echohl NONE",
                            \		s:_as_echon(a:cmdline.forward()),
                            \		suffix,
                            \	], " | ")
                            
                            	call s:_redraw(a:cmdline)
                            endfunction
                            
                            
    1              0.000003 function! s:_echon(expr)
                            	echon strtrans(a:expr)
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_draw(cmdline)
                            	execute self.draw_command
                            " 	execute "echohl" a:cmdline.highlights.prompt
                            " 	call s:echon(a:cmdline.get_prompt())
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.backward())
                            " 	if empty(a:cmdline.line.pos_char())
                            " 		execute "echohl" a:cmdline.highlights.cursor
                            " 		call s:echon(' ')
                            " 	else
                            " 		execute "echohl" a:cmdline.highlights.cursor_on
                            " 		call s:echon(a:cmdline.line.pos_char())
                            " 	endif
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.forward())
                            " 	if	a:cmdline.get_suffix() != ""
                            " 		call s:echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            " 	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_execute_pre(...)
                            	call s:cmdheight.restore()
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_leave(...)
                            	call s:cmdheight.restore()
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim
Sourced 1 time
Total time:   0.000227
 Self time:   0.000222

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000010 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000008   function! vital#_easymotion#Over#Commandline#Modules#Delete#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Delete#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000010 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000026 let s:save_cpo = &cpo
    1   0.000046   0.000043 set cpo&vim
                            
                            
    1              0.000009 let s:module = {
                            \	"name" : "Delete",
                            \}
    1              0.000005 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-h>")
                            \	|| a:cmdline.is_input("\<BS>")
                            		if a:cmdline.line.length() == 0
                            			return a:cmdline.exit(1)
                            		else
                            			call a:cmdline.line.remove_prev()
                            			call a:cmdline.setchar('')
                            		endif
                            	elseif a:cmdline.is_input("\<Del>")
                            		call a:cmdline.line.remove_pos()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-w>")
                            		let word = a:cmdline.backward_word()
                            		let backward = a:cmdline.backward()[ : -strlen(word)-1 ]
                            		call a:cmdline.setline(backward . a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(strchars(backward))
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-u>")
                            		call a:cmdline.setline(a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim
Sourced 1 time
Total time:   0.000320
 Self time:   0.000313

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000024 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#CursorMove#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#CursorMove#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000120   0.000116 set cpo&vim
                            
                            
    1              0.000011 let s:module = {
                            \	"name" : "CursorMove"
                            \}
    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<Right>")
                            		call a:cmdline.line.next()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<Left>")
                            		call a:cmdline.line.prev()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-b>")
                            \		|| a:cmdline.is_input("\<Home>")
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-e>")
                            \		|| a:cmdline.is_input("\<End>")
                            		call a:cmdline.setline(a:cmdline.line.length())
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-Left>")
                            \		|| a:cmdline.is_input("\<S-Left>")
                            		call a:cmdline.setline(strridx(a:cmdline.backward()[:-2], ' ') + 1)
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-Right>")
                            \		|| a:cmdline.is_input("\<S-Right>")
                            		let p = stridx(a:cmdline.forward()[1:], ' ')
                            		call a:cmdline.setline(p != -1 ? a:cmdline.line.pos() + p + 2 : a:cmdline.line.length())
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction
                            
                            
    1              0.000004 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000025   0.000022 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim
Sourced 1 time
Total time:   0.000128
 Self time:   0.000124

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#Paste#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Paste#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "Paste"
                            \}
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(paste)")
                            		let register = v:register == "" ? '"' : v:register
                            		call a:cmdline.insert(tr(getreg("*"), "\n", "\r"))
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim
Sourced 1 time
Total time:   0.000373
 Self time:   0.000351

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000009 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000008   function! vital#_easymotion#Over#Commandline#Modules#BufferComplete#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#BufferComplete#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000021   0.000018 set cpo&vim
                            
                            
    1              0.000004 function! s:_uniq(list)
                            	let dict = {}
                            	for _ in a:list
                            		let dict[_] = 0
                            	endfor
                            	return keys(dict)
                            endfunction
                            
                            
    1              0.000007 let s:module = {
                            \	"name" : "BufferComplete",
                            \}
                            
                            
    1              0.000003 function! s:_buffer_complete()
                            	return sort(s:_uniq(filter(split(join(getline(1, '$')), '\W'), '!empty(v:val)')), 1)
                            endfunction
                            
                            
    1              0.000004 function! s:_parse_line(line)
                            	let keyword = matchstr(a:line, '\zs\w\+\ze$')
                            	let pos = strchars(a:line) - strchars(keyword)
                            	return [pos, keyword]
                            endfunction
                            
                            
    1              0.000004 function! s:_as_statusline(list, count)
                            	if empty(a:list)
                            		return
                            	endif
                            	let hl_none = "%#StatusLine#"
                            	let hl_select = "%#StatusLineNC#"
                            	let tail = " > "
                            	let result = a:list[0]
                            	let pos = 0
                            	for i in range(1, len(a:list)-1)
                            		if strdisplaywidth(result . " " . a:list[i]) > &columns - len(tail)
                            			if a:count < i
                            				break
                            			else
                            				let pos = -i
                            			endif
                            			let result = a:list[i]
                            		else
                            			let result .= (" " . a:list[i])
                            		endif
                            		if a:count == i
                            			let pos = pos + i
                            		endif
                            	endfor
                            	return join(map(split(result, " "), 'v:key == pos ? hl_select . v:val . hl_none : v:val'))
                            endfunction
                            
                            
    1              0.000003 function! s:module.get_complete_words()
                            	return s:_buffer_complete()
                            endfunction
                            
                            
    1              0.000002 function! s:module.complete(cmdline)
                            	call s:_finish()
                            	let s:old_statusline = &statusline
                            
                            	let backward = a:cmdline.backward()
                            	let [pos, keyword] = s:_parse_line(backward)
                            
                            	if !exists("s:complete")
                            		let s:complete = self.get_complete_words()
                            	endif
                            	let s:complete_list = filter(copy(s:complete), 'v:val =~ ''^''.keyword')
                            	if empty(s:complete_list)
                            		return -1
                            	endif
                            
                            	if pos == 0
                            		let backward = ""
                            	else
                            		let backward = join(split(backward, '\zs')[ : pos-1 ], "")
                            	endif
                            	let s:line = backward . a:cmdline.forward()
                            	let s:pos = pos
                            	call a:cmdline.setline(s:line)
                            
                            	let s:count = 0
                            endfunction
                            
                            
    1              0.000003 function! s:_finish()
                            	if exists("s:old_statusline")
                            		let &statusline = s:old_statusline
                            		unlet s:old_statusline
                            		redrawstatus
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(buffer-complete)")
                            \		|| a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            		if self.complete(a:cmdline) == -1
                            			call s:_finish()
                            			call a:cmdline.setchar('')
                            			return
                            		endif
                            		if a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            		call a:cmdline.setchar('')
                            		call a:cmdline.tap_keyinput("Completion")
                            " 	elseif a:cmdline.is_input("\<Tab>", "Completion")
                            	elseif a:cmdline.is_input("<Over>(buffer-complete)", "Completion")
                            \		|| a:cmdline.is_input("\<Right>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count += 1
                            		if s:count >= len(s:complete_list)
                            			let s:count = 0
                            		endif
                            	elseif a:cmdline.is_input("<Over>(buffer-complete-prev)", "Completion")
                            \		|| a:cmdline.is_input("\<Left>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count -= 1
                            		if s:count < 0
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            	else
                            		if a:cmdline.untap_keyinput("Completion")
                            			call a:cmdline.callevent("on_char_pre")
                            		endif
                            		call s:_finish()
                            		return
                            	endif
                            	call a:cmdline.setline(s:line)
                            	call a:cmdline.insert(s:complete_list[s:count], s:pos)
                            	if len(s:complete_list) > 1
                            		let &statusline = s:_as_statusline(s:complete_list, s:count)
                            		redrawstatus
                            	endif
                            	if len(s:complete_list) == 1
                            		call a:cmdline.untap_keyinput("Completion")
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_draw_pre(...)
                            " 	redrawstatus
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_leave(cmdline)
                            	call s:_finish()
                            	unlet! s:complete
                            endfunction
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
    1   0.000044   0.000025 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim
Sourced 1 time
Total time:   0.000326
 Self time:   0.000322

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000023 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000026   function! vital#_easymotion#Over#Commandline#Modules#InsertRegister#import() abort
                                return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#InsertRegister#import() abort', printf("return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:to_string(expr)
                            	return type(a:expr) == type("") ? a:expr : string(a:expr)
                            endfunction
                            
                            
    1              0.000003 function! s:input(cmdline)
                            	let CR_index = index(a:cmdline.input_key_stack(), "\<CR>")
                            	if CR_index != -1
                            		let input = a:cmdline.input_key_stack_string()
                            		let input = input[ : CR_index-1]
                            		call a:cmdline.set_input_key_stack(a:cmdline.input_key_stack()[CR_index+1 : ])
                            		return eval(input)
                            	endif
                            
                            	let input_text = ""
                            	if !empty(a:cmdline.input_key_stack())
                            		let input_text = a:cmdline.input_key_stack_string()
                            		call a:cmdline.set_input_key_stack([])
                            	endif
                            
                            	call a:cmdline.hl_cursor_on()
                            	try
                            		redraw
                            		let input = input("=", input_text, "expression")
                            		if !empty(input)
                            			let input = s:to_string(eval(input))
                            		endif
                            	catch
                            		return ""
                            	finally
                            		call a:cmdline.hl_cursor_off()
                            	endtry
                            	return input
                            endfunction
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "InsertRegister"
                            \}
                            
                            
                            
    1              0.000003 function! s:module.reset()
                            	let self.cword = expand("<cword>")
                            	let self.cWORD = expand("<cWORD>")
                            	let self.cfile = expand("<cfile>")
                            endfunction
                            
    1              0.000002 function! s:module.on_enter(...)
                            	call self.reset()
                            " 	let self.prefix_key = ""
                            endfunction
                            
                            
    1              0.000004 function! s:get_cmdline_cword(backward, cword)
                            " 	let backward = matchstr(a:backward, '.\{-}\zs\k\+$')
                            	let backward = a:backward
                            	if &incsearch == 0 || a:cword == "" || a:backward == "" || s:String.index(a:cword, backward) != 0
                            		return a:cword
                            	endif
                            	return a:cword[len(backward) : ]
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.setchar('"')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
                            	elseif exists("self.prefix_key")
                            \		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let char = a:cmdline.input_key()
                            		if char =~ '^[0-9a-zA-z.%#:/"\-*+]$'
                            			let register = tr(getreg(char), "\n", "\r")
                            			call a:cmdline.setchar(register)
                            		elseif char == "="
                            			call a:cmdline.setchar(s:input(a:cmdline))
                            		elseif char == "\<C-w>"
                            			call a:cmdline.setchar(s:get_cmdline_cword(a:cmdline.backward_word(), self.cword))
                            		elseif char == "\<C-a>"
                            			call a:cmdline.setchar(self.cWORD)
                            		elseif char == "\<C-f>"
                            			call a:cmdline.setchar(self.cfile)
                            		elseif char == "\<C-r>"
                            			call a:cmdline.setchar('"')
                            		else
                            			call a:cmdline.setchar("")
                            		endif
                            " 		elseif a:cmdline.is_input('=', self.prefix_key)
                            " 			call a:cmdline.setchar(s:input(a:cmdline))
                            " 		elseif a:cmdline.is_input("\<C-w>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cword)
                            " 		elseif a:cmdline.is_input("\<C-a>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cWORD)
                            " 		elseif a:cmdline.is_input("\<C-f>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cfile)
                            " 		elseif a:cmdline.is_input("\<C-r>", self.prefix_key)
                            " 			call a:cmdline.setchar('"')
                            " 		else
                            " 			call a:cmdline.setchar("")
                            " 		endif
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_char(cmdline)
                            	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
                            	else
                            		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
                            		endif
                            	endif
                            endfunction
                            
                            
                            
    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionExit.vim
Sourced 1 time
Total time:   0.000121
 Self time:   0.000119

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#ExceptionExit#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#ExceptionExit#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000017 set cpo&vim
                            
    1              0.000006 let s:module = {
                            \	"name" : "ExceptionExit",
                            \}
                            
                            
    1              0.000003 function! s:module.on_exception(cmdline)
                            	call a:cmdline.exit(-1)
                            endfunction
                            
                            
    1              0.000002 function! s:make(...)
                            	let result = deepcopy(s:module)
                            	let result.exit_code = get(a:, 1, 0)
                            	return result
                            endfunction
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim
Sourced 1 time
Total time:   0.000158
 Self time:   0.000154

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#ExceptionMessage#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#ExceptionMessage#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000009 let s:vname = expand("<sfile>:h:h:h:h:t")
                            
                            
    1              0.000005 let s:module = {
                            \	"name" : "ExceptionMessage",
                            \}
                            
                            
    1              0.000004 function! s:module.on_exception(cmdline)
                            	let self.exception  = v:exception
                            	let self.throwpoint = v:throwpoint
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_draw_pre(cmdline)
                            	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
                            	endif
                            endfunction
                            
    1              0.000003 function! s:module.message(...)
                            	echohl ErrorMsg
                            	execute self.command string(self.prefix . " : " . self.throwpoint . " " . self.exception)
                            	echohl None
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_leave(cmdline)
                            	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make(...)
                            	let result = deepcopy(s:module)
                            	let result.prefix = get(a:, 1, "vital-over(".s:vname.") Exception")
                            	let result.command = get(a:, 2, "echom")
                            	return result
                            endfunction
                            
                            
    1   0.000016   0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim
Sourced 1 time
Total time:   0.000164
 Self time:   0.000158

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Over#Commandline#Modules#History#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#History#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
    1              0.000006 let s:module = {
                            \	"name" : "History",
                            \	"mode" : "cmd",
                            \}
                            
    1              0.000003 function! s:module.histories()
                            	return map(range(1, &history), 'histget(self.mode, v:val * -1)')
                            endfunction
                            
    1              0.000004 function! s:_should_match_cmdline(cmdline)
                            	return a:cmdline.is_input("\<Up>")
                            \		|| a:cmdline.is_input("\<Down>")
                            endfunction
                            
    1              0.000003 function! s:_reset()
                            	let s:cmdhist = []
                            	let s:count = 0
                            	let s:is_match_mode = 0 " <Up>/<Down>: true, <C-n>/<C-p>: false
                            endfunction
                            
    1              0.000002 function! s:module.on_enter(...)
                            	call s:_reset()
                            endfunction
                            
    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if !a:cmdline.is_input("\<Up>") && !a:cmdline.is_input("\<Down>")
                            	\	&& !a:cmdline.is_input("\<C-p>") && !a:cmdline.is_input("\<C-n>")
                            		call s:_reset()
                            		return
                            	else
                            		if s:count == 0 && empty(s:cmdhist)
                            		\	|| s:is_match_mode != s:_should_match_cmdline(a:cmdline)
                            			let cmdline = '^' . a:cmdline.getline()
                            			let s:is_match_mode = s:_should_match_cmdline(a:cmdline)
                            			let s:cmdhist = [a:cmdline.getline()] + (s:is_match_mode ?
                            			\	filter(self.histories(), 'v:val =~ cmdline') : self.histories())
                            		endif
                            	endif
                            	call a:cmdline.setchar("")
                            	if a:cmdline.is_input("\<Down>") || a:cmdline.is_input("\<C-n>")
                            		let s:count = max([s:count - 1, 0])
                            	endif
                            	if a:cmdline.is_input("\<Up>") || a:cmdline.is_input("\<C-p>")
                            		let s:count = min([s:count + 1, len(s:cmdhist)])
                            	endif
                            	call a:cmdline.setline(get(s:cmdhist, s:count, a:cmdline.getline()))
                            endfunction
                            
    1              0.000003 function! s:make(...)
                            	let module = deepcopy(s:module)
                            	let module.mode = get(a:, 1, "cmd")
                            	return module
                            endfunction
                            
    1   0.000019   0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim
Sourced 1 time
Total time:   0.000144
 Self time:   0.000141

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Over#Commandline#Modules#NoInsert#import() abort
                                return map({'make_special_chars': '', 'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#NoInsert#import() abort', printf("return map({'make_special_chars': '', 'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
    1              0.000007 let s:module = {
                            \	"name" : "NoInsert",
                            \	"chars" : []
                            \}
                            
                            
    1              0.000003 function! s:module.is_no_insert(char)
                            	return index(self.chars, a:char) >= 0
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if self.is_no_insert(a:cmdline.char())
                            		call a:cmdline.setchar("", 0)
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make(chars)
                            	let module = deepcopy(s:module)
                            	let module.chars = type(a:chars) == type([]) ? a:chars : [a:chars]
                            	return module
                            endfunction
                            
                            
    1              0.000004 function! s:make_special_chars()
                            	let module = s:make([])
                            	function! module.is_no_insert(char)
                            		return char2nr(a:char) == 128 || char2nr(a:char) < 27
                            	endfunction
                            	return module
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim
Sourced 1 time
Total time:   0.000322
 Self time:   0.000317

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Modules#KeyMapping#import() abort
                                return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#KeyMapping#import() abort', printf("return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000019 endif
                            " ___vital___
    1              0.000002 scriptencoding utf-8
    1              0.000051 let s:save_cpo = &cpo
    1   0.000024   0.000021 set cpo&vim
                            
                            
    1              0.000006 function! s:_vital_loaded(V)
                            	let s:Keymapping = a:V.import("Palette.Keymapping")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Palette.Keymapping",
                            \	]
                            endfunction
                            
                            
    1              0.000008 let s:emacs = {
                            \	"name" : "KeyMapping_emacs_like"
                            \}
                            
    1              0.000005 function! s:emacs.keymapping(cmdline)
                            	return {
                            \		"\<C-f>" : {
                            \			"key" : "\<Right>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-b>" : {
                            \			"key" : "\<Left>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-n>" : {
                            \			"key" : "\<Down>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-p>" : {
                            \			"key" : "\<Up>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-a>" : {
                            \			"key" : "\<Home>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-e>" : {
                            \			"key" : "\<End>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-d>" : {
                            \			"key" : "\<Del>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-d>" : {
                            \			"key" : "\<C-w>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-b>" : {
                            \			"key" : "\<S-Left>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-f>" : {
                            \			"key" : "\<S-Right>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \	}
                            endfunction
                            
                            
    1              0.000017 function! s:make_emacs()
                            	return deepcopy(s:emacs)
                            endfunction
                            
                            
    1              0.000012 let s:vim_cmdline_mapping = {
                            \	"name" : "KeyMapping_vim_cmdline_mapping",
                            \	"_cmaps" : {}
                            \}
                            
    1              0.000006 function! s:_convert_sid(rhs, sid) abort
                            	return substitute(a:rhs, '<SID>', '<SNR>' . a:sid . '_', 'g')
                            endfunction
                            
    1              0.000004 function! s:_auto_cmap()
                            	let cmaps = {}
                            	let cmap_info = s:Keymapping.rhs_key_list("c", 0, 1)
                            	" vital-over currently doesn't support <buffer> mappings
                            	for c in filter(cmap_info, "v:val['buffer'] ==# 0")
                            		let cmaps[s:Keymapping.escape_special_key(c['lhs'])] = {
                            		\   'noremap' : c['noremap'],
                            		\   'key'  : s:Keymapping.escape_special_key(s:_convert_sid(c['rhs'], c['sid'])),
                            		\   'expr' : s:Keymapping.escape_special_key(c['expr']),
                            		\ }
                            	endfor
                            	return cmaps
                            endfunction
                            
                            
    1              0.000005 function! s:vim_cmdline_mapping.on_enter(cmdline)
                            	let self._cmaps = s:_auto_cmap()
                            endfunction
                            
                            
    1              0.000005 function! s:vim_cmdline_mapping.keymapping(cmdline)
                            	return self._cmaps
                            endfunction
                            
                            
    1              0.000005 function! s:make_vim_cmdline_mapping()
                            	return deepcopy(s:vim_cmdline_mapping)
                            endfunction
                            
                            
                            
    1   0.000022   0.000020 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Keymapping.vim
Sourced 1 time
Total time:   0.000241
 Self time:   0.000238

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000008 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Palette#Keymapping#import() abort
                                return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Palette#Keymapping#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000004 let s:modep = "[nvoicsxl]"
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Capture  = s:V.import("Palette.Capture")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Palette.Capture",
                            \	]
                            endfunction
                            
                            
    1              0.000003 function! s:_capture(mode)
                            	let cmd = "map"
                            	if a:mode ==# "!"
                            		let cmd = cmd . "!"
                            	elseif a:mode =~# "[nvoicsxl]"
                            		let cmd = a:mode . cmd
                            	endif
                            	return s:Capture.command(cmd)
                            endfunction
                            
                            
    1              0.000002 function! s:capture(...)
                            	let mode = get(a:, 1, "")
                            	let modes = split(mode, '\zs')
                            	return join(map(modes, "s:_capture(v:val)"), "\n")
                            endfunction
                            
                            
    1              0.000003 function! s:_keymapping(str)
                            	return a:str =~ '^[!nvoicsxl]\s'
                            endfunction
                            
                            
    1              0.000003 function! s:capture_list(...)
                            	let mode = get(a:, 1, "")
                            	return filter(split(s:capture(mode), "\n"), "s:_keymapping(v:val)")
                            endfunction
                            
                            
    1              0.000004 function! s:escape_special_key(key)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
                            	if a:key ==# "<^?>"
                            		return "\<C-?>"
                            	endif
                            	execute 'let result = "' . substitute(escape(a:key, '\"'), '\(<.\{-}>\)', '\\\1', 'g') . '"'
                            	return result
                            endfunction
                            
                            
    1              0.000004 function! s:parse_lhs(text, ...)
                            	let mode = get(a:, 1, '[!nvoicsxl]')
                            	" NOTE: :map! Surpport : https://github.com/osyo-manga/vital-palette/issues/4
                            	if get(a:, 1, "") =~# '[!ci]'
                            		let mode = '[!ci]'
                            	endif
                            	return matchstr(a:text, mode . '\{1,3\}\s*\zs\S\{-}\ze\s\+')
                            endfunction
                            
                            
    1              0.000003 function! s:parse_lhs_list(...)
                            	let mode = get(a:, 1, "")
                            	return map(s:capture_list(mode), "s:parse_lhs(v:val, mode)")
                            endfunction
                            
                            
    1              0.000004 function! s:lhs_key_list(...)
                            	let mode = get(a:, 1, "")
                            	return map(s:parse_lhs_list(mode), "s:escape_special_key(v:val)")
                            endfunction
                            
                            
    1              0.000004 function! s:_maparg(name, mode, abbr, dict)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
                            	if a:name ==# "<^?>"
                            		return maparg("\<C-?>", a:mode, a:abbr, a:dict)
                            	endif
                            	return maparg(a:name, a:mode, a:abbr, a:dict)
                            endfunction
                            
                            
    1              0.000003 function! s:rhs_key_list(...)
                            	let mode = get(a:, 1, "")
                            	let abbr = get(a:, 2, 0)
                            	let dict = get(a:, 3, 0)
                            	
                            	let result = []
                            	for m in split(mode, '\zs')
                            		let result += map(s:parse_lhs_list(m), "s:_maparg(v:val, m, abbr, dict)")
                            	endfor
                            	return filter(result, "empty(v:val) == 0")
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Capture.vim
Sourced 1 time
Total time:   0.000256
 Self time:   0.000252

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000068 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Palette#Capture#import() abort
                                return map({'extend': '', 'command': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Palette#Capture#import() abort', printf("return map({'extend': '', 'command': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000020   0.000017 set cpo&vim
                            
                            
    1              0.000004 let s:verbosefiles = []
                            
    1              0.000005 function! s:_verbosefile_push(file)
                            	call add(s:verbosefiles, &verbosefile)
                            	let &verbosefile = a:file
                            	return a:file
                            endfunction
                            
                            
    1              0.000004 function! s:_verbosefile_pop()
                            	let filename = &verbosefile
                            	let &verbosefile = get(s:verbosefiles, -1)
                            	call remove(s:verbosefiles, -1)
                            	return filename
                            endfunction
                            
                            
    1              0.000003 function! s:_reset()
                            	let s:verbosefiles = []
                            endfunction
                            
                            
    1              0.000003 function! s:extend(dict, src)
                            	for [key, value] in items(a:src)
                            		let a:dict[key] = value
                            		unlet value
                            	endfor
                            endfunction
                            
                            
    1              0.000003 function! s:command(cmd, ...)
                            	" Workaround : Vim 7.3.xxx in Travis and Ubuntu
                            	" https://github.com/osyo-manga/vital-palette/issues/5
                            " 	call extend(l:, get(a:, 1, {}))
                            	if a:0 > 0
                            		call s:extend(l:, a:1)
                            	endif
                            
                            	call s:_verbosefile_push(tempname())
                            	try
                            		redir =>result
                            		silent execute a:cmd
                            	finally
                            		redir END
                            	endtry
                            	call s:_verbosefile_pop()
                            " 	let result = substitute(result, "<SRN>", "\<SNR>", "g")
                            " 	let result = substitute(result, "<SID>", "\<SID>", "g")
                            	return result
                            endfunction
                            
                            
    1   0.000018   0.000017 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim
Sourced 1 time
Total time:   0.000691
 Self time:   0.000684

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000008 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#Doautocmd#import() abort
                                return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Doautocmd#import() abort', printf("return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000005 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:E  = s:V.import("Over.Exception")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Over.Exception",
                            \	]
                            endfunction
                            
                            
    1              0.000004 let s:cache_command = {}
    1              0.000005 function! s:doautocmd_user(prefix, command)
                            	let group =  a:prefix . "-vital-over-commandline-doautocmd-dummy"
                            	if !has_key(s:cache_command, a:prefix)
                            		let s:cache_command[a:prefix] = {}
                            	endif
                            
                            	if !has_key(s:cache_command[a:prefix], a:command)
                            		execute "autocmd " . group
                            \			. " User " . a:command." silent! execute ''"
                            
                            		if v:version > 703 || v:version == 703 && has("patch438")
                            			let s:cache_command[a:prefix][a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:prefix][a:command] = "doautocmd User " . a:command
                            		endif
                            	endif
                            
                            	execute s:cache_command[a:prefix][a:command]
                            endfunction
                            
                            
    1              0.000012 let s:hooks = [
                            \	"enter",
                            \	"leave",
                            \	"char",
                            \	"char_pre",
                            \	"draw",
                            \	"draw_pre",
                            \	"execute_pre",
                            \	"execute_failed",
                            \	"execute",
                            \	"exception",
                            \]
                            
    1              0.000013 let s:hooks_camel = [
                            \	"Enter",
                            \	"Leave",
                            \	"Char",
                            \	"CharPre",
                            \	"Draw",
                            \	"DrawPre",
                            \	"ExecutePre",
                            \	"ExecuteFailed",
                            \	"Execute",
                            \	"Exception",
                            \]
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "Doautocmd",
                            \}
                            
                            
   11              0.000031 for s:i in range(len(s:hooks))
   10              0.000280 	execute join([
                            \		"function! s:module.on_" . s:hooks[s:i] . "(cmdline, ...)",
                            \		"	let s:cmdline = a:cmdline",
                            \		"	call s:doautocmd_user(self.prefix, self.prefix . " . string(s:hooks_camel[s:i]) . ")",
                            \		"endfunction",
                            \	], "\n")
   11              0.000020 endfor
                            
                            
    1              0.000005 function! s:get_cmdline()
                            	if !exists("s:cmdline")
                            		execute s:E.throw_cmd("Undefined cmdline object.", "Over.Commandline.Modules.Doautocmd")
                            	endif
                            	return s:cmdline
                            endfunction
                            
                            
    1              0.000004 function! s:make(prefix)
                            	if has_key(s:cache_command, a:prefix)
                            		unlet! s:cache_command[a:prefix]
                            	endif
                            	execute "augroup " a:prefix . "-vital-over-commandline-doautocmd-dummy"
                            		autocmd!
                            	augroup END
                            
                            	let module = deepcopy(s:module)
                            	let module.prefix = a:prefix
                            	return module
                            endfunction
                            
                            
    1   0.000084   0.000079 let &cpo = s:save_cpo
    1              0.000015 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Exception.vim
Sourced 1 time
Total time:   0.000275
 Self time:   0.000271

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000037 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Exception#import() abort
                                return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Exception#import() abort', printf("return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000021   0.000018 set cpo&vim
                            
                            
    1              0.000009 let s:vname = expand("<sfile>:h:h:t")
    1              0.000008 let s:prefix = printf("vital-over(%s) Exception", s:vname)
                            
    1              0.000005 function! s:set_prefix(prefix)
                            	let s:prefix = a:prefix
                            endfunction
                            
    1              0.000004 function! s:throw_cmd(exp, where)
                            	return 'throw ' . string(s:prefix . " : " . a:exp . " in " . a:where)
                            endfunction
                            
                            
    1              0.000003 function! s:throw(exp, where)
                            	execute s:throw_cmd(a:exp, a:where)
                            endfunction
                            
                            
    1              0.000003 function! s:error(text, where)
                            	echohl ErrorMsg
                            	echom s:prefix . " : " . a:text . " in " . a:where
                            	echohl None
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim
Sourced 1 time
Total time:   0.000287
 Self time:   0.000283

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/EasyMotion/helper.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000013 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            " }}}
                            
    1              0.000005 function! EasyMotion#helper#mode(flag) "{{{
                                return mode(a:flag) == "\<C-v>" ? "C-v" : mode(a:flag)
                            endfunction "}}}
                            
    1              0.000004 function! EasyMotion#helper#get_char_by_coord(coord) "{{{
                                " @param coord: [lnum, col] or [bufnum, lnum, col, off]
                                if len(a:coord) == 4
                                    let [line_num, col_num] = [a:coord[1], a:coord[2]]
                                else
                                    let [line_num, col_num] = a:coord
                                endif
                                let target_col_regexp = '\%' . (col_num) . 'c.'
                                return matchstr(getline(line_num), target_col_regexp)
                            endfunction "}}}
                            
    1              0.000004 function! EasyMotion#helper#is_greater_coords(coords1, coords2) "{{{
                                " [line_num, col_num] < [line_num, col_num]
                                "
                                " coords1 < coords2  : return 1
                                " coords1 > coords2  : return -1
                                " coords1 == coords2 : return 0
                                if a:coords1 == a:coords2 | return 0 | endif
                            
                                if a:coords1[0] < a:coords2[0]
                                    return 1
                                elseif a:coords1[0] > a:coords2[0]
                                    return -1
                                endif
                            
                                " Same line
                                if a:coords1[1] < a:coords2[1]
                                    return 1
                                elseif a:coords1[1] > a:coords2[1]
                                    return -1
                                endif
                            endfunction "}}}
                            
    1              0.000004 function! EasyMotion#helper#is_folded(line) "{{{
                                " Return false if g:EasyMotion_skipfoldedline == 1
                                " and line is start of folded lines
                                let _foldclosed = foldclosed(a:line)
                                return _foldclosed != -1 &&
                                    \ (g:EasyMotion_skipfoldedline == 1 || a:line != _foldclosed)
                            endfunction "}}}
    1              0.000004 function! EasyMotion#helper#should_case_sensitive(input, is_search) "{{{
                                if !a:is_search
                                    if g:EasyMotion_smartcase == 0
                                        return 0
                                    else
                                        " return 1 if input didn't match uppercase letter
                                        return match(a:input, '\u') == -1
                                    endif
                                endif
                            
                                if (g:EasyMotion_smartcase == 1 && match(a:input, '\u') == -1) ||
                                \  (&ignorecase && &smartcase && match(a:input, '\u') == -1) ||
                                \  (&ignorecase && !&smartcase)
                                    return 1
                                endif
                                return 0
                            endfunction "}}}
    1              0.000004 function! EasyMotion#helper#silent_feedkeys(expr, name, ...) "{{{
                                " Ref:
                                " https://github.com/osyo-manga/vim-over/blob/d51b028c29661d4a5f5b79438ad6d69266753711/autoload/over.vim#L6
                                let mode = get(a:, 1, "m")
                                let name = "easymotion-" . a:name
                                let map = printf("<Plug>(%s)", name)
                                if mode == "n"
                                    let command = "nnoremap"
                                else
                                    let command = "nmap"
                                endif
                                execute command "<silent>" map printf("%s:nunmap %s<CR>", a:expr, map)
                                if mode(1) !=# 'ce'
                                    " FIXME: mode(1) !=# 'ce' exists only for the test
                                    "        :h feedkeys() doesn't work while runnning a test script
                                    "        https://github.com/kana/vim-vspec/issues/27
                                    call feedkeys(printf("\<Plug>(%s)", name))
                                endif
                            endfunction "}}}
    1              0.000003 function! EasyMotion#helper#VarReset(var, ...) "{{{
                                if ! exists('s:var_reset')
                                    let s:var_reset = {}
                                endif
                            
                                if a:0 == 0 && has_key(s:var_reset, a:var)
                                    " Reset var to original value
                                    " setbufvar( or bufname): '' or '%' can be used for the current buffer
                                    call setbufvar('%', a:var, s:var_reset[a:var])
                                elseif a:0 == 1
                                    " Save original value and set new var value
                            
                                    let new_value = a:0 == 1 ? a:1 : ''
                            
                                    " Store original value
                                    let s:var_reset[a:var] = getbufvar("", a:var)
                            
                                    " Set new var value
                                    call setbufvar('%', a:var, new_value)
                                endif
                            endfunction "}}}
                            
                            " Migemo {{{
    1              0.000003 function! EasyMotion#helper#load_migemo_dict() "{{{
                                let enc = &l:encoding
                                if enc ==# 'utf-8'
                                    return EasyMotion#migemo#utf8#load_dict()
                                elseif enc ==# 'cp932'
                                    return EasyMotion#migemo#cp932#load_dict()
                                elseif enc ==# 'euc-jp'
                                    return EasyMotion#migemo#eucjp#load_dict()
                                else
                                    let g:EasyMotion_use_migemo = 0
                                    throw "Error: ".enc." is not supported. Migemo is made disabled."
                                endif
                            endfunction "}}}
                            
                            " EasyMotion#helper#strchars() {{{
    1              0.000006 if exists('*strchars')
    1              0.000003     function! EasyMotion#helper#strchars(str)
                                    return strchars(a:str)
                                endfunction
                            else
                                function! EasyMotion#helper#strchars(str)
                                    return strlen(substitute(a:str, ".", "x", "g"))
                                endfunction
    1              0.000002 endif "}}}
    1              0.000004 function! EasyMotion#helper#include_multibyte_char(str) "{{{
                                return strlen(a:str) != EasyMotion#helper#strchars(a:str)
                            endfunction "}}}
                            
    1              0.000003 function! EasyMotion#helper#vcol(expr) abort
                                let col_num = col(a:expr)
                                let line = getline(a:expr)
                                let before_line = col_num > 2 ? line[: col_num - 2]
                                \   : col_num is# 2 ? line[0]
                                \   : ''
                                let vcol_num = 1
                                for c in split(before_line, '\zs')
                                    let vcol_num += c is# "\t" ? s:_virtual_tab2spacelen(vcol_num) : len(c)
                                endfor
                                return vcol_num
                            endfunction
                            
    1              0.000005 function! s:_virtual_tab2spacelen(col_num) abort
                                return &tabstop - ((a:col_num - 1) % &tabstop)
                            endfunction
                            
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000016   0.000014 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/EasyMotion/undo.vim
Sourced 1 time
Total time:   0.005645
 Self time:   0.000141

count  total (s)   self (s)
    1   0.005526   0.000022 let s:Buffer = vital#easymotion#import('Vim.Buffer')
                            
    1              0.000005 function! EasyMotion#undo#save() abort
                              return s:undo_lock.save()
                            endfunction
                            
    1              0.000004 let s:undo_lock = {}
                            
    1              0.000004 function! s:undo_lock.save() abort
                              let undo = deepcopy(self)
                              call undo._save()
                              return undo
                            endfunction
                            
    1              0.000003 function! s:undo_lock._save() abort
                              if undotree().seq_last == 0
                                " if there are no undo history, disable undo feature by setting
                                " 'undolevels' to -1 and restore it.
                                let self.save_undolevels = &l:undolevels
                                let &l:undolevels = -1
                              elseif !s:Buffer.is_cmdwin()
                                " command line window doesn't support :wundo.
                                let self.undofile = tempname()
                                execute 'wundo!' self.undofile
                              else
                                let self.is_cmdwin = s:TRUE
                              endif
                            endfunction
                            
    1              0.000004 function! s:undo_lock.restore() abort
                              if has_key(self, 'save_undolevels')
                                let &l:undolevels = self.save_undolevels
                              endif
                              if has_key(self, 'undofile') && filereadable(self.undofile)
                                silent execute 'rundo' self.undofile
                                call delete(self.undofile)
                              endif
                              if has_key(self, 'is_cmdwin')
                                " XXX: it breaks undo history. AFAIK, there are no way to save and restore
                                " undo history in commandline window.
                                call self.undobreak()
                              endif
                            endfunction
                            
    1              0.000005 function! s:undo_lock.undobreak() abort
                              let old_undolevels = &l:undolevels
                              setlocal undolevels=-1
                              keepjumps call setline('.', getline('.'))
                              let &l:undolevels = old_undolevels
                            endfunction

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Buffer.vim
Sourced 1 time
Total time:   0.000361
 Self time:   0.000356

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000024 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000039   function! vital#_easymotion#Vim#Buffer#import() abort
                                return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Vim#Buffer#import() abort', printf("return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000028 let s:save_cpo = &cpo
    1   0.000021   0.000018 set cpo&vim
                            
    1              0.000004 function! s:_vital_loaded(V) abort
                              let s:V = a:V
                              let s:P = s:V.import('Prelude')
                              let s:G = s:V.import('Vim.Guard')
                            endfunction
                            
    1              0.000003 function! s:_vital_depends() abort
                              return ['Prelude', 'Vim.Guard']
                            endfunction
                            
    1              0.000006 if exists('*getcmdwintype')
    1              0.000003   function! s:is_cmdwin() abort
                                return getcmdwintype() !=# ''
                              endfunction
                            else
                              function! s:is_cmdwin() abort
                                return bufname('%') ==# '[Command Line]'
                              endfunction
    1              0.000002 endif
                            
    1              0.000004 function! s:open(buffer, opener) abort
                              let save_wildignore = &wildignore
                              let &wildignore = ''
                              try
                                if s:P.is_funcref(a:opener)
                                  let loaded = !bufloaded(a:buffer)
                                  call a:opener(a:buffer)
                                elseif a:buffer is 0 || a:buffer is# ''
                                  let loaded = 1
                                  silent execute a:opener
                                  enew
                                else
                                  let loaded = !bufloaded(a:buffer)
                                  if s:P.is_string(a:buffer)
                                    execute a:opener '`=a:buffer`'
                                  elseif s:P.is_number(a:buffer)
                                    silent execute a:opener
                                    execute a:buffer 'buffer'
                                  else
                                    throw 'vital: Vim.Buffer: Unknown opener type.'
                                  endif
                                endif
                              finally
                                let &wildignore = save_wildignore
                              endtry
                              return loaded
                            endfunction
                            
    1              0.000004 function! s:get_selected_text(...) abort
                              echohl WarningMsg
                              echom "[WARN] s:get_selected_text() is deprecated. Use 's:get_last_selected()'."
                              echohl None
                              return call('s:get_last_selected', a:000)
                            endfunction
                            
                            " Get the last selected text in visual mode
                            " without using |gv| to avoid |textlock|.
                            " NOTE:
                            " * This function uses |gv| only when using |CTRL-V|
                            "   because |gv| is the only way to get selected text
                            "   when using <C-v>$ .
                            "   Please see #192 for the details.
                            " * If you don't care about |textlock|,
                            "   you can use simple version of this function.
                            "   https://github.com/vim-jp/vital.vim/commit/39aae80f3839fdbeebd838ff14d87327a6b889a9
    1              0.000004 function! s:get_last_selected() abort
                              if visualmode() ==# "\<C-v>"
                                let save = getreg('"', 1)
                                let save_type = getregtype('"')
                                try
                                  normal! gv""y
                                  return @"
                                finally
                                  call setreg('"', save, save_type)
                                endtry
                              else
                                let [begin, end] = [getpos("'<"), getpos("'>")]
                                let lastchar = matchstr(getline(end[1])[end[2]-1 :], '.')
                                if begin[1] ==# end[1]
                                  let lines = [getline(begin[1])[begin[2]-1 : end[2]-2]]
                                else
                                  let lines = [getline(begin[1])[begin[2]-1 :]]
                                  \         + (end[1] - begin[1] <# 2 ? [] : getline(begin[1]+1, end[1]-1))
                                  \         + [getline(end[1])[: end[2]-2]]
                                endif
                                return join(lines, "\n") . lastchar . (visualmode() ==# 'V' ? "\n" : '')
                              endif
                            endfunction
                            
    1              0.000004 function! s:read_content(content, ...) abort
                              let options = extend({
                                    \ 'tempfile': '',
                                    \ 'fileformat': '',
                                    \ 'encoding': '',
                                    \ 'binary': 0,
                                    \ 'nobinary': 0,
                                    \ 'bad': '',
                                    \ 'edit': 0,
                                    \ 'line': '',
                                    \}, get(a:000, 0, {}))
                              let tempfile = empty(options.tempfile) ? tempname() : options.tempfile
                              let optnames = [
                                    \ empty(options.fileformat) ? '' : '++ff=' . options.fileformat,
                                    \ empty(options.encoding) ? '' : '++enc=' . options.encoding,
                                    \ empty(options.binary) ? '' : '++bin',
                                    \ empty(options.nobinary) ? '' : '++nobin',
                                    \ empty(options.bad) ? '' : '++bad=' . options.bad,
                                    \ empty(options.edit) ? '' : '++edit',
                                    \]
                              let optname = join(filter(optnames, '!empty(v:val)'))
                              try
                                call writefile(a:content, tempfile)
                                execute printf('keepalt keepjumps %sread %s%s',
                                      \ options.line,
                                      \ empty(optname) ? '' : optname . ' ',
                                      \ fnameescape(tempfile),
                                      \)
                              finally
                                call delete(tempfile)
                                execute 'bwipeout!' tempfile
                              endtry
                            endfunction
                            
    1              0.000004 function! s:edit_content(content, ...) abort
                              let options = extend({
                                    \ 'edit': 1,
                                    \}, get(a:000, 0, {}))
                              let guard = s:G.store(['&l:modifiable'])
                              let saved_view = winsaveview()
                              try
                                let &l:modifiable=1
                                silent keepjumps %delete _
                                silent call s:read_content(a:content, options)
                                silent keepjumps 1delete _
                              finally
                                keepjump call winrestview(saved_view)
                                call guard.restore()
                              endtry
                              setlocal nomodified
                            endfunction
                            
    1              0.000004 function! s:parse_cmdarg(...) abort
                              let cmdarg = get(a:000, 0, v:cmdarg)
                              let options = {}
                              if cmdarg =~# '++enc='
                                let options.encoding = matchstr(cmdarg, '++enc=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++ff='
                                let options.fileformat = matchstr(cmdarg, '++ff=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++bad='
                                let options.bad = matchstr(cmdarg, '++bad=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++bin'
                                let options.binary = 1
                              endif
                              if cmdarg =~# '++nobin'
                                let options.nobinary = 1
                              endif
                              if cmdarg =~# '++edit'
                                let options.edit = 1
                              endif
                              return options
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Prelude.vim
Sourced 1 time
Total time:   0.000774
 Self time:   0.000770

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000023 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Prelude#import() abort
                                return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Prelude#import() abort', printf("return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000015 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            
    1              0.000006 if v:version > 703 ||
                            \  (v:version == 703 && has('patch465'))
    1              0.000003   function! s:glob(expr) abort
                                return glob(a:expr, 1, 1)
                              endfunction
                            else
                              function! s:glob(expr) abort
                                return split(glob(a:expr, 1), '\n')
                              endfunction
    1              0.000001 endif
                            
    1              0.000005 if v:version > 704 ||
                            \  (v:version == 704 && has('patch279'))
    1              0.000003   function! s:globpath(path, expr) abort
                                return globpath(a:path, a:expr, 1, 1)
                              endfunction
                            else
                              function! s:globpath(path, expr) abort
                                return split(globpath(a:path, a:expr, 1), '\n')
                              endfunction
    1              0.000001 endif
                            
                            " Wrapper functions for type().
                            " NOTE: __TYPE_FLOAT = -1 when -float.
                            " this doesn't match to anything.
    1              0.000008 if has('patch-7.4.2071')
    1              0.000022   let [
                              \   s:__TYPE_NUMBER,
                              \   s:__TYPE_STRING,
                              \   s:__TYPE_FUNCREF,
                              \   s:__TYPE_LIST,
                              \   s:__TYPE_DICT,
                              \   s:__TYPE_FLOAT] = [
                                    \   v:t_number,
                                    \   v:t_string,
                                    \   v:t_func,
                                    \   v:t_list,
                                    \   v:t_dict,
                                    \   v:t_float]
                            else
                              let [
                              \   s:__TYPE_NUMBER,
                              \   s:__TYPE_STRING,
                              \   s:__TYPE_FUNCREF,
                              \   s:__TYPE_LIST,
                              \   s:__TYPE_DICT,
                              \   s:__TYPE_FLOAT] = [
                                    \   type(3),
                                    \   type(''),
                                    \   type(function('tr')),
                                    \   type([]),
                                    \   type({}),
                                    \   has('float') ? type(str2float('0')) : -1]
    1              0.000002 endif
                            
                            " Number or Float
    1              0.000004 function! s:is_numeric(Value) abort
                              let _ = type(a:Value)
                              return _ ==# s:__TYPE_NUMBER
                              \   || _ ==# s:__TYPE_FLOAT
                            endfunction
                            
                            " Number
    1              0.000004 function! s:is_number(Value) abort
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
                            
                            " String
    1              0.000004 function! s:is_string(Value) abort
                              return type(a:Value) ==# s:__TYPE_STRING
                            endfunction
                            
                            " Funcref
    1              0.000003 function! s:is_funcref(Value) abort
                              return type(a:Value) ==# s:__TYPE_FUNCREF
                            endfunction
                            
                            " List
    1              0.000003 function! s:is_list(Value) abort
                              return type(a:Value) ==# s:__TYPE_LIST
                            endfunction
                            
                            " Dictionary
    1              0.000003 function! s:is_dict(Value) abort
                              return type(a:Value) ==# s:__TYPE_DICT
                            endfunction
                            
                            " Float
    1              0.000003 function! s:is_float(Value) abort
                              return type(a:Value) ==# s:__TYPE_FLOAT
                            endfunction
                            
                            
    1              0.000006 function! s:truncate_skipping(str, max, footer_width, separator) abort
                              call s:_warn_deprecated('truncate_skipping', 'Data.String.truncate_skipping')
                            
                              let width = s:wcswidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - s:wcswidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator
                                      \ . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                            
                              return s:truncate(ret, a:max)
                            endfunction
                            
    1              0.000003 function! s:truncate(str, width) abort
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              call s:_warn_deprecated('truncate', 'Data.String.truncate')
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ?
                                      \ printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000004 function! s:strwidthpart(str, width) abort
                              call s:_warn_deprecated('strwidthpart', 'Data.String.strwidthpart')
                            
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
    1              0.000004 function! s:strwidthpart_reverse(str, width) abort
                              call s:_warn_deprecated('strwidthpart_reverse', 'Data.String.strwidthpart_reverse')
                            
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '^.')
                                let ret = ret[len(char) :]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
                            
    1              0.000003 if v:version >= 703
                              " Use builtin function.
    1              0.000004   function! s:wcswidth(str) abort
                                call s:_warn_deprecated('wcswidth', 'Data.String.wcswidth')
                                return strwidth(a:str)
                              endfunction
                            else
                              function! s:wcswidth(str) abort
                                call s:_warn_deprecated('wcswidth', 'Data.String.wcswidth')
                            
                                if a:str =~# '^[\x00-\x7f]*$'
                                  return strlen(a:str)
                                end
                            
                                let mx_first = '^\(.\)'
                                let str = a:str
                                let width = 0
                                while 1
                                  let ucs = char2nr(substitute(str, mx_first, '\1', ''))
                                  if ucs == 0
                                    break
                                  endif
                                  let width += s:_wcwidth(ucs)
                                  let str = substitute(str, mx_first, '', '')
                                endwhile
                                return width
                              endfunction
                            
                              " UTF-8 only.
                              function! s:_wcwidth(ucs) abort
                                let ucs = a:ucs
                                if (ucs >= 0x1100
                                      \  && (ucs <= 0x115f
                                      \  || ucs == 0x2329
                                      \  || ucs == 0x232a
                                      \  || (ucs >= 0x2e80 && ucs <= 0xa4cf
                                      \      && ucs != 0x303f)
                                      \  || (ucs >= 0xac00 && ucs <= 0xd7a3)
                                      \  || (ucs >= 0xf900 && ucs <= 0xfaff)
                                      \  || (ucs >= 0xfe30 && ucs <= 0xfe6f)
                                      \  || (ucs >= 0xff00 && ucs <= 0xff60)
                                      \  || (ucs >= 0xffe0 && ucs <= 0xffe6)
                                      \  || (ucs >= 0x20000 && ucs <= 0x2fffd)
                                      \  || (ucs >= 0x30000 && ucs <= 0x3fffd)
                                      \  ))
                                  return 2
                                endif
                                return 1
                              endfunction
    1              0.000001 endif
                            
    1              0.000020 let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')
    1              0.000007 let s:is_cygwin = has('win32unix')
    1              0.000026 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
    1              0.000004 let s:is_unix = has('unix')
                            
    1              0.000003 function! s:is_windows() abort
                              return s:is_windows
                            endfunction
                            
    1              0.000003 function! s:is_cygwin() abort
                              return s:is_cygwin
                            endfunction
                            
    1              0.000002 function! s:is_mac() abort
                              return s:is_mac
                            endfunction
                            
    1              0.000003 function! s:is_unix() abort
                              return s:is_unix
                            endfunction
                            
    1              0.000005 function! s:_warn_deprecated(name, alternative) abort
                              try
                                echohl Error
                                echomsg 'Prelude.' . a:name . ' is deprecated!  Please use ' . a:alternative . ' instead.'
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000005 function! s:smart_execute_command(action, word) abort
                              execute a:action . ' ' . (a:word ==# '' ? '' : '`=a:word`')
                            endfunction
                            
    1              0.000017 function! s:escape_file_searching(buffer_name) abort
                              return escape(a:buffer_name, '*[]?{}, ')
                            endfunction
                            
    1              0.000003 function! s:escape_pattern(str) abort
                              call s:_warn_deprecated(
                                    \ 'escape_pattern',
                                    \ 'Data.String.escape_pattern',
                                    \)
                              return escape(a:str, '~"\.^$[]*')
                            endfunction
                            
    1              0.000003 function! s:getchar(...) abort
                              let c = call('getchar', a:000)
                              return type(c) == type(0) ? nr2char(c) : c
                            endfunction
                            
    1              0.000003 function! s:getchar_safe(...) abort
                              let c = s:input_helper('getchar', a:000)
                              return type(c) == type('') ? c : nr2char(c)
                            endfunction
                            
    1              0.000003 function! s:input_safe(...) abort
                              return s:input_helper('input', a:000)
                            endfunction
                            
    1              0.000004 function! s:input_helper(funcname, args) abort
                              let success = 0
                              if inputsave() !=# success
                                throw 'vital: Prelude: inputsave() failed'
                              endif
                              try
                                return call(a:funcname, a:args)
                              finally
                                if inputrestore() !=# success
                                  throw 'vital: Prelude: inputrestore() failed'
                                endif
                              endtry
                            endfunction
                            
    1              0.000003 function! s:set_default(var, val) abort
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let {a:var} = a:val
                              endif
                            endfunction
                            
    1              0.000005 function! s:substitute_path_separator(path) abort
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction
                            
    1              0.000003 function! s:path2directory(path) abort
                              return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))
                            endfunction
                            
    1              0.000005 function! s:_path2project_directory_git(path) abort
                              let parent = a:path
                            
                              while 1
                                let path = parent . '/.git'
                                if isdirectory(path) || filereadable(path)
                                  return parent
                                endif
                                let next = fnamemodify(parent, ':h')
                                if next == parent
                                  return ''
                                endif
                                let parent = next
                              endwhile
                            endfunction
                            
    1              0.000005 function! s:_path2project_directory_svn(path) abort
                              let search_directory = a:path
                              let directory = ''
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir('.svn', find_directory . ';')
                              if d ==# ''
                                return ''
                              endif
                            
                              let directory = fnamemodify(d, ':p:h:h')
                            
                              " Search parent directories.
                              let parent_directory = s:path2directory(
                                    \ fnamemodify(directory, ':h'))
                            
                              if parent_directory !=# ''
                                let d = finddir('.svn', parent_directory . ';')
                                if d !=# ''
                                  let directory = s:_path2project_directory_svn(parent_directory)
                                endif
                              endif
                              return directory
                            endfunction
                            
    1              0.000005 function! s:_path2project_directory_others(vcs, path) abort
                              let vcs = a:vcs
                              let search_directory = a:path
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir(vcs, find_directory . ';')
                              if d ==# ''
                                return ''
                              endif
                              return fnamemodify(d, ':p:h:h')
                            endfunction
                            
    1              0.000005 function! s:path2project_directory(path, ...) abort
                              let is_allow_empty = get(a:000, 0, 0)
                              let search_directory = s:path2directory(a:path)
                              let directory = ''
                            
                              " Search VCS directory.
                              for vcs in ['.git', '.bzr', '.hg', '.svn']
                                if vcs ==# '.git'
                                  let directory = s:_path2project_directory_git(search_directory)
                                elseif vcs ==# '.svn'
                                  let directory = s:_path2project_directory_svn(search_directory)
                                else
                                  let directory = s:_path2project_directory_others(vcs, search_directory)
                                endif
                                if directory !=# ''
                                  break
                                endif
                              endfor
                            
                              " Search project file.
                              if directory ==# ''
                                for d in ['build.xml', 'prj.el', '.project', 'pom.xml', 'package.json',
                                      \ 'Makefile', 'configure', 'Rakefile', 'NAnt.build',
                                      \ 'P4CONFIG', 'tags', 'gtags']
                                  let d = findfile(d, s:escape_file_searching(search_directory) . ';')
                                  if d !=# ''
                                    let directory = fnamemodify(d, ':p:h')
                                    break
                                  endif
                                endfor
                              endif
                            
                              if directory ==# ''
                                " Search /src/ directory.
                                let base = s:substitute_path_separator(search_directory)
                                if base =~# '/src/'
                                  let directory = base[: strridx(base, '/src/') + 3]
                                endif
                              endif
                            
                              if directory ==# '' && !is_allow_empty
                                " Use original path.
                                let directory = search_directory
                              endif
                            
                              return s:substitute_path_separator(directory)
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Guard.vim
Sourced 1 time
Total time:   0.000536
 Self time:   0.000531

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Vim#Guard#import() abort
                                return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Vim#Guard#import() abort', printf("return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            " Use a Funcref as a special term _UNDEFINED
    1              0.000004 function! s:_undefined() abort
                              return 'undefined'
                            endfunction
    1              0.000009 let s:_UNDEFINED = function('s:_undefined')
                            
    1              0.000003 function! s:_vital_loaded(V) abort
                              let s:V = a:V
                              let s:Prelude = s:V.import('Prelude')
                              let s:List = s:V.import('Data.List')
                              let s:Dict = s:V.import('Data.Dict')
                            endfunction
    1              0.000004 function! s:_vital_depends() abort
                              return ['Prelude', 'Data.List', 'Data.Dict']
                            endfunction
    1              0.000003 function! s:_vital_created(module) abort
                              " define constant variables
                              if !exists('s:const')
                                let s:const = {}
                                let s:const.is_local_variable_supported =
                                    \ v:version > 703 || (v:version == 703 && has('patch560'))
                                " NOTE:
                                " The third argument is available from 7.4.242 but it had bug and that
                                " bug was fixed from 7.4.513
                                let s:const.is_third_argument_of_getreg_supported = has('patch-7.4.513')
                                lockvar s:const
                              endif
                              call extend(a:module, s:const)
                            endfunction
    1              0.000003 function! s:_throw(msg) abort
                              throw printf('vital: Vim.Guard: %s', a:msg)
                            endfunction
                            
    1              0.000003 let s:option = {}
    1              0.000004 function! s:_new_option(name) abort
                              if a:name !~# '^&'
                                call s:_throw(printf(
                                      \'An option name "%s" requires to be started from "&"', a:name
                                      \))
                              elseif !exists(a:name)
                                call s:_throw(printf(
                                      \'An option name "%s" does not exist', a:name
                                      \))
                              endif
                              let option = copy(s:option)
                              let option.name = a:name
                              let option.value = eval(a:name)
                              return option
                            endfunction
    1              0.000003 function! s:option.restore() abort
                              execute printf('let %s = %s', self.name, string(self.value))
                            endfunction
                            
    1              0.000003 let s:register = {}
    1              0.000004 function! s:_new_register(name) abort
                              if len(a:name) != 2
                                call s:_throw(printf(
                                      \'A register name "%s" requires to be "@" + a single character', a:name
                                      \))
                              elseif a:name !~# '^@'
                                call s:_throw(printf(
                                      \'A register name "%s" requires to be started from "@"', a:name
                                      \))
                              elseif a:name =~# '^@[:.%]$'
                                call s:_throw(printf(
                                      \'A register name "%s" is read only', a:name
                                      \))
                              elseif a:name !~# '^@[@0-9a-zA-Z#=*+~_/-]$'
                                call s:_throw(printf(
                                      \'A register name "%s" does not exist. See ":help let-register"', a:name
                                      \))
                              endif
                              let name = a:name ==# '@@' ? '' : a:name[1]
                              let register = copy(s:register)
                              let register.name = name
                              if s:const.is_third_argument_of_getreg_supported
                                let register.value = getreg(name, 1, 1)
                              else
                                let register.value = getreg(name, 1)
                              endif
                              let register.type = getregtype(name)
                              return register
                            endfunction
    1              0.000003 function! s:register.restore() abort
                              " https://github.com/vim/vim/commit/5a50c2255c447838d08d3b4895a3be3a41cd8eda
                              if has('patch-7.4.243') || self.name !=# '='
                                call setreg(self.name, self.value, self.type)
                              else
                                let @= = self.value
                              endif
                            endfunction
                            
    1              0.000004 let s:environment = {}
    1              0.000004 function! s:_new_environment(name) abort
                              if a:name !~# '^\$'
                                call s:_throw(printf(
                                      \'An environment variable name "%s" requires to be started from "$"', a:name
                                      \))
                              elseif !exists(a:name)
                                call s:_throw(printf(
                                      \'An environment variable name "%s" does not exist. While Vim cannot unlet environment variable, it requires to exist', a:name
                                      \))
                              endif
                              let environment = copy(s:environment)
                              let environment.name = a:name
                              let environment.value = eval(a:name)
                              return environment
                            endfunction
    1              0.000003 function! s:environment.restore() abort
                              execute printf('let %s = %s', self.name, string(self.value))
                            endfunction
                            
    1              0.000021 let s:variable = {}
    1              0.000048 function! s:_new_variable(name, ...) abort
                              if a:0 == 0
                                let m = matchlist(a:name, '^\([bwtg]:\)\(.*\)$')
                                if empty(m)
                                  call s:_throw(printf(
                                        \ join([
                                        \   'An variable name "%s" requires to start from b:, w:, t:, or g:',
                                        \   'while no {namespace} is specified',
                                        \ ]),
                                        \ a:name,
                                        \))
                                endif
                                let [prefix, name] = m[1 : 2]
                                let namespace = eval(prefix)
                              else
                                let name = a:name
                                let namespace = a:1
                              endif
                              let variable = copy(s:variable)
                              let variable.name = name
                              let variable.value = get(namespace, name, s:_UNDEFINED)
                              let variable.value =
                                    \ type(variable.value) == type({}) || type(variable.value) == type([])
                                    \   ? deepcopy(variable.value)
                                    \   : variable.value
                              let variable._namespace = namespace
                              return variable
                            endfunction
    1              0.000044 function! s:variable.restore() abort
                              " unlet the variable to prevent variable type mis-match in case
                              silent! unlet! self._namespace[self.name]
                              if type(self.value) == type(s:_UNDEFINED) && self.value == s:_UNDEFINED
                                " do nothing, leave the variable as undefined
                              else
                                let self._namespace[self.name] = self.value
                              endif
                            endfunction
                            
    1              0.000005 let s:instance = {}
    1              0.000006 function! s:_new_instance(instance, ...) abort
                              let shallow = get(a:000, 0, 0)
                              if !s:Prelude.is_list(a:instance) && !s:Prelude.is_dict(a:instance)
                                call s:_throw(printf(
                                      \'An instance "%s" requires to be List or Dictionary', string(a:instance)
                                      \))
                              endif
                              let instance = copy(s:instance)
                              let instance.instance = a:instance
                              let instance.values = shallow ? copy(a:instance) : deepcopy(a:instance)
                              return instance
                            endfunction
    1              0.000004 function! s:instance.restore() abort
                              if s:Prelude.is_list(self.instance)
                                call s:List.clear(self.instance)
                              else
                                call s:Dict.clear(self.instance)
                              endif
                              call extend(self.instance, self.values)
                            endfunction
                            
    1              0.000005 let s:guard = {}
    1              0.000004 function! s:store(targets) abort
                              let resources = []
                              for meta in a:targets
                                if s:Prelude.is_list(meta)
                                  if len(meta) == 1
                                    call add(resources, s:_new_instance(meta[0]))
                                  elseif len(meta) == 2
                                    if s:Prelude.is_string(meta[0])
                                      call add(resources, call('s:_new_variable', meta))
                                    else
                                      call add(resources, call('s:_new_instance', meta))
                                    endif
                                  else
                                    call s:_throw('List assignment requires one or two elements')
                                  endif
                                elseif type(meta) == type('')
                                  if meta =~# '^[bwtgls]:'
                                    " Note:
                                    " To improve an error message, handle l:XXX or s:XXX as well
                                    call add(resources, s:_new_variable(meta))
                                  elseif meta =~# '^&'
                                    call add(resources, s:_new_option(meta))
                                  elseif meta =~# '^@'
                                    call add(resources, s:_new_register(meta))
                                  elseif meta =~# '^\$'
                                    call add(resources, s:_new_environment(meta))
                                  else
                                    call s:_throw(printf(
                                          \ 'Unknown value "%s" was specified',
                                          \ meta
                                          \))
                                  endif
                                endif
                                unlet meta
                              endfor
                              let guard = copy(s:guard)
                              let guard._resources = resources
                              return guard
                            endfunction
    1              0.000004 function! s:guard.restore() abort
                              for resource in self._resources
                                call resource.restore()
                              endfor
                            endfunction
                            
    1   0.000025   0.000022 let &cpo = s:save_cpo
    1              0.000005 unlet! s:save_cpo
                            " vim:set et ts=2 sts=2 sw=2 tw=0 fdm=marker:

SCRIPT  /home/kc/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/Dict.vim
Sourced 1 time
Total time:   0.000283
 Self time:   0.000279

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000011 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Data#Dict#import() abort
                                return map({'pick': '', 'clear': '', 'max_by': '', 'foldl': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Data#Dict#import() abort', printf("return map({'pick': '', 'clear': '', 'max_by': '', 'foldl': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
                            " Utilities for dictionary.
                            
    1              0.000014 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            
                            " Makes a dict from keys and values
    1              0.000004 function! s:make(keys, values, ...) abort
                              let dict = {}
                              let fill = a:0 ? a:1 : 0
                              for i in range(len(a:keys))
                                let key = type(a:keys[i]) == type('') ? a:keys[i] : string(a:keys[i])
                                if key ==# ''
                                  throw "vital: Data.Dict: Can't use an empty string for key."
                                endif
                                let dict[key] = get(a:values, i, fill)
                              endfor
                              return dict
                            endfunction
                            
                            " Swaps keys and values
    1              0.000003 function! s:swap(dict) abort
                              return s:make(values(a:dict), keys(a:dict))
                            endfunction
                            
                            " Makes a index dict from a list
    1              0.000003 function! s:make_index(list, ...) abort
                              let value = a:0 ? a:1 : 1
                              return s:make(a:list, [], value)
                            endfunction
                            
    1              0.000003 function! s:pick(dict, keys) abort
                              let new_dict = {}
                              for key in a:keys
                                if has_key(a:dict, key)
                                  let new_dict[key] = a:dict[key]
                                endif
                              endfor
                              return new_dict
                            endfunction
                            
    1              0.000003 function! s:omit(dict, keys) abort
                              let new_dict = copy(a:dict)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  call remove(new_dict, key)
                                endif
                              endfor
                              return new_dict
                            endfunction
                            
    1              0.000003 function! s:clear(dict) abort
                              for key in keys(a:dict)
                                call remove(a:dict, key)
                              endfor
                              return a:dict
                            endfunction
                            
    1              0.000004 function! s:_max_by(dict, expr) abort
                              let dict = s:swap(map(copy(a:dict), a:expr))
                              let key = dict[max(keys(dict))]
                              return [key, a:dict[key]]
                            endfunction
                            
    1              0.000023 function! s:max_by(dict, expr) abort
                              if empty(a:dict)
                                throw 'vital: Data.Dict: Empty dictionary'
                              endif
                              return s:_max_by(a:dict, a:expr)
                            endfunction
                            
    1              0.000004 function! s:min_by(dict, expr) abort
                              if empty(a:dict)
                                throw 'vital: Data.Dict: Empty dictionary'
                              endif
                              return s:_max_by(a:dict, '-(' . a:expr . ')')
                            endfunction
                            
    1              0.000003 function! s:_foldl(f, init, xs) abort
                              let memo = a:init
                              for [k, v] in a:xs
                                let expr = substitute(a:f, 'v:key', string(k), 'g')
                                let expr = substitute(expr, 'v:val', string(v), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
    1              0.000004 function! s:foldl(f, init, dict) abort
                              return s:_foldl(a:f, a:init, items(a:dict))
                            endfunction
                            
    1              0.000018 function! s:foldr(f, init, dict) abort
                              return s:_foldl(a:f, a:init, reverse(items(a:dict)))
                            endfunction
                            
    1   0.000030   0.000028 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch.vim
Sourced 1 time
Total time:   0.002422
 Self time:   0.001566

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "
                            " vimlint:
                            " @vimlint(EVL103, 1, a:cmdline)
                            " @vimlint(EVL102, 1, v:errmsg)
                            " @vimlint(EVL102, 1, v:warningmsg)
                            " @vimlint(EVL102, 1, v:searchforward)
                            "=============================================================================
    1              0.000008 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000017 let s:save_cpo = &cpo
    1   0.000026   0.000022 set cpo&vim
                            " }}}
                            
    1              0.000003 let s:TRUE = !0
    1              0.000003 let s:FALSE = 0
    1              0.000007 let s:DIRECTION = { 'forward': 1, 'backward': 0 } " see :h v:searchforward
                            
                            " based on: https://github.com/deris/vim-magicalize/blob/433e38c1e83b1bdea4f83ab99dc19d070932380c/autoload/magicalize.vim#L52-L53
                            " improve to work with repetitive espaced slash like \V\V
                            " NOTE: \@1<= doesn't work to detect \v\v\v\v
    1              0.000005 let s:escaped_backslash     = '\m\%(^\|[^\\]\)\%(\\\\\)*'
    1              0.000006 let s:non_escaped_backslash = '\m\%(\%(^\|[^\\]\)\%(\\\\\)*\)\@<=\\'
                            
                            " Option:
    1              0.000009 let g:incsearch#emacs_like_keymap      = get(g: , 'incsearch#emacs_like_keymap'      , s:FALSE)
    1              0.000006 let g:incsearch#highlight              = get(g: , 'incsearch#highlight'              , {})
    1              0.000008 let g:incsearch#separate_highlight     = get(g: , 'incsearch#separate_highlight'     , s:FALSE)
    1              0.000008 let g:incsearch#consistent_n_direction = get(g: , 'incsearch#consistent_n_direction' , s:FALSE)
    1              0.000007 let g:incsearch#vim_cmdline_keymap     = get(g: , 'incsearch#vim_cmdline_keymap'     , s:TRUE)
    1              0.000008 let g:incsearch#smart_backward_word    = get(g: , 'incsearch#smart_backward_word'    , s:TRUE)
    1              0.000007 let g:incsearch#no_inc_hlsearch        = get(g: , 'incsearch#no_inc_hlsearch'        , s:FALSE)
                            " This changes error and warning emulation way slightly
    1              0.000009 let g:incsearch#do_not_save_error_message_history =
                            \   get(g:, 'incsearch#do_not_save_error_message_history', s:FALSE)
    1              0.000006 let g:incsearch#auto_nohlsearch = get(g: , 'incsearch#auto_nohlsearch' , s:FALSE)
                            " assert g:incsearch#magic =~# \\[mMvV]
    1              0.000005 let g:incsearch#magic           = get(g: , 'incsearch#magic'           , '')
                            
                            " Debug:
    1              0.000005 let g:incsearch#debug = get(g:, 'incsearch#debug', s:FALSE)
                            
                            " Utility:
    1   0.001074   0.000226 let s:U = incsearch#util#import()
                            
                            " Main: {{{
                            
                            " @return vital-over command-line interface object. [experimental]
    1              0.000004 function! incsearch#cli() abort
                              return incsearch#cli#get()
                            endfunction
                            
                            "" Make vital-over command-line interface object and return it [experimental]
    1              0.000005 function! incsearch#make(...) abort
                              return incsearch#cli#make(incsearch#config#make(get(a:, 1, {})))
                            endfunction
                            
                            "" NOTE: this global variable is only for handling config from go_wrap func
                            " It avoids to make config string temporarily
    1              0.000004 let g:incsearch#_go_config = {}
                            
                            "" This is main API assuming used by <expr> mappings
                            " ARGS:
                            "   @config See autoload/incsearch/config.vim
                            " RETURN:
                            "   Return primitive search commands (like `3/pattern<CR>`) if config.is_expr
                            "   is TRUE, return excute command to call incsearch.vim's inner API.
                            "   To handle dot repeat, make sure that config.is_expr is true. If you do not
                            "   specify config.is_expr, it automatically set config.is_expr TRUE for
                            "   operator-pending mode
                            " USAGE:
                            "   :noremap <silent><expr> <Plug>(incsearch-forward)  incsearch#go({'command': '/'})
                            "   " FIXME?: Calling this with feedkeys() is ugly... Reason: incsearch#go()
                            "   is optimize the situation which calling from <expr> mappings, and do not
                            "   take care from calling directly or some defined command.
                            "   :call feedkeys(incsearch#go(), 'n')
                            " @api
    1              0.000004 function! incsearch#go(...) abort
                              let config = incsearch#config#make(get(a:, 1, {}))
                              " FIXME?: this condition should not be config.is_expr?
                              if config.is_expr
                                return incsearch#_go(config)
                              else
                                let g:incsearch#_go_config = config
                                let esc = s:U.is_visual(g:incsearch#_go_config.mode) ? "\<ESC>" : ''
                                return printf("%s:\<C-u>call incsearch#_go(g:incsearch#_go_config)\<CR>", esc)
                              endif
                            endfunction
                            
                            "" Debuggin incsearch.vim interface for calling from function call
                            " USAGE:
                            "   :call incsearch#call({'pattern': @/})
                            " @api for debugging
    1              0.000004 function! incsearch#call(...) abort
                              return incsearch#_go(incsearch#config#make(get(a:, 1, {})))
                            endfunction
                            
                            " IMPORTANT NOTE:
                            "   Calling `incsearch#go()` and executing command which returned from
                            "   `incsearch#go()` have to result in the same cursor move.
                            " @return command: String to search
    1              0.000004 function! incsearch#_go(config) abort
                              if s:U.is_visual(a:config.mode) && !a:config.is_expr
                                normal! gv
                              endif
                              let cli = incsearch#cli#make(a:config)
                              let input = s:get_input(cli)
                              if cli._does_exit_from_incsearch
                                " Outer incsearch-plugin handle it so do not something in paticular
                                return cli._return_cmd
                              else
                                " After getting input, generate command, take aftercare, and return
                                " command.
                                let l:F = function(cli._flag is# 'n' ? 's:stay' : 's:search')
                                let cmd = l:F(cli, input)
                                if !a:config.is_expr
                                  let should_set_jumplist = (cli._flag !=# 'n')
                                  call s:set_search_related_stuff(cli, cmd, should_set_jumplist)
                                  if a:config.mode is# 'no'
                                    call s:set_vimrepeat(cmd)
                                  endif
                                endif
                                return cmd
                              endif
                            endfunction
                            
                            "" To handle recursive mapping, map command to <Plug>(_incsearch-dotrepeat)
                            " temporarily
                            " https://github.com/tpope/vim-repeat
                            " https://github.com/kana/vim-repeat
    1              0.000004 function! s:set_vimrepeat(cmd) abort
                              execute 'noremap' '<Plug>(_incsearch-dotrepeat)' a:cmd
                              silent! call repeat#set("\<Plug>(_incsearch-dotrepeat)")
                            endfunction
                            
    1              0.000008 let g:incsearch#_view = get(g:, 'incsearch#_view', {})
    1              0.000044 noremap  <silent> <Plug>(_incsearch-winrestview) <Nop>
    1              0.000017 noremap! <silent> <Plug>(_incsearch-winrestview) <Nop>
    1              0.000028 nnoremap <silent> <Plug>(_incsearch-winrestview) :<C-u>call winrestview(g:incsearch#_view)<CR>
    1              0.000026 xnoremap <silent> <Plug>(_incsearch-winrestview) :<C-u>call winrestview(g:incsearch#_view)<CR>gv
                            
    1              0.000004 function! s:stay(cli, input) abort
                              let [raw_pattern, offset] = a:cli._parse_pattern()
                              let pattern = a:cli._convert(raw_pattern)
                            
                              " NOTE: do not move cursor but need to handle {offset} for n & N ...! {{{
                              " FIXME: cannot set {offset} if in operator-pending mode because this
                              " have to use feedkeys()
                              let is_cancel = a:cli.exit_code()
                              if is_cancel
                                call s:cleanup_cmdline()
                              elseif !empty(offset) && mode(1) !=# 'no'
                                let cmd = incsearch#with_ignore_foldopen(
                                \   s:U.dictfunction(a:cli._generate_command, a:cli), a:input)
                                call feedkeys(cmd, 'n')
                                let g:incsearch#_view = a:cli._w
                                call feedkeys("\<Plug>(_incsearch-winrestview)", 'm')
                                call incsearch#autocmd#auto_nohlsearch(2)
                              else
                                " Handle last-pattern
                                if a:input isnot# ''
                                  call histadd('/', a:input)
                                  call s:set_search_reg(pattern, a:cli._base_key)
                                endif
                                call incsearch#autocmd#auto_nohlsearch(0)
                              endif
                              " }}}
                              return s:U.is_visual(a:cli._mode) ? "\<ESC>gv" : "\<ESC>" " just exit
                            endfunction
                            
    1              0.000004 function! s:search(cli, input) abort
                              call incsearch#autocmd#auto_nohlsearch(1) " NOTE: `.` repeat doesn't handle this
                              return a:cli._generate_command(a:input)
                            endfunction
                            
    1              0.000003 function! s:get_input(cli) abort
                              " Handle visual mode highlight
                              if s:U.is_visual(a:cli._mode)
                                let visual_hl = incsearch#highlight#get_visual_hlobj()
                                try
                                  call incsearch#highlight#turn_off(visual_hl)
                                  call incsearch#highlight#emulate_visual_highlight(a:cli._mode, visual_hl)
                                  let input = a:cli.get(a:cli._pattern)
                                finally
                                  call incsearch#highlight#turn_on(visual_hl)
                                endtry
                              else
                                let input = a:cli.get(a:cli._pattern)
                              endif
                              return input
                            endfunction
                            
                            " Assume the cursor move is already done.
                            " This function handle search related stuff which doesn't be set by :execute
                            " in function like @/, hisory, jumplist, offset, error & warning emulation.
    1              0.000005 function! s:set_search_related_stuff(cli, cmd, ...) abort
                              " For stay motion
                              let should_set_jumplist = get(a:, 1, s:TRUE)
                              let is_cancel = a:cli.exit_code()
                              if is_cancel
                                " Restore cursor position and return
                                " NOTE: Should I request on_cancel event to vital-over and use it?
                                call winrestview(a:cli._w)
                                call s:cleanup_cmdline()
                                return
                              endif
                              let [raw_pattern, offset] = a:cli._parse_pattern()
                              let should_execute = !empty(offset) || empty(raw_pattern)
                              if should_execute
                                " Execute with feedkeys() to work with
                                "  1. :h {offset} for `n` and `N`
                                "  2. empty input (:h last-pattern)
                                "  NOTE: Don't use feedkeys() as much as possible to avoid flickering
                                call winrestview(a:cli._w)
                                call feedkeys(a:cmd, 'n')
                                if g:incsearch#consistent_n_direction
                                  call feedkeys("\<Plug>(_incsearch-searchforward)", 'm')
                                endif
                              else
                                " Add history if necessary
                                " Do not save converted pattern to history
                                let pattern = a:cli._convert(raw_pattern)
                                let input = a:cli._combine_pattern(raw_pattern, offset)
                                call histadd(a:cli._base_key, input)
                                call s:set_search_reg(pattern, a:cli._base_key)
                            
                                let target_view = winsaveview()
                                call winrestview(a:cli._w) " Get back start position temporarily for emulation
                                " Set jump list
                                if should_set_jumplist
                                  normal! m`
                                endif
                                " Emulate errors, and handling `n` and `N` preparation
                                call s:emulate_search_error(a:cli._direction, a:cli._w)
                            
                                " winrestview() between error and wraning emulation to avoid flickering
                                call winrestview(target_view)
                            
                                " Emulate warning
                                call s:emulate_search_warning(a:cli._direction, a:cli._w, target_view)
                            
                                call s:silent_after_search()
                            
                                " Open fold
                                if &foldopen =~# '\vsearch|all'
                                  normal! zv
                                endif
                              endif
                            endfunction
                            
                            
                            "}}}
                            
                            " Helper: {{{
                            " @return [pattern, offset]
    1              0.000007 function! incsearch#parse_pattern(expr, search_key) abort
                              " search_key : '/' or '?'
                              " expr       : {pattern\/pattern}/{offset}
                              " expr       : {pattern}/;/{newpattern} :h //;
                              " return     : [{pattern\/pattern}, {offset}]
                              let very_magic = '\v'
                              let pattern  = '(%(\\.|.){-})'
                              let slash = '(\' . a:search_key . '&[^\\"|[:alnum:][:blank:]])'
                              let offset = '(.*)'
                            
                              let parse_pattern = very_magic . pattern . '%(' . slash . offset . ')?$'
                              let result = matchlist(a:expr, parse_pattern)[1:3]
                              if type(result) == type(0) || empty(result)
                                return []
                              endif
                              unlet result[1]
                              return result
                            endfunction
                            
    1              0.000005 function! incsearch#detect_case(pattern) abort
                              " Ignore \%C, \%U, \%V for smartcase detection
                              let p = substitute(a:pattern, s:non_escaped_backslash . '%[CUV]', '', 'g')
                              " Explicit \c has highest priority
                              if p =~# s:non_escaped_backslash . 'c'
                                return '\c'
                              endif
                              if p =~# s:non_escaped_backslash . 'C' || &ignorecase == s:FALSE
                                return '\C' " noignorecase or explicit \C
                              endif
                              if &smartcase == s:FALSE
                                return '\c' " ignorecase & nosmartcase
                              endif
                              " Find uppercase letter which isn't escaped
                              if p =~# s:escaped_backslash . '[A-Z]'
                                return '\C' " smartcase with [A-Z]
                              else
                                return '\c' " smartcase without [A-Z]
                              endif
                            endfunction
                            
    1              0.000007 function! s:silent_after_search(...) abort " arg: mode(1)
                              " :h function-search-undo
                              let m = get(a:, 1, mode(1))
                              if m !=# 'no' " guard for operator-mapping
                                let cmd = join([
                                \   (s:U.is_visual(m) ? "\<Plug>(_incsearch-esc)" : ''),
                                \   "\<Plug>(_incsearch-hlsearch)",
                                \   "\<Plug>(_incsearch-searchforward)",
                                \   (s:U.is_visual(m) ? "\<Plug>(_incsearch-gv)" : '')
                                \ ], '')
                                call feedkeys(cmd, 'm')
                              endif
                            endfunction
                            
    1              0.000043 noremap  <silent> <Plug>(_incsearch-gv) <Nop>
    1              0.000021 noremap! <silent> <Plug>(_incsearch-gv) <Nop>
    1              0.000031 nnoremap <silent> <Plug>(_incsearch-gv) gv
                            
    1              0.000031 noremap  <silent> <Plug>(_incsearch-esc) <Nop>
    1              0.000034 noremap! <silent> <Plug>(_incsearch-esc) <Nop>
    1              0.000020 xnoremap <silent> <Plug>(_incsearch-esc) <Esc>
                            
    1              0.000022 noremap  <silent> <Plug>(_incsearch-hlsearch) <Nop>
    1              0.000015 noremap! <silent> <Plug>(_incsearch-hlsearch) <Nop>
    1              0.000025 nnoremap <silent> <Plug>(_incsearch-hlsearch) :<C-u>let &hlsearch=&hlsearch<CR>
    1              0.000023 xnoremap <silent> <Plug>(_incsearch-hlsearch) :<C-u>let &hlsearch=&hlsearch<CR>gv
                            
    1              0.000022 noremap  <silent>       <Plug>(_incsearch-searchforward) <Nop>
    1              0.000016 noremap! <silent>       <Plug>(_incsearch-searchforward) <Nop>
    1              0.000026 nnoremap <silent><expr> <Plug>(_incsearch-searchforward) <SID>_searchforward_cmd()
    1              0.000024 xnoremap <silent><expr> <Plug>(_incsearch-searchforward) <SID>_searchforward_cmd()
    1              0.000005 function! s:_searchforward_cmd() abort
                              let d = (g:incsearch#consistent_n_direction ? s:DIRECTION.forward : (incsearch#cli()._base_key is# '/' ? 1 : 0))
                              return printf(":\<C-u>let v:searchforward=%d\<CR>", d)
                            endfunction
                            
    1              0.000004 function! s:emulate_search_error(direction, ...) abort
                              let from = get(a:, 1, winsaveview())
                              let keyseq = (a:direction == s:DIRECTION.forward ? '/' : '?')
                              let old_errmsg = v:errmsg
                              let v:errmsg = ''
                              " NOTE:
                              "   - XXX: Handle `n` and `N` preparation with s:silent_after_search()
                              "   - silent!: Do not show error and warning message, because it also
                              "     echo v:throwpoint for error and save messages in message-history
                              "   - Unlike v:errmsg, v:warningmsg doesn't set if it use :silent!
                              " Get first error
                              silent! call incsearch#execute_search(keyseq . "\<CR>")
                              call winrestview(from)
                              if g:incsearch#do_not_save_error_message_history
                                if v:errmsg !=# ''
                                  call s:Error(v:errmsg)
                                else
                                  let v:errmsg = old_errmsg
                                endif
                              else
                                " NOTE: show more than two errors e.g. `/\za`
                                let last_error = v:errmsg
                                try
                                  " Do not use silent! to show warning
                                  call incsearch#execute_search(keyseq . "\<CR>")
                                catch /^Vim\%((\a\+)\)\=:E/
                                  let first_error = matchlist(v:exception, '\v^Vim%(\(\a+\))=:(E.*)$')[1]
                                  call s:Error(first_error, 'echom')
                                  if last_error !=# '' && last_error !=# first_error
                                    call s:Error(last_error, 'echom')
                                  endif
                                finally
                                  call winrestview(from)
                                endtry
                                if v:errmsg ==# ''
                                  let v:errmsg = old_errmsg
                                endif
                              endif
                            endfunction
                            
    1              0.000005 function! s:emulate_search_warning(direction, from, to) abort
                              " NOTE:
                              " - It should use :h echomsg considering emulation of default
                              "   warning messages remain in the :h message-history, but it'll mess
                              "   up the message-history unnecessary, so it use :h echo
                              " - See :h shortmess
                              " if &shortmess !~# 's' && g:incsearch#do_not_save_error_message_history
                              if &shortmess !~# 's' && g:incsearch#do_not_save_error_message_history
                                let from = [a:from.lnum, a:from.col]
                                let to = [a:to.lnum, a:to.col]
                                let old_warningmsg = v:warningmsg
                                let v:warningmsg =
                                \   ( a:direction == s:DIRECTION.forward && !s:U.is_pos_less_equal(from, to)
                                \   ? 'search hit BOTTOM, continuing at TOP'
                                \   : a:direction == s:DIRECTION.backward && s:U.is_pos_less_equal(from, to)
                                \   ? 'search hit TOP, continuing at BOTTOM'
                                \   : '' )
                                if v:warningmsg !=# ''
                                  call s:Warning(v:warningmsg)
                                else
                                  let v:warningmsg = old_warningmsg
                                endif
                              endif
                            endfunction
                            
    1              0.000004 function! s:cleanup_cmdline() abort
                              redraw | echo ''
                            endfunction
                            
                            " Should I use :h echoerr ? But it save the messages in message-history
    1              0.000004 function! s:Error(msg, ...) abort
                              return call(function('s:_echohl'), [a:msg, 'ErrorMsg'] + a:000)
                            endfunction
                            
    1              0.000003 function! s:Warning(msg, ...) abort
                              return call(function('s:_echohl'), [a:msg, 'WarningMsg'] + a:000)
                            endfunction
                            
    1              0.000003 function! s:_echohl(msg, hlgroup, ...) abort
                              let echocmd = get(a:, 1, 'echo')
                              redraw | echo ''
                              exec 'echohl' a:hlgroup
                              exec echocmd string(a:msg)
                              echohl None
                            endfunction
                            
                            " Not to generate command with zv
    1              0.000004 function! incsearch#with_ignore_foldopen(F, ...) abort
                              let foldopen_save = &foldopen
                              let &foldopen=''
                              try
                                return call(a:F, a:000)
                              finally
                                let &foldopen = foldopen_save
                              endtry
                            endfunction
                            
                            " Try to avoid side-effect as much as possible except cursor movement
    1              0.000010 let s:has_keeppattern = v:version > 704 || v:version == 704 && has('patch083')
    1              0.000006 let s:keeppattern = (s:has_keeppattern ? 'keeppattern' : '')
    1              0.000004 function! s:_execute_search(cmd) abort
                              " :nohlsearch
                              "   Please do not highlight at the first place if you set back
                              "   info! I'll handle it myself :h function-search-undo
                              execute s:keeppattern 'keepjumps' 'normal!' a:cmd | nohlsearch
                            endfunction
    1              0.000003 if s:has_keeppattern
    1              0.000004   function! incsearch#execute_search(...) abort
                                return call(function('s:_execute_search'), a:000)
                              endfunction
                            else
                              function! incsearch#execute_search(...) abort
                                " keeppattern emulation
                                let p = @/
                                let r = call(function('s:_execute_search'), a:000)
                                " NOTE: `let @/ = p` reset v:searchforward
                                let d = v:searchforward
                                let @/ = p
                                let v:searchforward = d
                                return r
                              endfunction
    1              0.000002 endif
                            
    1              0.000003 function! incsearch#magic() abort
                              let m = g:incsearch#magic
                              return (len(m) == 2 && m =~# '\\[mMvV]' ? m : '')
                            endfunction
                            
                            " s:set_search_reg() set pattern to @/ with ?\? handling
                            " @command '/' or '?'
    1              0.000004 function! s:set_search_reg(pattern, command) abort
                              let @/ = a:command is# '?'
                              \ ? substitute(a:pattern, '\\?', '?', 'g') : a:pattern
                            endfunction
                            
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000021   0.000017 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=2 shiftwidth=2
                            " vim: foldmethod=marker
                            " }}}

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim
Sourced 1 time
Total time:   0.000549
 Self time:   0.000542

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/util.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000015 set cpo&vim
                            " }}}
                            
    1              0.000003 let s:TRUE = !0
    1              0.000003 let s:FALSE = 0
                            
                            " Public Utilities:
    1              0.000005 function! incsearch#util#deepextend(...) abort
                              return call(function('s:deepextend'), a:000)
                            endfunction
                            
                            " Utilities:
                            
    1              0.000004 function! incsearch#util#import() abort
                              let prefix = '<SNR>' . s:SID() . '_'
                              let module = {}
                              for func in s:functions
                                let module[func] = function(prefix . func)
                              endfor
                              return copy(module)
                            endfunction
                            
    1              0.000003 function! s:SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
                            endfunction
                            
    1              0.000016 let s:functions = [
                            \     'is_visual'
                            \   , 'get_max_col'
                            \   , 'is_pos_less_equal'
                            \   , 'is_pos_more_equal'
                            \   , 'sort_num'
                            \   , 'sort_pos'
                            \   , 'count_pattern'
                            \   , 'silent_feedkeys'
                            \   , 'deepextend'
                            \   , 'dictfunction'
                            \   , 'regexp_join'
                            \ ]
                            
                            
    1              0.000003 function! s:is_visual(mode) abort
                              return a:mode =~# "[vV\<C-v>]"
                            endfunction
                            
                            " Return max column number of given line expression
                            " expr: similar to line(), col()
    1              0.000004 function! s:get_max_col(expr) abort
                              return strlen(getline(a:expr)) + 1
                            endfunction
                            
                            " return (x <= y)
    1              0.000005 function! s:is_pos_less_equal(x, y) abort
                              return (a:x[0] == a:y[0]) ? a:x[1] <= a:y[1] : a:x[0] < a:y[0]
                            endfunction
                            
                            " return (x > y)
    1              0.000004 function! s:is_pos_more_equal(x, y) abort
                              return ! s:is_pos_less_equal(a:x, a:y)
                            endfunction
                            
                            " x < y -> -1
                            " x = y -> 0
                            " x > y -> 1
    1              0.000003 function! s:compare_pos(x, y) abort
                              return max([-1, min([1,(a:x[0] == a:y[0]) ? a:x[1] - a:y[1] : a:x[0] - a:y[0]])])
                            endfunction
                            
    1              0.000003 function! s:sort_num(xs) abort
                              " 7.4.341
                              " http://ftp.vim.org/vim/patches/7.4/7.4.341
                              if v:version > 704 || v:version == 704 && has('patch341')
                                return sort(a:xs, 'n')
                              else
                                return sort(a:xs, 's:_sort_num_func')
                              endif
                            endfunction
                            
    1              0.000003 function! s:_sort_num_func(x, y) abort
                              return a:x - a:y
                            endfunction
                            
    1              0.000004 function! s:sort_pos(pos_list) abort
                              " pos_list: [ [x1, y1], [x2, y2] ]
                              return sort(a:pos_list, 's:compare_pos')
                            endfunction
                            
                            " Return the number of matched patterns in the current buffer or the specified
                            " region with `from` and `to` positions
                            " parameter: pattern, from, to
    1              0.000008 function! s:count_pattern(pattern, ...) abort
                              let w = winsaveview()
                              let [from, to] = [
                              \   get(a:, 1, [1, 1]),
                              \   get(a:, 2, [line('$'), s:get_max_col('$')])
                              \ ]
                              let ignore_at_cursor_pos = get(a:, 3, 0)
                              " direction flag
                              let d_flag = s:compare_pos(from, to) > 0 ? 'b' : ''
                              call cursor(from)
                              let cnt = 0
                              let base_flag = d_flag . 'W'
                              try
                                " first: accept a match at the cursor position
                                let pos = searchpos(a:pattern, (ignore_at_cursor_pos ? '' : 'c' ) . base_flag)
                                while (pos != [0, 0] && s:compare_pos(pos, to) isnot# (d_flag is# 'b' ? -1 : 1))
                                  let cnt += 1
                                  let pos = searchpos(a:pattern, base_flag)
                                endwhile
                              finally
                                call winrestview(w)
                              endtry
                              return cnt
                            endfunction
                            
                            " NOTE: support vmap?
                            " It doesn't handle feedkeys() on incsert or command-line mode
    1              0.000007 function! s:silent_feedkeys(expr, name, ...) abort
                              " Ref:
                              " https://github.com/osyo-manga/vim-over/blob/d51b028c29661d4a5f5b79438ad6d69266753711/autoload/over.vim#L6
                              let mode = get(a:, 1, 'm')
                              let name = 'incsearch-' . a:name
                              let map = printf('<Plug>(%s)', name)
                              if mode ==# 'n'
                                let command = 'nnoremap'
                              else
                                let command = 'nmap'
                              endif
                              execute command '<silent>' map printf('%s:nunmap %s<CR>', a:expr, map)
                              if mode(1) !=# 'ce'
                                " FIXME: mode(1) !=# 'ce' exists only for the test
                                "        :h feedkeys() doesn't work while runnning a test script
                                "        https://github.com/kana/vim-vspec/issues/27
                                call feedkeys(printf("\<Plug>(%s)", name))
                              endif
                            endfunction
                            
                            " deepextend (nest: 1)
    1              0.000005 function! s:deepextend(expr1, expr2) abort
                              let expr2 = copy(a:expr2)
                              for [k, V] in items(a:expr1)
                                if (type(V) is type({}) || type(V) is type([])) && has_key(expr2, k)
                                  let a:expr1[k] = extend(a:expr1[k], expr2[k])
                                  unlet expr2[k]
                                endif
                                unlet V
                              endfor
                              return extend(a:expr1, expr2)
                            endfunction
                            
    1              0.000006 let s:funcmanage = {}
    1              0.000005 function! s:funcmanage() abort
                              return s:funcmanage
                            endfunction
                            
    1              0.000006 function! s:dictfunction(dictfunc, dict) abort
                              if has('patch-7.4.1842')
                                let funcname = '_' . get(a:dictfunc, 'name')
                              else
                                let funcname = '_' . matchstr(string(a:dictfunc), '\d\+')
                              endif
                              let s:funcmanage[funcname] = {
                              \   'func': a:dictfunc,
                              \   'dict': a:dict
                              \ }
                              let prefix = '<SNR>' . s:SID() . '_'
                              let fm = printf("%sfuncmanage()['%s']", prefix, funcname)
                              execute join([
                              \   printf('function! s:%s(...) abort', funcname),
                              \   printf("  return call(%s['func'], a:000, %s['dict'])", fm, fm),
                              \          'endfunction'
                              \ ], "\n")
                              return function(printf('%s%s', prefix, funcname))
                            endfunction
                            
                            
                            "--- regexp
                            
    1              0.000008 let s:escaped_backslash = '\m\%(^\|[^\\]\)\%(\\\\\)*\zs'
                            
    1              0.000006 function! s:regexp_join(ps) abort
                              let rs = map(filter(copy(a:ps), 's:_is_valid_regexp(v:val)'), 's:escape_unbalanced_left_r(v:val)')
                              return printf('\m\%%(%s\m\)', join(rs, '\m\|'))
                            endfunction
                            
    1              0.000005 function! s:_is_valid_regexp(pattern) abort
                              try
                                if '' =~# a:pattern
                                endif
                                return s:TRUE
                              catch
                                return s:FALSE
                              endtry
                            endfunction
                            
                            " \m,\v:  [ -> \[
                            " \M,\V:  \[ -> [
    1              0.000006 function! s:escape_unbalanced_left_r(pattern) abort
                              let rs = []
                              let cs = split(a:pattern, '\zs')
                              " escape backslash (\, \\\, \\\\\, ...)
                              let escape_bs = s:FALSE
                              let flag = &magic ? 'm' : 'M'
                              let i = 0
                              while i < len(cs)
                                let c = cs[i]
                                " characters to add to rs
                                let addcs = [c]
                                if escape_bs && s:_is_flag(c)
                                  let flag = c
                                elseif c is# '[' && s:_may_replace_left_r_cond(escape_bs, flag)
                                  let idx = s:_find_right_r(cs, i)
                                  if idx is# -1
                                    if s:_is_flag(flag, 'MV')
                                      " Remove `\` before unbalanced `[`
                                      let rs = rs[:-2]
                                    else
                                      " Escape unbalanced `[`
                                      let addcs = ['\' . c]
                                    endif
                                  else
                                    let addcs = cs[(i):(i+idx)]
                                    let i += idx
                                  endif
                                endif
                                let escape_bs = (escape_bs || c isnot# '\') ? s:FALSE : s:TRUE
                                let rs += addcs
                                let i += 1
                              endwhile
                              return join(rs, '')
                            endfunction
                            
                            " @ return boolean
    1              0.000005 function! s:_is_flag(flag, ...) abort
                              let chars = get(a:, 1, 'mMvV')
                              return a:flag =~# printf('\m[%s]', chars)
                            endfunction
                            
                            " @ return boolean
    1              0.000007 function! s:_may_replace_left_r_cond(escape_bs, flag) abort
                              return (a:escape_bs && s:_is_flag(a:flag, 'MV')) || (!a:escape_bs && s:_is_flag(a:flag, 'mv'))
                            endfunction
                            
                            " @return index
    1              0.000005 function! s:_find_right_r(cs, i) abort
                              return match(join(a:cs[(a:i+1):], ''), s:escaped_backslash . ']')
                            endfunction
                            
                            "--- end of regexp
                            
                            
                            " Restore 'cpoptions' {{{
    1   0.000026   0.000022 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=2 shiftwidth=2
                            " vim: foldmethod=marker
                            " }}}

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/config.vim
Sourced 1 time
Total time:   0.000392
 Self time:   0.000220

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/config.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000004 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000018   0.000017 set cpo&vim
                            
    1              0.000004 let s:TRUE = !0
    1              0.000003 let s:FALSE = 0
    1              0.000003 lockvar s:TRUE s:FALSE
                            
    1   0.000187   0.000018 let s:U = incsearch#util#import()
                            
                            "" incsearch config
                            " TODO: more detail documentation
                            " @command is equivalent with base_key TODO: fix this inconsistence
                            " @count default: v:count secret
                            " @mode default: mode(1) secret
    1              0.000017 let s:config = {
                            \   'command': '/',
                            \   'is_stay': s:FALSE,
                            \   'is_expr': s:FALSE,
                            \   'pattern': '',
                            \   'mode': 'n',
                            \   'count': 0,
                            \   'prompt': '',
                            \   'modules': [],
                            \   'converters': [],
                            \   'keymap': {}
                            \ }
                            
                            " @return config for lazy value
    1              0.000004 function! s:lazy_config() abort
                              let m = mode(1)
                              return {
                              \   'count': v:count,
                              \   'mode': m,
                              \   'is_expr': (m is# 'no'),
                              \   'keymap': s:keymap()
                              \ }
                            endfunction
                            
                            " @return config with default value
    1              0.000004 function! incsearch#config#make(additional) abort
                              let default = extend(deepcopy(s:config), s:lazy_config())
                              let c = s:U.deepextend(default, a:additional)
                              if c.prompt is# ''
                                let c.prompt = c.command
                              endif
                              return c
                            endfunction
                            
    1              0.000033 let s:default_keymappings = {
                            \   "\<Tab>"   : {
                            \       'key' : '<Over>(incsearch-next)',
                            \       'noremap' : 1,
                            \   },
                            \   "\<S-Tab>"   : {
                            \       'key' : '<Over>(incsearch-prev)',
                            \       'noremap' : 1,
                            \   },
                            \   "\<C-j>"   : {
                            \       'key' : '<Over>(incsearch-scroll-f)',
                            \       'noremap' : 1,
                            \   },
                            \   "\<C-k>"   : {
                            \       'key' : '<Over>(incsearch-scroll-b)',
                            \       'noremap' : 1,
                            \   },
                            \   "\<C-l>"   : {
                            \       'key' : '<Over>(buffer-complete)',
                            \       'noremap' : 1,
                            \   },
                            \   "\<CR>"   : {
                            \       'key': "\<CR>",
                            \       'noremap': 1
                            \   },
                            \ }
                            
                            " https://github.com/haya14busa/incsearch.vim/issues/35
    1              0.000007 if has('mac')
                              call extend(s:default_keymappings, {
                              \   '"+gP'   : {
                              \       'key': "\<C-r>+",
                              \       'noremap': 1
                              \   },
                              \ })
    1              0.000002 endif
                            
    1              0.000017 function! s:keymap() abort
                              return extend(copy(s:default_keymappings), g:incsearch_cli_key_mappings)
                            endfunction
                            
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim
Sourced 1 time
Total time:   0.065804
 Self time:   0.003220

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/cli.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
    1              0.000007 let s:DIRECTION = { 'forward': 1, 'backward': 0 } " see :h v:searchforward
                            
    1              0.000004 function! incsearch#cli#get() abort
                              try
                                " It returns current cli object
                                return s:Doautocmd.get_cmdline()
                              catch /vital-over(_incsearch) Exception/
                                " If there are no current cli object, return default one
                                return incsearch#cli#make(incsearch#config#make({}))
                              endtry
                            endfunction
                            
                            " @config: whole configuration
    1              0.000003 function! incsearch#cli#make(config) abort
                              let cli = deepcopy(s:cli)
                              call incsearch#cli#set(cli, a:config)
                              return cli
                            endfunction
                            
                            " To reuse cli object, you should re-set configuration
                            " @config: whole configuration
    1              0.000004 function! incsearch#cli#set(cli, config) abort
                              let a:cli._base_key = a:config.command
                              let a:cli._vcount1 = max([1, a:config.count])
                              let a:cli._has_count = a:config.count > 0
                              let a:cli._is_expr = a:config.is_expr
                              let a:cli._mode = a:config.mode
                              let a:cli._pattern = a:config.pattern
                              let a:cli._prompt = a:config.prompt
                              let a:cli._keymap = a:config.keymap
                              let a:cli._converters = a:config.converters
                              let a:cli._flag = a:config.is_stay         ? 'n'
                              \               : a:config.command is# '/' ? ''
                              \               : a:config.command is# '?' ? 'b'
                              \               : ''
                              let a:cli._direction =
                              \ (a:cli._base_key is# '/' ? s:DIRECTION.forward : s:DIRECTION.backward)
                              " TODO: provide config? but it may conflict with <expr> mapping
                              " NOTE: _w: default cursor view
                              let a:cli._w = winsaveview()
                              for module in a:config.modules
                                call a:cli.connect(module)
                              endfor
                              call a:cli.set_prompt(a:cli._prompt)
                              return a:cli
                            endfunction
                            
    1   0.016564   0.000285 let s:cli = vital#incsearch#import('Over.Commandline').make_default('/')
    1   0.000118   0.000019 let s:modules = vital#incsearch#import('Over.Commandline.Modules')
                            
                            " Add modules
    1   0.001200   0.000008 call s:cli.connect('BufferComplete')
    1   0.001240   0.000007 call s:cli.connect('Cancel')
    1   0.001010   0.000013 call s:cli.connect('CursorMove')
    1   0.001322   0.000008 call s:cli.connect('Digraphs')
    1   0.001088   0.000008 call s:cli.connect('Delete')
    1   0.001206   0.000008 call s:cli.connect('DrawCommandline')
    1   0.001208   0.000009 call s:cli.connect('ExceptionExit')
    1   0.001151   0.000022 call s:cli.connect('LiteralInsert')
    1   0.000603   0.000324 call s:cli.connect(incsearch#over#modules#exit#make())
    1   0.002005   0.000347 call s:cli.connect(incsearch#over#modules#insert_register#make())
    1   0.001299   0.000007 call s:cli.connect('Paste')
    1   0.003116   0.000017 let s:Doautocmd = s:modules.get('Doautocmd')
    1   0.000555   0.000027 call s:cli.connect(s:Doautocmd.make('IncSearch'))
    1   0.001540   0.000039 call s:cli.connect(s:modules.get('ExceptionMessage').make('incsearch.vim: ', 'echom'))
    1   0.001228   0.000044 call s:cli.connect(s:modules.get('History').make('/'))
    1   0.001333   0.000082 call s:cli.connect(s:modules.get('NoInsert').make_special_chars())
                            
                            " Dynamic Module Loading Management
    1   0.004133   0.000014 let s:KeyMapping = s:modules.get('KeyMapping')
    1   0.000020   0.000014 let s:emacs_like = s:KeyMapping.make_emacs()
    1   0.000041   0.000034 let s:vim_cmap = s:KeyMapping.make_vim_cmdline_mapping()
    1   0.001003   0.000025 let s:smartbackword = s:modules.get('IgnoreRegexpBackwardWord').make()
    1              0.000005 function! s:emacs_like._condition() abort
                              return g:incsearch#emacs_like_keymap
                            endfunction
    1              0.000003 function! s:vim_cmap._condition() abort
                              return g:incsearch#vim_cmdline_keymap
                            endfunction
    1              0.000002 function! s:smartbackword._condition() abort
                              return g:incsearch#smart_backward_word
                            endfunction
    1   0.000692   0.000286 call s:cli.connect(incsearch#over#modules#module_management#make([s:emacs_like, s:vim_cmap, s:smartbackword]))
    1              0.000006 unlet s:KeyMapping s:emacs_like s:vim_cmap s:smartbackword
                            
    1   0.000575   0.000281 call s:cli.connect(incsearch#over#modules#pattern_saver#make())
    1   0.000647   0.000333 call s:cli.connect(incsearch#over#modules#bulk_input_char#make())
    1   0.000663   0.000269 call s:cli.connect(incsearch#over#modules#bracketed_paste#make())
    1   0.019374   0.000263 call s:cli.connect(incsearch#over#modules#incsearch#make())
                            
    1              0.000003 function! s:cli.__keymapping__() abort
                              return copy(self._keymap)
                            endfunction
                            
    1   0.000696   0.000256 call incsearch#over#extend#enrich(s:cli)
                            
    1   0.000016   0.000015 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim
Sourced 1 time
Total time:   0.001049
 Self time:   0.000965

count  total (s)   self (s)
    1              0.000015 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000007 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000008 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000005 let s:is_vital_vim = s:plugin_name is# 'vital'
                            
    1              0.000017 let s:loaded = {}
    1              0.000004 let s:cache_sid = {}
                            
                            " function() wrapper
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! s:_function(fstr) abort
                                return function(a:fstr)
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              let s:_s = '<SNR>' . s:_SID() . '_'
                              function! s:_function(fstr) abort
                                return function(substitute(a:fstr, 's:', s:_s, 'g'))
                              endfunction
    1              0.000002 endif
                            
    1              0.000005 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction
                            
    1              0.000006 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction
                            
    1              0.000003 let s:Vital = {}
                            
    1              0.000003 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction
                            
    1              0.000088 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1   0.000040   0.000027 let s:Vital.vital_files = s:_function('s:vital_files')
                            
    1              0.000005 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1   0.000029   0.000018 let s:Vital.import = s:_function('s:import')
                            
    1              0.000004 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1   0.000039   0.000029 let s:Vital.load = s:_function('s:load')
                            
    1              0.000005 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1   0.000039   0.000030 let s:Vital.unload = s:_function('s:unload')
                            
    1              0.000005 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1   0.000025   0.000017 let s:Vital.exists = s:_function('s:exists')
                            
    1              0.000004 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return s:_uniq(modules)
                            endfunction
    1   0.000024   0.000016 let s:Vital.search = s:_function('s:search')
                            
    1              0.000005 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1   0.000025   0.000017 let s:Vital.plugin_name = s:_function('s:plugin_name')
                            
    1              0.000005 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction
                            
    1              0.000005 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction
                            
    1              0.000005 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction
                            
    1              0.000009 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction
                            
                            " @param {string} name e.g. Data.List
    1              0.000004 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1   0.000026   0.000018 let s:Vital._import = s:_function('s:_import')
                            
                            " s:_get_module() returns module object wihch has all script local functions.
    1              0.000005 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              try
                                return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117/
                                return s:_get_builtin_module(a:name)
                              endtry
                            endfunction
                            
    1              0.000005 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction
                            
    1              0.000004 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = s:_function('s:_get_builtin_module')
    1              0.000003 else
    1   0.000026   0.000017   let s:Vital._get_module = s:_function('s:_get_module')
    1              0.000003 endif
                            
    1              0.000007 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction
                            
    1              0.000004 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction
                            
    1              0.000005 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction
                            
    1              0.000005 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction
                            
    1              0.000004 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction
                            
    1              0.000004 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000005 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(s:_execute(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction
                            
                            " A bug of execute() is fixed in Vim 8.0.0264
    1              0.000009 if has('patch-8.0.0264')
    1              0.000008   let s:_execute = function('execute')
                            else
                              function! s:_execute(cmd) abort
                                let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
                                set verbose=0 verbosefile=
                                redir => res
                                  silent! execute a:cmd
                                redir END
                                let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
                                return res
                              endfunction
    1              0.000001 endif
                            
    1              0.000019 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
                              let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
                              function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
    1              0.000002 else
    1              0.000003   function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
    1              0.000002 endif
                            
                            " copied and modified from Vim.ScriptLocal
    1              0.000050 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000004 function! s:sid2sfuncs(sid) abort
                              let fs = split(s:_execute(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction
                            
                            "" Return funcname of script local functions with SID
    1              0.000004 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction
                            
    1              0.000005 if exists('*uniq')
    1              0.000003   function! s:_uniq(list) abort
                                return uniq(a:list)
                              endfunction
                            else
                              function! s:_uniq(list) abort
                                let i = len(a:list) - 1
                                while 0 < i
                                  if a:list[i] ==# a:list[i - 1]
                                    call remove(a:list, i)
                                  endif
                                  let i -= 1
                                endwhile
                                return a:list
                              endfunction
    1              0.000003 endif

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline.vim
Sourced 1 time
Total time:   0.000257
 Self time:   0.000202

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000106   0.000055 execute join(['function! vital#_incsearch#Over#Commandline#import() abort', printf("return map({'_vital_depends': '', 'make_standard_search_back': '', 'get_module': '', 'make_standard_search': '', 'make_standard': '', 'make_module': '', 'make_default': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Maker = s:V.import("Over.Commandline.Maker")
                            	let s:Modules = s:V.import("Over.Commandline.Modules")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Over.Commandline.Maker",
                            \		"Over.Commandline.Modules",
                            \		"Over.Commandline.Modules.All",
                            \	]
                            endfunction
                            
                            
    1              0.000003 function! s:make_module(...)
                            	return call(s:Modules.make, a:000, s:Modules)
                            endfunction
                            
                            
    1              0.000003 function! s:get_module(...)
                            	return call(s:Modules.get, a:000, s:Modules)
                            endfunction
                            
                            
    1              0.000003 function! s:make_default(...)
                            	return call(s:Maker.default, a:000, s:Maker)
                            endfunction
                            
                            
    1              0.000003 function! s:make_standard(...)
                            	return call(s:Maker.standard, a:000, s:Maker)
                            endfunction
                            
                            
    1              0.000004 function! s:make_standard_search(...)
                            	return call(s:Maker.standard_search, a:000, s:Maker)
                            endfunction
                            
                            
    1              0.000004 function! s:make_standard_search_back(...)
                            	return call(s:Maker.standard_search_back, a:000, s:Maker)
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch.vim
Sourced 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000013 let s:_plugin_name = expand('<sfile>:t:r')
                            
    1              0.000007 function! vital#{s:_plugin_name}#new() abort
                              return vital#{s:_plugin_name[1:]}#new()
                            endfunction
                            
    1              0.000006 function! vital#{s:_plugin_name}#function(funcname) abort
                              silent! return function(a:funcname)
                            endfunction

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Maker.vim
Sourced 1 time
Total time:   0.000265
 Self time:   0.000238

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000067   0.000045 execute join(['function! vital#_incsearch#Over#Commandline#Maker#import() abort', printf("return map({'plain': '', '_vital_depends': '', 'standard_search': '', 'standard': '', 'standard_search_back': '', 'default': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000026 let s:save_cpo = &cpo
    1   0.000030   0.000027 set cpo&vim
                            
    1              0.000016 let s:modules = [
                            \	"Scroll",
                            \	"CursorMove",
                            \	"Delete",
                            \	"HistAdd",
                            \	"History",
                            \	"Cancel",
                            \	"Execute",
                            \	"NoInsert",
                            \	"InsertRegister",
                            \	"Redraw",
                            \	"DrawCommandline",
                            \	"ExceptionExit",
                            \	"ExceptionMessage",
                            \]
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Cmdline = s:V.import("Over.Commandline.Base")
                            	let s:Modules = s:V.import("Over.Commandline.Modules")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Over.Commandline.Base",
                            \		"Over.Commandline.Modules",
                            \	] + map(copy(s:modules), "'Over.Commandline.Modules.' . v:val")
                            endfunction
                            
                            
    1              0.000003 function! s:default(...)
                            	return call(s:Cmdline.make, a:000, s:Cmdline)
                            endfunction
                            
                            
    1              0.000003 function! s:plain()
                            	return s:Cmdline.plain()
                            endfunction
                            
                            
    1              0.000003 function! s:standard(...)
                            	let result = call(s:Cmdline.make, a:000, s:Cmdline)
                            	call result.connect("Execute")
                            	call result.connect("Cancel")
                            	call result.connect("Delete")
                            	call result.connect("CursorMove")
                            	call result.connect("HistAdd")
                            	call result.connect("History")
                            	call result.connect("InsertRegister")
                            	call result.connect(s:Modules.get("NoInsert").make_special_chars())
                            	call result.connect("Redraw")
                            	call result.connect("DrawCommandline")
                            	call result.connect("ExceptionExit")
                            	call result.connect("ExceptionMessage")
                            	call result.connect(s:Modules.get("KeyMapping").make_vim_cmdline_mapping())
                            	call result.connect("Digraphs")
                            	call result.connect("LiteralInsert")
                            
                            	return result
                            endfunction
                            
                            
    1              0.000003 function! s:standard_search(...)
                            	let result = s:standard(get(a:, 1, "/"))
                            	call result.connect(s:Modules.get("Execute").make_search("/"))
                            	call result.connect(s:Modules.make("HistAdd", "/"))
                            	call result.connect(s:Modules.make("History", "/"))
                            	return result
                            endfunction
                            
                            
    1              0.000004 function! s:standard_search_back(...)
                            	let result = s:standard(get(a:, 1, "?"))
                            	call result.connect(s:Modules.get("Execute").make_search("?"))
                            	call result.connect(s:Modules.make("HistAdd", "/"))
                            	call result.connect(s:Modules.make("History", "/"))
                            	return result
                            endfunction
                            
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim
Sourced 1 time
Total time:   0.000948
 Self time:   0.000921

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000064   0.000044 execute join(['function! vital#_incsearch#Over#Commandline#Base#import() abort', printf("return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            	let s:Signals = s:V.import("Over.Signals")
                            	let s:Input = s:V.import("Over.Input")
                            	let s:Keymapping = s:V.import("Over.Keymapping")
                            	let s:Module = s:V.import("Over.Commandline.Modules")
                            	let s:base.variables.modules = s:Signals.make()
                            	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
                            
                            	let s:Highlight = s:V.import("Palette.Highlight")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \		"Over.Signals",
                            \		"Over.Input",
                            \		"Over.Keymapping",
                            \		"Over.Commandline.Modules",
                            \		"Palette.Highlight",
                            \	]
                            endfunction
                            
                            
    1              0.000003 function! s:make(...)
                            	let result = deepcopy(s:base)
                            	call result.set_prompt(get(a:, 1, ":"))
                            	call result.connect(result, "_")
                            	return result
                            endfunction
                            
                            
    1              0.000003 function! s:make_plain()
                            	return deepcopy(s:base)
                            endfunction
                            
                            
    1              0.000031 let s:base = {
                            \	"line" : {},
                            \	"variables" : {
                            \		"prompt" : "",
                            \		"char" : "",
                            \		"input" : "",
                            \		"tap_key" : "",
                            \		"exit" : 0,
                            \		"keymapping" : {},
                            \		"suffix" : "",
                            \		"is_setted" : 0,
                            \	},
                            \	"highlights" : {
                            \		"prompt" : "NONE",
                            \		"cursor" : "VitalOverCommandLineCursor",
                            \		"cursor_on" : "VitalOverCommandLineCursorOn",
                            \		"cursor_insert" : "VitalOverCommandLineOnCursor",
                            \	},
                            \}
                            
    1              0.000022 if exists("s:Signals")
                            	let s:base.variables.modules = s:Signals.make()
                            	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
    1              0.000002 endif
                            
                            
    1              0.000003 function! s:base.getline()
                            	return self.line.str()
                            endfunction
                            
                            
    1              0.000003 function! s:base.setline(line)
                            	return self.line.set(a:line)
                            endfunction
                            
                            
    1              0.000002 function! s:base.char()
                            	return self.variables.char
                            endfunction
                            
                            
    1              0.000003 function! s:base.setchar(char, ...)
                            	" 1 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å¶„ÇÇ‰∏äÊõ∏„Åç„Åô„Çã
                            	" 0 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞‰∏äÊõ∏„Åç„Åó„Å™„ÅÑ
                            	let overwrite = get(a:, 1, 1)
                            	if overwrite || self.variables.is_setted == 0
                            		let self.variables.input = a:char
                            		let self.variables.is_setted = 1
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:base.getpos()
                            	return self.line.pos()
                            endfunction
                            
                            
    1              0.000019 function! s:base.setpos(pos)
                            	return self.line.set_pos(a:pos)
                            endfunction
                            
                            
    1              0.000003 function! s:base.tap_keyinput(key)
                            	let self.variables.tap_key = a:key
                            endfunction
                            
                            
    1              0.000002 function! s:base.untap_keyinput(key)
                            	if self.variables.tap_key == a:key
                            		let self.variables.tap_key = ""
                            		return 1
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_tap_key()
                            	return self.variables.tap_key
                            endfunction
                            
                            
    1              0.000003 function! s:base.is_input(key, ...)
                            	let prekey = get(a:, 1, "")
                            	return self.get_tap_key() ==# prekey
                            \		&& self.char() ==# a:key
                            " \		&& self.char() == (prekey . a:key)
                            endfunction
                            
                            
    1              0.000002 function! s:base.input_key()
                            	return self.variables.input_key
                            endfunction
                            
                            
    1              0.000002 function! s:base.set_prompt(prompt)
                            	let self.variables.prompt = a:prompt
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_prompt()
                            	return self.variables.prompt
                            endfunction
                            
                            
    1              0.000003 function! s:base.set_suffix(str)
                            	let self.variables.suffix = a:str
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_suffix()
                            	return self.variables.suffix
                            endfunction
                            
                            
    1              0.000002 function! s:base.insert(word, ...)
                            	if a:0
                            		call self.line.set(a:1)
                            	endif
                            	call self.line.input(a:word)
                            endfunction
                            
    1              0.000002 function! s:base.forward()
                            	return self.line.forward()
                            endfunction
                            
    1              0.000002 function! s:base.backward()
                            	return self.line.backward()
                            endfunction
                            
                            
    1              0.000002 function! s:base.backward_word(...)
                            	let pat = get(a:, 1, '\k\+\s*\|.')
                            	return matchstr(self.backward(), '\%(' . pat . '\)$')
                            endfunction
                            
                            
    1              0.000005 function! s:base.connect(module, ...)
                            	if type(a:module) == type("")
                            		return call(self.connect, [s:Module.make(a:module)] + a:000, self)
                            	endif
                            	if empty(a:module)
                            		return
                            	endif
                            	let name = a:0 > 0 ? a:1 : a:module.name
                            	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(name))
                            	if empty(slot)
                            		call self.variables.modules.connect({ "name" : name, "module" : a:module })
                            	else
                            		let slot.slot.module = a:module
                            	endif
                            " 	let self.variables.modules[name] = a:module
                            endfunction
                            
                            
    1              0.000002 function! s:base.disconnect(name)
                            	return self.variables.modules.disconnect_by(
                            \		"get(v:val.slot, 'name', '') == " . string(a:name)
                            \	)
                            " 	unlet self.variables.modules[a:name]
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_module(name)
                            	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(a:name))
                            	return empty(slot) ? {} : slot.slot.module
                            endfunction
                            
                            
    1              0.000003 function! s:base.callevent(event)
                            	call self.variables.modules.sort_by("has_key(v:val.slot.module, 'priority') ? v:val.slot.module.priority('" . a:event . "') : 0")
                            	return self.variables.modules.call(a:event, [self])
                            " 	call map(filter(copy(self.variables.modules), "has_key(v:val, a:event)"), "v:val." . a:event . "(self)")
                            endfunction
                            
                            
    1              0.000002 function! s:base.cmap(lhs, rhs)
                            	let self.variables.keymapping[a:lhs] = a:rhs
                            endfunction
                            
                            
    1              0.000002 function! s:base.cnoremap(lhs, rhs)
                            	let key = s:Keymapping.as_key_config(a:rhs)
                            	let key.noremap = 1
                            	let self.variables.keymapping[a:lhs] = key
                            endfunction
                            
                            
    1              0.000003 function! s:base.cunmap(lhs)
                            	unlet self.variables.keymapping[a:lhs]
                            endfunction
                            
                            
    1              0.000002 function! s:base.keymapping()
                            	return self.__keymapping__()
                            endfunction
                            
                            
    1              0.000002 function! s:base.__keymapping__()
                            	return {}
                            endfunction
                            
                            
    1              0.000002 function! s:base.execute(...)
                            	let command = get(a:, 1, self.getline())
                            	call self.__execute(command)
                            endfunction
                            
                            
    1              0.000002 function! s:base.draw()
                            	call self.callevent("on_draw_pre")
                            	call self.callevent("on_draw")
                            endfunction
                            
                            
    1              0.000002 function! s:base.exit(...)
                            	let self.variables.exit = 1
                            	let self.variables.exit_code = get(a:, 1, 0)
                            endfunction
                            
                            
    1              0.000002 function! s:base.enable_keymapping()
                            	let self.variables.enable_keymapping = 1
                            endfunction
                            
                            
    1              0.000002 function! s:base.disable_keymapping()
                            	let self.variables.enable_keymapping = 0
                            endfunction
                            
                            
    1              0.000002 function! s:base.is_enable_keymapping()
                            	return self.variables.enable_keymapping
                            endfunction
                            
                            " function! s:base.cancel()
                            " 	call self.exit(1)
                            " 	call self.__on_cancel()
                            " endfunction
                            
                            
    1              0.000002 function! s:base.exit_code()
                            	return self.variables.exit_code
                            endfunction
                            
                            
    1              0.000002 function! s:base.hl_cursor_on()
                            	if exists("self.variables.old_guicursor")
                            		set guicursor&
                            		let &guicursor = self.variables.old_guicursor
                            		unlet self.variables.old_guicursor
                            	endif
                            
                            	if exists("self.variables.old_t_ve")
                            		let &t_ve = self.variables.old_t_ve
                            		unlet self.variables.old_t_ve
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:base.hl_cursor_off()
                            	if exists("self.variables.old_t_ve")
                            		return
                            	endif
                            
                            	let self.variables.old_guicursor = &guicursor
                            	set guicursor=n:block-NONE
                            	let self.variables.old_t_ve = &t_ve
                            	set t_ve=
                            endfunction
                            
                            
    1              0.000003 function! s:base.start(...)
                            	let exit_code = call(self.__main, a:000, self)
                            	return exit_code
                            endfunction
                            
                            
    1              0.000002 function! s:base.__empty(...)
                            endfunction
                            
                            
    1              0.000002 function! s:base.get(...)
                            	let Old_execute = self.execute
                            	let self.execute = self.__empty
                            	try
                            		let exit_code = call(self.start, a:000, self)
                            		if exit_code == 0
                            			return self.getline()
                            		endif
                            	finally
                            		let self.execute = Old_execute
                            	endtry
                            	return ""
                            endfunction
                            
                            
    1              0.000002 function! s:base.input_key_stack()
                            	return self.variables.input_key_stack
                            endfunction
                            
                            
    1              0.000002 function! s:base.input_key_stack_string()
                            	return join(self.variables.input_key_stack, "")
                            endfunction
                            
                            
    1              0.000002 function! s:base.set_input_key_stack(stack)
                            	let self.variables.input_key_stack = a:stack
                            	return self.variables.input_key_stack
                            endfunction
                            
                            
    1              0.000003 function! s:base.input_key_stack_pop()
                            	return remove(self.input_key_stack(), 0)
                            endfunction
                            
                            
    1              0.000002 function! s:base.getchar(...)
                            	if empty(self.input_key_stack())
                            		return call(s:Input.getchar, a:000, s:Input)
                            	endif
                            	return self.input_key_stack_pop()
                            endfunction
                            
                            
    1              0.000002 function! s:base.__init_variables()
                            	let self.variables.tap_key = ""
                            	let self.variables.char = ""
                            	let self.variables.input = ""
                            	let self.variables.exit = 0
                            	let self.variables.exit_code = 1
                            	let self.variables.enable_keymapping = 1
                            	let self.variables.input_key_stack = []
                            	let self.line = deepcopy(s:String.make())
                            endfunction
                            
                            
    1              0.000004 function! s:_is_valid_highlight(name)
                            	let highlight = s:Highlight.get(a:name)
                            	if empty(highlight)
                            		return 0
                            	endif
                            
                            	if has("gui_running")
                            \	&& (has_key(highlight, "guifg") || has_key(highlight, "guibg"))
                            		return 1
                            	elseif (has_key(highlight, "ctermfg") || has_key(highlight, "ctermbg"))
                            		return 1
                            	endif
                            	return 0
                            endfunction
                            
                            
    1              0.000003 function! s:base.__init()
                            	call self.__init_variables()
                            	call self.hl_cursor_off()
                            	if !hlexists(self.highlights.cursor)
                            		if s:_is_valid_highlight("Cursor")
                            			execute "highlight link " . self.highlights.cursor . " Cursor"
                            		else
                            			" Workaround by CUI Vim Cursor Highlight
                            			" issues #92
                            			" https://github.com/osyo-manga/vital-over/issues/92
                            			execute "highlight " . self.highlights.cursor . " term=reverse cterm=reverse gui=reverse"
                            		endif
                            	endif
                            	if !hlexists(self.highlights.cursor_on)
                            		execute "highlight link " . self.highlights.cursor_on . " " . self.highlights.cursor
                            	endif
                            	if !hlexists(self.highlights.cursor_insert)
                            		execute "highlight " . self.highlights.cursor_insert . " cterm=underline term=underline gui=underline"
                            	endif
                            endfunction
                            
                            
    1              0.000017 function! s:base.__execute(command)
                            	call self.callevent("on_execute_pre")
                            	try
                            		call self.__execute__(a:command)
                            	catch
                            		echohl ErrorMsg
                            		echom matchstr(v:exception, 'Vim\((\w*)\)\?:\zs.*\ze')
                            		echohl None
                            		call self.callevent("on_execute_failed")
                            	finally
                            		call self.callevent("on_execute")
                            	endtry
                            endfunction
                            
                            
    1              0.000002 function! s:base.__execute__(cmd)
                            	execute a:cmd
                            endfunction
                            
                            
    1              0.000002 function! s:base.__input_char(char)
                            	let char = a:char
                            	let self.variables.input_key = char
                            	let self.variables.char = char
                            	call self.setchar(self.variables.char)
                            	let self.variables.is_setted = 0
                            	call self.callevent("on_char_pre")
                            	call self.insert(self.variables.input)
                            	call self.callevent("on_char")
                            endfunction
                            
                            
    1              0.000003 function! s:base.__input(input, ...)
                            	if a:input == ""
                            		return
                            	endif
                            
                            	let self.variables.input_key = a:input
                            	if a:0 == 0
                            		let keymapping = self.__get_keymapping()
                            	else
                            		let keymapping = a:1
                            	endif
                            	if self.is_enable_keymapping()
                            		let key = s:Keymapping.unmapping(keymapping, a:input)
                            	else
                            		let key = a:input
                            	endif
                            	if key == ""
                            		return
                            	endif
                            
                            	call self.set_input_key_stack(s:String.split_by_keys(key))
                            	while !(empty(self.input_key_stack()) || self.is_exit())
                            		call self.__input_char(self.input_key_stack_pop())
                            	endwhile
                            endfunction
                            
                            
    1              0.000004 function! s:is_input_waiting(keymapping, input)
                            	let num = len(filter(copy(a:keymapping), 'stridx(v:key, a:input) == 0'))
                            	return num > 1 || (num == 1 && !has_key(a:keymapping, a:input))
                            endfunction
                            
                            
    1              0.000002 function! s:base.__inputting()
                            	if !self.is_enable_keymapping()
                            		return self.__input(s:Input.getchar())
                            	endif
                            
                            	let input = s:Input.getchar()
                            	let old_line = self.getline()
                            	let old_pos  = self.getpos()
                            	let keymapping = self.__get_keymapping()
                            	try
                            		let t = reltime()
                            		while s:is_input_waiting(keymapping, input)
                            \		&& str2nr(reltimestr(reltime(t))) * 1000 < &timeoutlen
                            			call self.setline(old_line)
                            			call self.insert(input)
                            			call self.setpos(old_pos)
                            			call self.draw()
                            			let input .= s:Input.getchar(0)
                            		endwhile
                            	finally
                            		call self.setline(old_line)
                            		call self.setpos(old_pos)
                            	endtry
                            	call self.__input(input, keymapping)
                            endfunction
                            
                            
    1              0.000003 function! s:base.__update()
                            " 	call self.callevent("on_update")
                            " 	if !getchar(1)
                            " 		continue
                            " 	endif
                            "
                            " 	call self.__input(s:getchar(0))
                            " 	call self.draw()
                            
                            	call self.callevent("on_update")
                            	call self.__inputting()
                            " 	call self.__input(s:Input.getchar())
                            	if self.is_exit()
                            		return -1
                            	endif
                            	call self.draw()
                            endfunction
                            
                            
    1              0.000002 function! s:base.__main(...)
                            	try
                            		call self.__init()
                            		call self.callevent("on_enter")
                            
                            		call self.__input(get(a:, 1, ""))
                            		call self.draw()
                            		while !self.is_exit()
                            			try
                            				if self.__update()
                            					break
                            				endif
                            			catch
                            				call self.callevent("on_exception")
                            			endtry
                            		endwhile
                            	catch
                            		echohl ErrorMsg | echom v:throwpoint . " " . v:exception | echohl None
                            		let self.variables.exit_code = -1
                            	finally
                            		call self.__finish()
                            		call self.callevent("on_leave")
                            	endtry
                            	return self.exit_code()
                            endfunction
                            
                            
    1              0.000002 function! s:base.__finish()
                            	call self.hl_cursor_on()
                            endfunction
                            
                            
    1              0.000002 function! s:base.__is_exit()
                            	return self.is_exit()
                            endfunction
                            
                            
    1              0.000002 function! s:base.is_exit()
                            	return self.variables.exit
                            endfunction
                            
                            
    1              0.000002 function! s:base.__get_keymapping()
                            	let result = {}
                            " 	for module in values(self.variables.modules)
                            	for module in self.variables.modules.slots()
                            		if has_key(module, "keymapping")
                            			if module isnot self
                            				call extend(result, module.keymapping(self))
                            			endif
                            		endif
                            	endfor
                            	return extend(extend(result, self.variables.keymapping), self.keymapping())
                            endfunction
                            
                            
    1   0.000022   0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim
Sourced 1 time
Total time:   0.000456
 Self time:   0.000374

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000132   0.000054 execute join(['function! vital#_incsearch#Over#String#import() abort', printf("return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000047 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:List = s:V.import("Data.List")
                            endfunction
                            
                            
    1              0.000006 function! s:_vital_depends()
                            	return [
                            \		"Data.List",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:_clamp(x, max, min)
                            	return min([max([a:x, a:max]), a:min])
                            endfunction
                            
                            
    1              0.000005 let s:base = {}
                            
    1              0.000003 function! s:base.set(item)
                            	return type(a:item) == type("") ? self.set_str(a:item)
                            \		 : type(a:item) == type(0)  ? self.set_pos(a:item)
                            \		 : self
                            endfunction
                            
    1              0.000003 function! s:base.str()
                            	return join(self.list, "")
                            endfunction
                            
    1              0.000002 function! s:base.set_pos(pos)
                            	let self.col = s:_clamp(a:pos, 0, self.length())
                            	return self
                            endfunction
                            
    1              0.000003 function! s:base.backward()
                            	return self.col > 0 ? join(self.list[ : self.col-1], '') : ""
                            endfunction
                            
    1              0.000003 function! s:base.forward()
                            	return join(self.list[self.col+1 : ], '')
                            endfunction
                            
    1              0.000003 function! s:base.pos_char()
                            	return get(self.list, self.col, "")
                            endfunction
                            
    1              0.000002 function! s:base.set_str(str)
                            	let self.list = split(a:str, '\zs')
                            	let self.col  = strchars(a:str)
                            	return self
                            endfunction
                            
    1              0.000002 function! s:base.pos()
                            	return self.col
                            endfunction
                            
    1              0.000002 function! s:base.input(str)
                            	call extend(self.list, split(a:str, '\zs'), self.col)
                            	let self.col += len(split(a:str, '\zs'))
                            	return self
                            endfunction
                            
    1              0.000002 function! s:base.length()
                            	return len(self.list)
                            endfunction
                            
    1              0.000002 function! s:base.next()
                            	return self.set_pos(self.col + 1)
                            endfunction
                            
    1              0.000002 function! s:base.prev()
                            	return self.set_pos(self.col - 1)
                            endfunction
                            
    1              0.000002 function! s:base.remove(index)
                            	if a:index < 0 || self.length() <= a:index
                            		return ""
                            	endif
                            	let result = self.list[a:index]
                            	unlet self.list[a:index]
                            	if a:index < self.col
                            		call self.set(self.col - 1)
                            	endif
                            	return result
                            endfunction
                            
    1              0.000002 function! s:base.remove_pos()
                            	return self.remove(self.col)
                            endfunction
                            
    1              0.000002 function! s:base.remove_prev()
                            	return self.remove(self.col - 1)
                            endfunction
                            
    1              0.000002 function! s:base.remove_next()
                            	return self.remove(self.col + 1)
                            endfunction
                            
                            
    1              0.000002 function! s:make(...)
                            	let default = get(a:, 1, "")
                            	let result = deepcopy(s:base)
                            	call result.set(default)
                            	return result
                            endfunction
                            
                            " NOTE: old regexpengine has a bug with string which contains binary
                            " :echo "\x80" =~ "\\%#=1\x80"   | " => 0
                            " But it matches correctly with :h /collection
                            " :echo "\x80" =~ "\\%#=1[\x80]" | " => 1
                            " http://lingr.com/room/vim/archives/2015/02/13#message-21261450
    1              0.000008 let s:_engine = exists("+regexpengine") ? '\%#=2' : ''
                            " \<A-]> => √õ\xfdQ
                            " \<A-@> => √Ä\xfeX
    1              0.000011 let s:_regex = exists("+regexpengine")
                            \	? "\\%(√õ\xfdQ\\|√Ä\xfeX\\|\x80\xfc.\\%(\x80..\\|.\\)\\|\x80..\\|.\\)\\zs"
                            \	: "\\%(√õ[\xfd]Q\\|√Ä[\xfe]X\\|[\x80][\xfc].\\%([\x80]..\\|.\\)\\|[\x80]..\\|.\\)\\zs"
    1              0.000004 function! s:_split_keystring(str, ...)
                            	return split(a:str, s:_engine . '\m\%(' . get(a:, 1, '') . s:_regex . '\)')
                            endfunction
                            
    1              0.000004 function! s:split_by_keys(str)
                            	return s:_split_keystring(a:str, "\\%(\<Plug>\\|<Over>\\)(.\\{-})\\zs\\|")
                            endfunction
                            
    1              0.000003 function! s:index(haystack, needle, ...)
                            	let start = get(a:, 1, 0)
                            	let ignorecase = get(a:, 2, &ignorecase)
                            	if ignorecase
                            		return stridx(tolower(a:haystack), tolower(a:needle), start)
                            	else
                            		return stridx(a:haystack, a:needle, start)
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:length(str)
                            	return len(s:split_by_keys(a:str))
                            endfunction
                            
                            
    1   0.000020   0.000018 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/List.vim
Sourced 1 time
Total time:   0.000714
 Self time:   0.000691

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000099   0.000080 execute join(['function! vital#_incsearch#Data#List#import() abort', printf("return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'shift': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'drop_while': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'map_accum': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
                            " Utilities for list.
                            
    1              0.000013 let s:save_cpo = &cpo
    1   0.000017   0.000015 set cpo&vim
                            
    1              0.000004 function! s:pop(list) abort
                              return remove(a:list, -1)
                            endfunction
                            
    1              0.000004 function! s:push(list, val) abort
                              call add(a:list, a:val)
                              return a:list
                            endfunction
                            
    1              0.000003 function! s:shift(list) abort
                              return remove(a:list, 0)
                            endfunction
                            
    1              0.000004 function! s:unshift(list, val) abort
                              return insert(a:list, a:val)
                            endfunction
                            
    1              0.000003 function! s:cons(x, xs) abort
                              return [a:x] + a:xs
                            endfunction
                            
    1              0.000003 function! s:conj(xs, x) abort
                              return a:xs + [a:x]
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000003 function! s:uniq(list) abort
                              return s:uniq_by(a:list, 'v:val')
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000003 function! s:uniq_by(list, f) abort
                              let list = map(copy(a:list), printf('[v:val, %s]', a:f))
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction
                            
    1              0.000003 function! s:clear(list) abort
                              if !empty(a:list)
                                unlet! a:list[0 : len(a:list) - 1]
                              endif
                              return a:list
                            endfunction
                            
                            " Concatenates a list of lists.
                            " XXX: Should we verify the input?
    1              0.000003 function! s:concat(list) abort
                              let memo = []
                              for Value in a:list
                                let memo += Value
                              endfor
                              return memo
                            endfunction
                            
                            " Take each elements from lists to a new list.
    1              0.000004 function! s:flatten(list, ...) abort
                              let limit = a:0 > 0 ? a:1 : -1
                              let memo = []
                              if limit == 0
                                return a:list
                              endif
                              let limit -= 1
                              for Value in a:list
                                let memo +=
                                      \ type(Value) == type([]) ?
                                      \   s:flatten(Value, limit) :
                                      \   [Value]
                                unlet! Value
                              endfor
                              return memo
                            endfunction
                            
                            " Sorts a list with expression to compare each two values.
                            " a:a and a:b can be used in {expr}.
    1              0.000003 function! s:sort(list, expr) abort
                              if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
                              let s:expr = a:expr
                              return sort(a:list, 's:_compare')
                            endfunction
                            
    1              0.000004 function! s:_compare(a, b) abort
                              return eval(s:expr)
                            endfunction
                            
                            " Sorts a list using a set of keys generated by mapping the values in the list
                            " through the given expr.
                            " v:val is used in {expr}
    1              0.000003 function! s:sort_by(list, expr) abort
                              let pairs = map(a:list, printf('[v:val, %s]', a:expr))
                              return map(s:sort(pairs,
                              \      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')
                            endfunction
                            
                            " Returns a maximum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
    1              0.000003 function! s:max_by(list, expr) abort
                              if empty(a:list)
                                return 0
                              endif
                              let list = map(copy(a:list), a:expr)
                              return a:list[index(list, max(list))]
                            endfunction
                            
                            " Returns a minimum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
                            " FIXME: -0x80000000 == 0x80000000
    1              0.000003 function! s:min_by(list, expr) abort
                              return s:max_by(a:list, '-(' . a:expr . ')')
                            endfunction
                            
                            " Returns List of character sequence between [a:from, a:to]
                            " e.g.: s:char_range('a', 'c') returns ['a', 'b', 'c']
    1              0.000003 function! s:char_range(from, to) abort
                              return map(
                              \   range(char2nr(a:from), char2nr(a:to)),
                              \   'nr2char(v:val)'
                              \)
                            endfunction
                            
                            " Returns true if a:list has a:value.
                            " Returns false otherwise.
    1              0.000003 function! s:has(list, value) abort
                              return index(a:list, a:value) isnot -1
                            endfunction
                            
                            " Returns true if a:list[a:index] exists.
                            " Returns false otherwise.
                            " NOTE: Returns false when a:index is negative number.
    1              0.000004 function! s:has_index(list, index) abort
                              " Return true when negative index?
                              " let index = a:index >= 0 ? a:index : len(a:list) + a:index
                              return 0 <= a:index && a:index < len(a:list)
                            endfunction
                            
                            " similar to Haskell's Data.List.span
    1              0.000003 function! s:span(f, xs) abort
                              let border = len(a:xs)
                              for i in range(len(a:xs))
                                if !eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  let border = i
                                  break
                                endif
                              endfor
                              return border == 0 ? [[], copy(a:xs)] : [a:xs[: border - 1], a:xs[border :]]
                            endfunction
                            
                            " similar to Haskell's Data.List.break
    1              0.000003 function! s:break(f, xs) abort
                              return s:span(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Data.List.takeWhile
    1              0.000003 function! s:take_while(f, xs) abort
                              return s:span(a:f, a:xs)[0]
                            endfunction
                            
                            " similar to Haskell's Data.List.dropWhile
    1              0.000003 function! s:drop_while(f, xs) abort
                              return s:span(a:f, a:xs)[1]
                            endfunction
                            
                            " similar to Haskell's Data.List.partition
    1              0.000004 function! s:partition(f, xs) abort
                              return [filter(copy(a:xs), a:f), filter(copy(a:xs), '!(' . a:f . ')')]
                            endfunction
                            
                            " similar to Haskell's Prelude.all
    1              0.000003 function! s:all(f, xs) abort
                              return !s:any(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.any
    1              0.000003 function! s:any(f, xs) abort
                              return !empty(filter(map(copy(a:xs), a:f), 'v:val'))
                            endfunction
                            
                            " similar to Haskell's Prelude.and
    1              0.000003 function! s:and(xs) abort
                              return s:all('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.or
    1              0.000003 function! s:or(xs) abort
                              return s:any('v:val', a:xs)
                            endfunction
                            
    1              0.000004 function! s:map_accum(expr, xs, init) abort
                              let memo = []
                              let init = a:init
                              for x in a:xs
                                let expr = substitute(a:expr, 'v:memo', init, 'g')
                                let expr = substitute(expr, 'v:val', x, 'g')
                                let [tmp, init] = eval(expr)
                                call add(memo, tmp)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl
    1              0.000003 function! s:foldl(f, init, xs) abort
                              let memo = a:init
                              for x in a:xs
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl1
    1              0.000003 function! s:foldl1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldl1'
                              endif
                              return s:foldl(a:f, a:xs[0], a:xs[1:])
                            endfunction
                            
                            " similar to Haskell's Prelude.foldr
    1              0.000004 function! s:foldr(f, init, xs) abort
                              return s:foldl(a:f, a:init, reverse(copy(a:xs)))
                            endfunction
                            
                            " similar to Haskell's Prelude.fold11
    1              0.000003 function! s:foldr1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldr1'
                              endif
                              return s:foldr(a:f, a:xs[-1], a:xs[0:-2])
                            endfunction
                            
                            " similar to python's zip()
    1              0.000002 function! s:zip(...) abort
                              return map(range(min(map(copy(a:000), 'len(v:val)'))), "map(copy(a:000), 'v:val['.v:val.']')")
                            endfunction
                            
                            " similar to zip(), but goes until the longer one.
    1              0.000004 function! s:zip_fill(xs, ys, filler) abort
                              if empty(a:xs) && empty(a:ys)
                                return []
                              elseif empty(a:ys)
                                return s:cons([a:xs[0], a:filler], s:zip_fill(a:xs[1 :], [], a:filler))
                              elseif empty(a:xs)
                                return s:cons([a:filler, a:ys[0]], s:zip_fill([], a:ys[1 :], a:filler))
                              else
                                return s:cons([a:xs[0], a:ys[0]], s:zip_fill(a:xs[1 :], a:ys[1: ], a:filler))
                              endif
                            endfunction
                            
                            " Inspired by Ruby's with_index method.
    1              0.000003 function! s:with_index(list, ...) abort
                              let base = a:0 > 0 ? a:1 : 0
                              return map(copy(a:list), '[v:val, v:key + base]')
                            endfunction
                            
                            " similar to Ruby's detect or Haskell's find.
    1              0.000003 function! s:find(list, default, f) abort
                              let l:Call = type(a:f) is type(function('function'))
                              \          ? function('call')
                              \          : function('s:_call_string_expr')
                            
                              for x in a:list
                                if l:Call(a:f, [x])
                                  return x
                                endif
                              endfor
                              return a:default
                            endfunction
                            
    1              0.000004 function! s:_call_string_expr(expr, args) abort
                              return map([a:args[0]], a:expr)[0]
                            endfunction
                            
                            " Returns the index of the first element which satisfies the given expr.
    1              0.000004 function! s:find_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction
                            
                            " Returns the index of the last element which satisfies the given expr.
    1              0.000004 function! s:find_last_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : len - 1
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, 0, -1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction
                            
                            " Similar to find_index but returns the list of indices satisfying the given expr.
    1              0.000004 function! s:find_indices(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let result = []
                              if start >=# len || start < 0
                                return result
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  call add(result, i)
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " Return non-zero if a:list1 and a:list2 have any common item(s).
                            " Return zero otherwise.
    1              0.000004 function! s:has_common_items(list1, list2) abort
                              return !empty(filter(copy(a:list1), 'index(a:list2, v:val) isnot -1'))
                            endfunction
                            
    1              0.000003 function! s:intersect(list1, list2) abort
                              let items = []
                              " for funcref
                              for X in a:list1
                                if index(a:list2, X) != -1 && index(items, X) == -1
                                  let items += [X]
                                endif
                              endfor
                              return items
                            endfunction
                            
                            " similar to Ruby's group_by.
    1              0.000003 function! s:group_by(xs, f) abort
                              let result = {}
                              let list = map(copy(a:xs), printf('[v:val, %s]', a:f))
                              for x in list
                                let Val = x[0]
                                let key = type(x[1]) !=# type('') ? string(x[1]) : x[1]
                                if has_key(result, key)
                                  call add(result[key], Val)
                                else
                                  let result[key] = [Val]
                                endif
                                unlet Val
                              endfor
                              return result
                            endfunction
                            
    1              0.000004 function! s:_default_compare(a, b) abort
                              return a:a <# a:b ? -1 : a:a ># a:b ? 1 : 0
                            endfunction
                            
    1              0.000004 function! s:binary_search(list, value, ...) abort
                              let Predicate = a:0 >= 1 ? a:1 : 's:_default_compare'
                              let dic = a:0 >= 2 ? a:2 : {}
                              let start = 0
                              let end = len(a:list) - 1
                            
                              while 1
                                if start > end
                                  return -1
                                endif
                            
                                let middle = (start + end) / 2
                            
                                let compared = call(Predicate, [a:value, a:list[middle]], dic)
                            
                                if compared < 0
                                  let end = middle - 1
                                elseif compared > 0
                                  let start = middle + 1
                                else
                                  return middle
                                endif
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:product(lists) abort
                              let result = [[]]
                              for pool in a:lists
                                let tmp = []
                                for x in result
                                  let tmp += map(copy(pool), 'x + [v:val]')
                                endfor
                                let result = tmp
                              endfor
                              return result
                            endfunction
                            
    1              0.000003 function! s:permutations(list, ...) abort
                              if a:0 > 1
                                throw 'vital: Data.List: too many arguments'
                              endif
                              let r = a:0 == 1 ? a:1 : len(a:list)
                              if r > len(a:list)
                                return []
                              elseif r < 0
                                throw 'vital: Data.List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:product(map(range(r), 'range(n)'))
                                if len(s:uniq(indices)) == r
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction
                            
    1              0.000004 function! s:combinations(list, r) abort
                              if a:r > len(a:list)
                                return []
                              elseif a:r < 0
                                throw 'vital: Data.List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:permutations(range(n), a:r)
                                if s:sort(copy(indices), 'a:a - a:b') == indices
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim
Sourced 1 time
Total time:   0.000287
 Self time:   0.000265

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000053   0.000035 execute join(['function! vital#_incsearch#Over#Signals#import() abort', printf("return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:L = s:V.import("Data.List")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return ["Data.List"]
                            endfunction
                            
                            
    1              0.000009 let s:base = {
                            \	"variables" : {
                            \		"slots" : [],
                            \		"counter" : 0,
                            \	}
                            \}
                            
                            
    1              0.000003 function! s:base.connect(slot)
                            	let self.variables.counter += 1
                            	let slot = { "id" : self.variables.counter, "slot" : a:slot }
                            	call add(self.variables.slots, slot)
                            	return slot
                            endfunction
                            
                            
    1              0.000002 function! s:base.disconnect(slot)
                            	if empty(a:slot)
                            		return -1
                            	endif
                            	for i in range(len(self.variables.slots))
                            		if self.variables.slots[i].id == a:slot.id
                            			unlet self.variables.slots[i]
                            			return
                            		endif
                            	endfor
                            	return -1
                            endfunction
                            
                            
    1              0.000002 function! s:base.disconnect_by(expr)
                            	return self.disconnect(self.find_first_by(a:expr))
                            endfunction
                            
                            
    1              0.000003 function! s:call(list, func, ...)
                            	let args = get(a:, 1, [])
                            	let def = get(a:, 2, 0)
                            	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")
                            endfunction
                            
    1              0.000003 function! s:base.call(func, ...)
                            	return call("s:call", [self.slots(), a:func] + a:000)
                            endfunction
                            
                            
    1              0.000002 function! s:base.find_by(expr)
                            	return filter(copy(self.variables.slots), a:expr)
                            endfunction
                            
                            
    1              0.000002 function! s:base.find_first_by(expr)
                            	return get(self.find_by(a:expr), 0, {})
                            endfunction
                            
                            
    1              0.000003 function! s:base.sort_by(expr)
                            	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_slot(val)
                            	return a:val.slot
                            endfunction
                            
                            
    1              0.000002 function! s:base.slots()
                            	return map(copy(self.variables.slots), "self.get_slot(v:val)")
                            endfunction
                            
                            
                            " function! s:base.dict()
                            " 	let result = {}
                            " 	for _ in self.variables.slots
                            " 		let result[_.id] = _.value
                            " 	endfor
                            " 	return result
                            " endfunction
                            
                            
    1              0.000002 function! s:make()
                            	let result = deepcopy(s:base)
                            	return result
                            endfunction
                            
                            
    1   0.000061   0.000058 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Input.vim
Sourced 1 time
Total time:   0.000159
 Self time:   0.000131

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000062   0.000038 execute join(['function! vital#_incsearch#Over#Input#import() abort', printf("return map({'getchar': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000003 function! s:getchar(...)
                            	let mode = get(a:, 1, 0)
                            	while 1
                            		" Workaround for https://github.com/osyo-manga/vital-over/issues/53
                            		try
                            			let char = call("getchar", a:000)
                            		catch /^Vim:Interrupt$/
                            			let char = 3 " <C-c>
                            		endtry
                            		" Workaround for the <expr> mappings
                            		if string(char) !=# "\x80\xfd`"
                            			return mode == 1 ? !!char
                            \				 : type(char) == type(0) ? nr2char(char) : char
                            		endif
                            	endwhile
                            endfunction
                            
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim
Sourced 1 time
Total time:   0.000343
 Self time:   0.000322

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000054   0.000038 execute join(['function! vital#_incsearch#Over#Keymapping#import() abort', printf("return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
    1              0.000002 scriptencoding utf-8
    1              0.000011 let s:save_cpo = &cpo
    1   0.000017   0.000015 set cpo&vim
                            
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:as_key_config(config)
                            	let base = {
                            \		"noremap" : 0,
                            \		"lock"    : 0,
                            \		"expr"    : 0,
                            \	}
                            	return type(a:config) == type({}) ? extend(base, a:config)
                            \		 : extend(base, {
                            \		 	"key" : a:config,
                            \		 })
                            endfunction
                            
                            
    1              0.000003 function! s:match_key(keymapping, key)
                            	let keys = sort(keys(a:keymapping))
                            	return get(filter(keys, 'stridx(a:key, v:val) == 0'), -1, '')
                            endfunction
                            
                            
    1              0.000003 function! s:_safe_eval(expr, ...)
                            	call extend(l:, get(a:, 1, {}))
                            	let result = get(a:, 2, "")
                            	try
                            		let result = eval(a:expr)
                            	catch
                            		echohl ErrorMsg | echom v:exception | echohl None
                            	endtry
                            	return result
                            endfunction
                            
                            
    1              0.000003 function! s:_get_key(conf)
                            " 	call extend(l:, a:conf)
                            	let self = a:conf
                            	return get(a:conf, "expr", 0) ? s:_safe_eval(a:conf.key, l:) : a:conf.key
                            endfunction
                            
                            
    1              0.000004 function! s:unmapping(keymapping, key, ...)
                            	let is_locking = get(a:, 1, 0)
                            	let key = s:match_key(a:keymapping, a:key)
                            	if key == ""
                            		return s:String.length(a:key) <= 1 ? a:key : s:unmapping(a:keymapping, a:key[0], is_locking) . s:unmapping(a:keymapping, a:key[1:], is_locking)
                            	endif
                            
                            	let map_conf = s:as_key_config(a:keymapping[key])
                            
                            	let next_input = s:unmapping(a:keymapping, a:key[len(key) : ], is_locking)
                            	if map_conf.lock == 0 && is_locking
                            		return key . next_input
                            	elseif map_conf.lock
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), is_locking) . next_input
                            	else
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), map_conf.noremap) . next_input
                            	endif
                            endfunction
                            
                            
                            
    1   0.000055   0.000052 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules.vim
Sourced 1 time
Total time:   0.000156
 Self time:   0.000135

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000056   0.000038 execute join(['function! vital#_incsearch#Over#Commandline#Modules#import() abort', printf("return map({'get': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000017   0.000015 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            endfunction
                            
                            
    1              0.000003 function! s:get(name)
                            	if exists("s:" . a:name)
                            		return s:{a:name}
                            	endif
                            	let s:{a:name} = s:V.import('Over.Commandline.Modules.' . a:name)
                            	return s:{a:name}
                            endfunction
                            
                            
    1              0.000003 function! s:make(name, ...)
                            	let module = s:get(a:name)
                            	return call(module.make, a:000, module)
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Highlight.vim
Sourced 1 time
Total time:   0.000271
 Self time:   0.000251

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000065   0.000047 execute join(['function! vital#_incsearch#Palette#Highlight#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Message  = s:V.import("Vim.Message")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Vim.Message",
                            \	]
                            endfunction
                            
                            
    1              0.000003 function! s:_execute(cmd)
                            	execute a:cmd
                            endfunction
                            
                            
    1              0.000003 function! s:capture(name)
                            	if hlexists(a:name) == 0
                            		return ""
                            	endif
                            	return s:Message.capture("highlight " . a:name)
                            endfunction
                            
                            
    1              0.000003 function! s:links_to(highlight)
                            	return matchstr(a:highlight, '^\S\+\s\+xxx links to \zs.*\ze$')
                            endfunction
                            
                            
    1              0.000004 function! s:parse_to_name(highlight)
                            	return matchstr(a:highlight, '^\zs\w\+\ze')
                            endfunction
                            
                            
    1              0.000003 function! s:parse(highlight)
                            	let highlight = a:highlight
                            	
                            	if highlight !~# '^\w\+\s\+xxx\s'
                            		return {}
                            	endif
                            
                            	let name = s:parse_to_name(a:highlight)
                            	let result = { "_name" : name }
                            
                            	if highlight =~# '^\w\+\s\+xxx cleared'
                            		let result.cleared = 1
                            		return result
                            	endif
                            
                            	let link = s:links_to(highlight)
                            	if link != ""
                            		let result.link = link
                            		return result
                            	endif
                            
                            	let attrs = [
                            \		"term",
                            \		"cterm",
                            \		"ctermfg",
                            \		"ctermbg",
                            \		"gui",
                            \		"font",
                            \		"guifg",
                            \		"guibg",
                            \		"guisp",
                            \	]
                            	for attr in attrs
                            		let item = matchstr(highlight, '\s' . attr . '=\zs#\?\w\+\ze')
                            		if item != ""
                            			let result[attr] = item
                            		endif
                            	endfor
                            	return result
                            endfunction
                            
                            
    1              0.000003 function! s:get(name, ...)
                            	if !hlexists(a:name)
                            		return {}
                            	endif
                            	let result = s:parse(substitute(s:capture(a:name), "\n", "", "g"))
                            	if has_key(result, "link") && get(a:, 1, 0)
                            		return s:get(result.link, get(a:, 1, 0))
                            	else
                            		return result
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:set(name, config)
                            	if type(a:config) == type("")
                            		return s:set(a:config, s:get(a:config))
                            	endif
                            	if has_key(a:config, "cleared")
                            		return s:_execute("highlight clear " . a:name)
                            	endif
                            	if has_key(a:config, "link")
                            		return s:_execute("highlight link " . a:name . " " . a:config.link)
                            	endif
                            	return s:_execute("highlight " . a:name . " " . join(map(items(filter(a:config, "v:key !=# '_name'")), "v:val[0] . '=' . v:val[1]"), " "))
                            endfunction
                            
                            
    1              0.000003 function! s:group_list()
                            	let highlights = split(s:Message.capture("highlight"), "\n")
                            	return filter(map(highlights, "s:parse_to_name(v:val)"), "v:val != ''")
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Message.vim
Sourced 1 time
Total time:   0.000233
 Self time:   0.000210

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000069   0.000049 execute join(['function! vital#_incsearch#Vim#Message#import() abort', printf("return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000014 let s:save_cpo = &cpo
    1   0.000023   0.000021 set cpo&vim
                            
                            
                            
    1              0.000004 function! s:echo(hl, msg) abort
                              execute 'echohl' a:hl
                              try
                                echo a:msg
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000003 function! s:echomsg(hl, msg) abort
                              execute 'echohl' a:hl
                              try
                                for m in split(a:msg, "\n")
                                  echomsg m
                                endfor
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000004 function! s:error(msg) abort
                              call s:echomsg('ErrorMsg', a:msg)
                            endfunction
                            
    1              0.000003 function! s:warn(msg) abort
                              call s:echomsg('WarningMsg', a:msg)
                            endfunction
                            
    1              0.000003 function! s:capture(command) abort
                              try
                                redir => out
                                silent execute a:command
                              finally
                                redir END
                              endtry
                              return out
                            endfunction
                            
                            " * Get max length of |hit-enter|.
                            "   If a string length of a message is greater than the max length,
                            "   Vim waits for user input according to |hit-enter|.
                            " XXX: Those fixed values may be different between different OSes?
                            "      Currently tested on only Windows.
    1              0.000005 function! s:get_hit_enter_max_length() abort
                              let maxlen = &columns * &cmdheight - 1
                              if &ruler
                                " TODO
                              endif
                              if &showcmd
                                let maxlen -= 11
                              endif
                              return maxlen
                            endfunction
                            
                            
                            
    1   0.000018   0.000017 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim
Sourced 1 time
Total time:   0.000321
 Self time:   0.000301

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000064   0.000046 execute join(['function! vital#_incsearch#Over#Commandline#Modules#BufferComplete#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000020   0.000019 set cpo&vim
                            
                            
    1              0.000003 function! s:_uniq(list)
                            	let dict = {}
                            	for _ in a:list
                            		let dict[_] = 0
                            	endfor
                            	return keys(dict)
                            endfunction
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "BufferComplete",
                            \}
                            
                            
    1              0.000004 function! s:_buffer_complete()
                            	return sort(s:_uniq(filter(split(join(getline(1, '$')), '\W'), '!empty(v:val)')), 1)
                            endfunction
                            
                            
    1              0.000003 function! s:_parse_line(line)
                            	let keyword = matchstr(a:line, '\zs\w\+\ze$')
                            	let pos = strchars(a:line) - strchars(keyword)
                            	return [pos, keyword]
                            endfunction
                            
                            
    1              0.000004 function! s:_as_statusline(list, count)
                            	if empty(a:list)
                            		return
                            	endif
                            	let hl_none = "%#StatusLine#"
                            	let hl_select = "%#StatusLineNC#"
                            	let tail = " > "
                            	let result = a:list[0]
                            	let pos = 0
                            	for i in range(1, len(a:list)-1)
                            		if strdisplaywidth(result . " " . a:list[i]) > &columns - len(tail)
                            			if a:count < i
                            				break
                            			else
                            				let pos = -i
                            			endif
                            			let result = a:list[i]
                            		else
                            			let result .= (" " . a:list[i])
                            		endif
                            		if a:count == i
                            			let pos = pos + i
                            		endif
                            	endfor
                            	return join(map(split(result, " "), 'v:key == pos ? hl_select . v:val . hl_none : v:val'))
                            endfunction
                            
                            
    1              0.000003 function! s:module.get_complete_words()
                            	return s:_buffer_complete()
                            endfunction
                            
                            
    1              0.000003 function! s:module.complete(cmdline)
                            	call s:_finish()
                            	let s:old_statusline = &statusline
                            
                            	let backward = a:cmdline.backward()
                            	let [pos, keyword] = s:_parse_line(backward)
                            
                            	if !exists("s:complete")
                            		let s:complete = self.get_complete_words()
                            	endif
                            	let s:complete_list = filter(copy(s:complete), 'v:val =~ ''^''.keyword')
                            	if empty(s:complete_list)
                            		return -1
                            	endif
                            
                            	if pos == 0
                            		let backward = ""
                            	else
                            		let backward = join(split(backward, '\zs')[ : pos-1 ], "")
                            	endif
                            	let s:line = backward . a:cmdline.forward()
                            	let s:pos = pos
                            	call a:cmdline.setline(s:line)
                            
                            	let s:count = 0
                            endfunction
                            
                            
    1              0.000003 function! s:_finish()
                            	if exists("s:old_statusline")
                            		let &statusline = s:old_statusline
                            		unlet s:old_statusline
                            		redrawstatus
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(buffer-complete)")
                            \		|| a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            		if self.complete(a:cmdline) == -1
                            			call s:_finish()
                            			call a:cmdline.setchar('')
                            			return
                            		endif
                            		if a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            		call a:cmdline.setchar('')
                            		call a:cmdline.tap_keyinput("Completion")
                            " 	elseif a:cmdline.is_input("\<Tab>", "Completion")
                            	elseif a:cmdline.is_input("<Over>(buffer-complete)", "Completion")
                            \		|| a:cmdline.is_input("\<Right>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count += 1
                            		if s:count >= len(s:complete_list)
                            			let s:count = 0
                            		endif
                            	elseif a:cmdline.is_input("<Over>(buffer-complete-prev)", "Completion")
                            \		|| a:cmdline.is_input("\<Left>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count -= 1
                            		if s:count < 0
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            	else
                            		if a:cmdline.untap_keyinput("Completion")
                            			call a:cmdline.callevent("on_char_pre")
                            		endif
                            		call s:_finish()
                            		return
                            	endif
                            	call a:cmdline.setline(s:line)
                            	call a:cmdline.insert(s:complete_list[s:count], s:pos)
                            	if len(s:complete_list) > 1
                            		let &statusline = s:_as_statusline(s:complete_list, s:count)
                            		redrawstatus
                            	endif
                            	if len(s:complete_list) == 1
                            		call a:cmdline.untap_keyinput("Completion")
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_draw_pre(...)
                            " 	redrawstatus
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_leave(cmdline)
                            	call s:_finish()
                            	unlet! s:complete
                            endfunction
                            
    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Cancel.vim
Sourced 1 time
Total time:   0.000195
 Self time:   0.000166

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000076   0.000052 execute join(['function! vital#_incsearch#Over#Commandline#Modules#Cancel#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000023   0.000020 set cpo&vim
                            
    1              0.000006 let s:module = {
                            \	"name" : "Cancel"
                            \}
                            
    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<Esc>")
                            \	|| a:cmdline.is_input("\<C-c>")
                            " 		call a:cmdline.cancel()
                            		call a:cmdline.exit(1)
                            		call a:cmdline.setchar("")
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000019   0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/CursorMove.vim
Sourced 1 time
Total time:   0.000173
 Self time:   0.000153

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000059   0.000042 execute join(['function! vital#_incsearch#Over#Commandline#Modules#CursorMove#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
                            
    1              0.000005 let s:module = {
                            \	"name" : "CursorMove"
                            \}
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<Right>")
                            		call a:cmdline.line.next()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<Left>")
                            		call a:cmdline.line.prev()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-b>")
                            \		|| a:cmdline.is_input("\<Home>")
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-e>")
                            \		|| a:cmdline.is_input("\<End>")
                            		call a:cmdline.setline(a:cmdline.line.length())
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-Left>")
                            \		|| a:cmdline.is_input("\<S-Left>")
                            		call a:cmdline.setline(strridx(a:cmdline.backward()[:-2], ' ') + 1)
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-Right>")
                            \		|| a:cmdline.is_input("\<S-Right>")
                            		let p = stridx(a:cmdline.forward()[1:], ' ')
                            		call a:cmdline.setline(p != -1 ? a:cmdline.line.pos() + p + 2 : a:cmdline.line.length())
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000016   0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim
Sourced 1 time
Total time:   0.000245
 Self time:   0.000225

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000061   0.000044 execute join(['function! vital#_incsearch#Over#Commandline#Modules#Digraphs#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'digraph': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000017 set cpo&vim
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:Input = a:V.import("Over.Input")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Over.Input",
                            \	]
                            endfunction
                            
                            
    1              0.000007 let s:module = {
                            \	"name" : "Digraphs",
                            \	"digraphs" : {}
                            \}
                            
    1              0.000003 function! s:capture(cmd)
                            	let verbose_save = &verbose
                            	let &verbose = 0
                            	try
                            		redir => result
                            		execute "silent!" a:cmd
                            		redir END
                            	finally
                            		let &verbose = verbose_save
                            	endtry
                            	return result
                            endfunction
                            
    1              0.000003 function! s:digraph() abort
                            	let x = split(substitute(s:capture(':digraph'), "\n", ' ', 'g'),
                            	\   '[[:graph:]]\{2}\s.\{1,4}\s\+\d\+\s*\zs')
                            	let digraphs = map(x, "split(v:val, ' \\+')")
                            	let r = {}
                            	for d in digraphs
                            		let r[d[0]] = len(d) is 3 && d[2] =~# '\d\+' ? nr2char(str2nr(d[2],10))
                            		\   : len(d) is 2 && d[1] =~# '32' ? nr2char(str2nr(d[1],10))
                            		\   : ''
                            	endfor
                            	return r
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_leave(cmdline)
                            	" Delete cache to handle additional digraphs definition
                            	let self.digraphs = {}
                            endfunction
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-k>")
                            		if empty(self.digraphs)
                            			" Get digraphs when inputting <C-k> instead of on_enter because it cause
                            			" flicker in some environments #107
                            			let self.digraphs = s:digraph()
                            		endif
                            		call a:cmdline.setchar('?')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
                            	elseif exists("self.prefix_key")
                            \		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let x = a:cmdline.input_key()
                            		let y = s:Input.getchar()
                            		" For CTRL-K, there is one general digraph: CTRL-K <Space> {char} will
                            		" enter {char} with the highest bit set.  You can use this to enter
                            		" meta-characters.
                            		let char = x ==# "\<Space>" ?
                            		\	nr2char(char2nr(y) + 128) : get(self.digraphs, x . y, y)
                            		call a:cmdline.setchar(char)
                            	endif
                            endfunction
                            
    1              0.000003 function! s:module.on_char(cmdline)
                            	if a:cmdline.is_input("\<C-k>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
                            	else
                            		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
                            		endif
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Delete.vim
Sourced 1 time
Total time:   0.000178
 Self time:   0.000156

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000058   0.000039 execute join(['function! vital#_incsearch#Over#Commandline#Modules#Delete#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "Delete",
                            \}
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-h>")
                            \	|| a:cmdline.is_input("\<BS>")
                            		if a:cmdline.line.length() == 0
                            			return a:cmdline.exit(1)
                            		else
                            			call a:cmdline.line.remove_prev()
                            			call a:cmdline.setchar('')
                            		endif
                            	elseif a:cmdline.is_input("\<Del>")
                            		call a:cmdline.line.remove_pos()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-w>")
                            		let word = a:cmdline.backward_word()
                            		let backward = a:cmdline.backward()[ : -strlen(word)-1 ]
                            		call a:cmdline.setline(backward . a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(strchars(backward))
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-u>")
                            		call a:cmdline.setline(a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000016   0.000015 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim
Sourced 1 time
Total time:   0.000290
 Self time:   0.000270

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000054   0.000036 execute join(['function! vital#_incsearch#Over#Commandline#Modules#DrawCommandline#import() abort', printf("return map({'suffix': '', 'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
    1              0.000006 let s:module = {
                            \	"name" : "DrawCommandline"
                            \}
                            
    1              0.000003 let s:cmdheight = {}
                            
    1              0.000003 function! s:cmdheight.save()
                            	if has_key(self, "value")
                            		return
                            	endif
                            	let self.value = &cmdheight
                            endfunction
                            
    1              0.000003 function! s:cmdheight.restore()
                            	if has_key(self, "value")
                            		let &cmdheight = self.value
                            		unlet self.value
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:cmdheight.get()
                            	return self.value
                            endfunction
                            
                            
    1              0.000003 function! s:suffix(left, suffix)
                            	let left_len = strdisplaywidth(a:left)
                            	let len = &columns - left_len % &columns
                            	let len = len + (&columns * (strdisplaywidth(a:suffix) > (len - 1))) - 1
                            	return repeat(" ", len - strdisplaywidth(a:suffix)) . a:suffix
                            " 	return printf("%" . len . "S", a:suffix)
                            endfunction
                            
                            
    1              0.000003 let s:old_width = 0
    1              0.000004 function! s:_redraw(cmdline)
                            	let left = a:cmdline.get_prompt() . a:cmdline.getline() . (empty(a:cmdline.line.pos_char()) ? " " : "")
                            	let width = len(left) + 1
                            
                            	if a:cmdline.get_suffix() != ""
                            		let width += len(s:suffix(left, a:cmdline.get_suffix())) - 1
                            	endif
                            
                            	if &columns >= width && &columns <= s:old_width && s:old_width >= width
                            		redraw
                            		normal! :
                            	elseif &columns <= width
                            		normal! :
                            	else
                            		redraw
                            	endif
                            	let s:old_width = width
                            
                            	call s:cmdheight.save()
                            	let height = max([(width - 1) / (&columns) + 1, s:cmdheight.get()])
                            	if height > &cmdheight || &cmdheight > height
                            		let &cmdheight = height
                            		redraw
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:_as_echon(str)
                            	return "echon " . strtrans(string(a:str))
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_draw_pre(cmdline)
                            	if empty(a:cmdline.line.pos_char())
                            		let cursor = "echohl " . a:cmdline.highlights.cursor . " | echon ' '"
                            	else
                            		let cursor = "echohl " . a:cmdline.highlights.cursor_on . " | " . s:_as_echon(a:cmdline.line.pos_char())
                            	endif
                            	let suffix = ""
                            	if	a:cmdline.get_suffix() != ""
                            		let suffix = s:_as_echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            	endif
                            	let self.draw_command  = join([
                            \		"echohl " . a:cmdline.highlights.prompt,
                            \		s:_as_echon(a:cmdline.get_prompt()),
                            \		"echohl NONE",
                            \		s:_as_echon(a:cmdline.backward()),
                            \		cursor,
                            \		"echohl NONE",
                            \		s:_as_echon(a:cmdline.forward()),
                            \		suffix,
                            \	], " | ")
                            
                            	call s:_redraw(a:cmdline)
                            endfunction
                            
                            
    1              0.000003 function! s:_echon(expr)
                            	echon strtrans(a:expr)
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_draw(cmdline)
                            	execute self.draw_command
                            " 	execute "echohl" a:cmdline.highlights.prompt
                            " 	call s:echon(a:cmdline.get_prompt())
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.backward())
                            " 	if empty(a:cmdline.line.pos_char())
                            " 		execute "echohl" a:cmdline.highlights.cursor
                            " 		call s:echon(' ')
                            " 	else
                            " 		execute "echohl" a:cmdline.highlights.cursor_on
                            " 		call s:echon(a:cmdline.line.pos_char())
                            " 	endif
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.forward())
                            " 	if	a:cmdline.get_suffix() != ""
                            " 		call s:echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            " 	endif
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_execute_pre(...)
                            	call s:cmdheight.restore()
                            endfunction
                            
                            
    1              0.000002 function! s:module.on_leave(...)
                            	call s:cmdheight.restore()
                            endfunction
                            
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionExit.vim
Sourced 1 time
Total time:   0.000181
 Self time:   0.000152

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000072   0.000048 execute join(['function! vital#_incsearch#Over#Commandline#Modules#ExceptionExit#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000019   0.000016 set cpo&vim
                            
    1              0.000006 let s:module = {
                            \	"name" : "ExceptionExit",
                            \}
                            
                            
    1              0.000004 function! s:module.on_exception(cmdline)
                            	call a:cmdline.exit(-1)
                            endfunction
                            
                            
    1              0.000002 function! s:make(...)
                            	let result = deepcopy(s:module)
                            	let result.exit_code = get(a:, 1, 0)
                            	return result
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/LiteralInsert.vim
Sourced 1 time
Total time:   0.000170
 Self time:   0.000150

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000058   0.000041 execute join(['function! vital#_incsearch#Over#Commandline#Modules#LiteralInsert#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "LiteralInsert",
                            \}
                            
    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-v>")
                            \	|| a:cmdline.is_input("\<C-q>")
                            		let old_line = a:cmdline.getline()
                            		let old_pos  = a:cmdline.getpos()
                            		call a:cmdline.insert('^')
                            		call a:cmdline.setpos(old_pos)
                            		call a:cmdline.draw()
                            		let char = a:cmdline.getchar()
                            		call a:cmdline.setline(old_line)
                            		call a:cmdline.setpos(old_pos)
                            		call a:cmdline.setchar(char)
                            	endif
                            endfunction
                            
    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
    1   0.000018   0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/exit.vim
Sourced 1 time
Total time:   0.000106
 Self time:   0.000103

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/exit.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000004 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000020   0.000019 set cpo&vim
                            
                            " NOTE:
                            " <CR> in {rhs} wil be remapped even after exiting vital-over command line
                            " interface, so do not use <Over>(exit)
                            " See also s:cli.keymapping()
    1              0.000008 let s:incsearch_exit = {
                            \   'name' : 'IncsearchExit',
                            \   'exit_code' : 0
                            \}
    1              0.000004 function! s:incsearch_exit.on_char_pre(cmdline) abort
                              if   a:cmdline.is_input("\<CR>")
                              \ || a:cmdline.is_input("\<NL>")
                                call a:cmdline.setchar('')
                                call a:cmdline.exit(self.exit_code)
                              endif
                            endfunction
                            
    1              0.000004 function! incsearch#over#modules#exit#make() abort
                              return deepcopy(s:incsearch_exit)
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/insert_register.vim
Sourced 1 time
Total time:   0.001485
 Self time:   0.000146

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/insert_register.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000016   0.000015 set cpo&vim
                            
    1   0.000117   0.000017 let s:modules = vital#incsearch#import('Over.Commandline.Modules')
                            
    1   0.001258   0.000021 let s:InsertRegister = s:modules.get('InsertRegister').make()
    1              0.000010 let s:InsertRegister_orig_on_char_pre = s:InsertRegister.on_char_pre
    1              0.000004 let s:InsertRegister.search_register = ''
                            
    1              0.000003 function! s:InsertRegister.on_enter(...) abort
                              let self.search_register = @/
                            endfunction
                            
    1              0.000003 function! s:InsertRegister.on_char_pre(cmdline) abort
                              if exists('self.prefix_key') && a:cmdline.get_tap_key() == self.prefix_key
                                call a:cmdline.setline(self.old_line)
                                call a:cmdline.setpos(self.old_pos)
                                let char = a:cmdline.input_key()
                                if char ==# '/'
                                  let register = tr(self.search_register, "\n", "\r")
                                  call a:cmdline.setchar(register)
                                  return
                                endif
                              endif
                              return call(s:InsertRegister_orig_on_char_pre, [a:cmdline], self)
                            endfunction
                            
    1              0.000004 function! incsearch#over#modules#insert_register#make() abort
                              return deepcopy(s:InsertRegister)
                            endfunction
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/InsertRegister.vim
Sourced 1 time
Total time:   0.000366
 Self time:   0.000310

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000101   0.000048 execute join(['function! vital#_incsearch#Over#Commandline#Modules#InsertRegister#import() abort', printf("return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000029 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000005 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:to_string(expr)
                            	return type(a:expr) == type("") ? a:expr : string(a:expr)
                            endfunction
                            
                            
    1              0.000003 function! s:input(cmdline)
                            	let CR_index = index(a:cmdline.input_key_stack(), "\<CR>")
                            	if CR_index != -1
                            		let input = a:cmdline.input_key_stack_string()
                            		let input = input[ : CR_index-1]
                            		call a:cmdline.set_input_key_stack(a:cmdline.input_key_stack()[CR_index+1 : ])
                            		return eval(input)
                            	endif
                            
                            	let input_text = ""
                            	if !empty(a:cmdline.input_key_stack())
                            		let input_text = a:cmdline.input_key_stack_string()
                            		call a:cmdline.set_input_key_stack([])
                            	endif
                            
                            	call a:cmdline.hl_cursor_on()
                            	try
                            		redraw
                            		let input = input("=", input_text, "expression")
                            		if !empty(input)
                            			let input = s:to_string(eval(input))
                            		endif
                            	catch
                            		return ""
                            	finally
                            		call a:cmdline.hl_cursor_off()
                            	endtry
                            	return input
                            endfunction
                            
                            
    1              0.000007 let s:module = {
                            \	"name" : "InsertRegister"
                            \}
                            
                            
                            
    1              0.000003 function! s:module.reset()
                            	let self.cword = expand("<cword>")
                            	let self.cWORD = expand("<cWORD>")
                            	let self.cfile = expand("<cfile>")
                            endfunction
                            
    1              0.000003 function! s:module.on_enter(...)
                            	call self.reset()
                            " 	let self.prefix_key = ""
                            endfunction
                            
                            
    1              0.000005 function! s:get_cmdline_cword(backward, cword)
                            " 	let backward = matchstr(a:backward, '.\{-}\zs\k\+$')
                            	let backward = a:backward
                            	if &incsearch == 0 || a:cword == "" || a:backward == "" || s:String.index(a:cword, backward) != 0
                            		return a:cword
                            	endif
                            	return a:cword[len(backward) : ]
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.setchar('"')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
                            	elseif exists("self.prefix_key")
                            \		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let char = a:cmdline.input_key()
                            		if char =~ '^[0-9a-zA-z.%#:/"\-*+]$'
                            			let register = tr(getreg(char), "\n", "\r")
                            			call a:cmdline.setchar(register)
                            		elseif char == "="
                            			call a:cmdline.setchar(s:input(a:cmdline))
                            		elseif char == "\<C-w>"
                            			call a:cmdline.setchar(s:get_cmdline_cword(a:cmdline.backward_word(), self.cword))
                            		elseif char == "\<C-a>"
                            			call a:cmdline.setchar(self.cWORD)
                            		elseif char == "\<C-f>"
                            			call a:cmdline.setchar(self.cfile)
                            		elseif char == "\<C-r>"
                            			call a:cmdline.setchar('"')
                            		else
                            			call a:cmdline.setchar("")
                            		endif
                            " 		elseif a:cmdline.is_input('=', self.prefix_key)
                            " 			call a:cmdline.setchar(s:input(a:cmdline))
                            " 		elseif a:cmdline.is_input("\<C-w>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cword)
                            " 		elseif a:cmdline.is_input("\<C-a>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cWORD)
                            " 		elseif a:cmdline.is_input("\<C-f>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cfile)
                            " 		elseif a:cmdline.is_input("\<C-r>", self.prefix_key)
                            " 			call a:cmdline.setchar('"')
                            " 		else
                            " 			call a:cmdline.setchar("")
                            " 		endif
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_char(cmdline)
                            	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
                            	else
                            		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
                            		endif
                            	endif
                            endfunction
                            
                            
                            
    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
    1   0.000019   0.000018 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Paste.vim
Sourced 1 time
Total time:   0.000157
 Self time:   0.000137

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000052   0.000035 execute join(['function! vital#_incsearch#Over#Commandline#Modules#Paste#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000017   0.000015 set cpo&vim
                            
                            
    1              0.000006 let s:module = {
                            \	"name" : "Paste"
                            \}
                            
    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(paste)")
                            		let register = v:register == "" ? '"' : v:register
                            		call a:cmdline.insert(tr(getreg("*"), "\n", "\r"))
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim
Sourced 1 time
Total time:   0.000758
 Self time:   0.000725

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000150   0.000122 execute join(['function! vital#_incsearch#Over#Commandline#Modules#Doautocmd#import() abort', printf("return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000006 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000017 let s:save_cpo = &cpo
    1   0.000022   0.000020 set cpo&vim
                            
                            
    1              0.000005 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:E  = s:V.import("Over.Exception")
                            endfunction
                            
                            
    1              0.000005 function! s:_vital_depends()
                            	return [
                            \		"Over.Exception",
                            \	]
                            endfunction
                            
                            
    1              0.000006 let s:cache_command = {}
    1              0.000005 function! s:doautocmd_user(prefix, command)
                            	let group =  a:prefix . "-vital-over-commandline-doautocmd-dummy"
                            	if !has_key(s:cache_command, a:prefix)
                            		let s:cache_command[a:prefix] = {}
                            	endif
                            
                            	if !has_key(s:cache_command[a:prefix], a:command)
                            		execute "autocmd " . group
                            \			. " User " . a:command." silent! execute ''"
                            
                            		if v:version > 703 || v:version == 703 && has("patch438")
                            			let s:cache_command[a:prefix][a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:prefix][a:command] = "doautocmd User " . a:command
                            		endif
                            	endif
                            
                            	execute s:cache_command[a:prefix][a:command]
                            endfunction
                            
                            
    1              0.000016 let s:hooks = [
                            \	"enter",
                            \	"leave",
                            \	"char",
                            \	"char_pre",
                            \	"draw",
                            \	"draw_pre",
                            \	"execute_pre",
                            \	"execute_failed",
                            \	"execute",
                            \	"exception",
                            \]
                            
    1              0.000014 let s:hooks_camel = [
                            \	"Enter",
                            \	"Leave",
                            \	"Char",
                            \	"CharPre",
                            \	"Draw",
                            \	"DrawPre",
                            \	"ExecutePre",
                            \	"ExecuteFailed",
                            \	"Execute",
                            \	"Exception",
                            \]
                            
                            
    1              0.000007 let s:module = {
                            \	"name" : "Doautocmd",
                            \}
                            
                            
   11              0.000034 for s:i in range(len(s:hooks))
   10              0.000303 	execute join([
                            \		"function! s:module.on_" . s:hooks[s:i] . "(cmdline, ...)",
                            \		"	let s:cmdline = a:cmdline",
                            \		"	call s:doautocmd_user(self.prefix, self.prefix . " . string(s:hooks_camel[s:i]) . ")",
                            \		"endfunction",
                            \	], "\n")
   11              0.000017 endfor
                            
                            
    1              0.000004 function! s:get_cmdline()
                            	if !exists("s:cmdline")
                            		execute s:E.throw_cmd("Undefined cmdline object.", "Over.Commandline.Modules.Doautocmd")
                            	endif
                            	return s:cmdline
                            endfunction
                            
                            
    1              0.000004 function! s:make(prefix)
                            	if has_key(s:cache_command, a:prefix)
                            		unlet! s:cache_command[a:prefix]
                            	endif
                            	execute "augroup " a:prefix . "-vital-over-commandline-doautocmd-dummy"
                            		autocmd!
                            	augroup END
                            
                            	let module = deepcopy(s:module)
                            	let module.prefix = a:prefix
                            	return module
                            endfunction
                            
                            
    1   0.000023   0.000020 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Exception.vim
Sourced 1 time
Total time:   0.000302
 Self time:   0.000271

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000074   0.000049 execute join(['function! vital#_incsearch#Over#Exception#import() abort', printf("return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000019 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000023   0.000020 set cpo&vim
                            
                            
    1              0.000011 let s:vname = expand("<sfile>:h:h:t")
    1              0.000010 let s:prefix = printf("vital-over(%s) Exception", s:vname)
                            
    1              0.000005 function! s:set_prefix(prefix)
                            	let s:prefix = a:prefix
                            endfunction
                            
    1              0.000007 function! s:throw_cmd(exp, where)
                            	return 'throw ' . string(s:prefix . " : " . a:exp . " in " . a:where)
                            endfunction
                            
                            
    1              0.000005 function! s:throw(exp, where)
                            	execute s:throw_cmd(a:exp, a:where)
                            endfunction
                            
                            
    1              0.000004 function! s:error(text, where)
                            	echohl ErrorMsg
                            	echom s:prefix . " : " . a:text . " in " . a:where
                            	echohl None
                            endfunction
                            
                            
    1   0.000034   0.000031 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionMessage.vim
Sourced 1 time
Total time:   0.000327
 Self time:   0.000298

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000071   0.000047 execute join(['function! vital#_incsearch#Over#Commandline#Modules#ExceptionMessage#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000024   0.000022 set cpo&vim
                            
                            
    1              0.000012 let s:vname = expand("<sfile>:h:h:h:h:t")
                            
                            
    1              0.000008 let s:module = {
                            \	"name" : "ExceptionMessage",
                            \}
                            
                            
    1              0.000004 function! s:module.on_exception(cmdline)
                            	let self.exception  = v:exception
                            	let self.throwpoint = v:throwpoint
                            endfunction
                            
                            
    1              0.000004 function! s:module.on_draw_pre(cmdline)
                            	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
                            	endif
                            endfunction
                            
    1              0.000003 function! s:module.message(...)
                            	echohl ErrorMsg
                            	execute self.command string(self.prefix . " : " . self.throwpoint . " " . self.exception)
                            	echohl None
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_leave(cmdline)
                            	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
                            	endif
                            endfunction
                            
                            
    1              0.000005 function! s:make(...)
                            	let result = deepcopy(s:module)
                            	let result.prefix = get(a:, 1, "vital-over(".s:vname.") Exception")
                            	let result.command = get(a:, 2, "echom")
                            	return result
                            endfunction
                            
                            
    1   0.000041   0.000038 let &cpo = s:save_cpo
    1              0.000008 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/History.vim
Sourced 1 time
Total time:   0.000224
 Self time:   0.000200

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000058   0.000038 execute join(['function! vital#_incsearch#Over#Commandline#Modules#History#import() abort', printf("return map({'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
    1              0.000007 let s:module = {
                            \	"name" : "History",
                            \	"mode" : "cmd",
                            \}
                            
    1              0.000003 function! s:module.histories()
                            	return map(range(1, &history), 'histget(self.mode, v:val * -1)')
                            endfunction
                            
    1              0.000004 function! s:_should_match_cmdline(cmdline)
                            	return a:cmdline.is_input("\<Up>")
                            \		|| a:cmdline.is_input("\<Down>")
                            endfunction
                            
    1              0.000002 function! s:_reset()
                            	let s:cmdhist = []
                            	let s:count = 0
                            	let s:is_match_mode = 0 " <Up>/<Down>: true, <C-n>/<C-p>: false
                            endfunction
                            
    1              0.000003 function! s:module.on_enter(...)
                            	call s:_reset()
                            endfunction
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if !a:cmdline.is_input("\<Up>") && !a:cmdline.is_input("\<Down>")
                            	\	&& !a:cmdline.is_input("\<C-p>") && !a:cmdline.is_input("\<C-n>")
                            		call s:_reset()
                            		return
                            	else
                            		if s:count == 0 && empty(s:cmdhist)
                            		\	|| s:is_match_mode != s:_should_match_cmdline(a:cmdline)
                            			let cmdline = '^' . a:cmdline.getline()
                            			let s:is_match_mode = s:_should_match_cmdline(a:cmdline)
                            			let s:cmdhist = [a:cmdline.getline()] + (s:is_match_mode ?
                            			\	filter(self.histories(), 'v:val =~ cmdline') : self.histories())
                            		endif
                            	endif
                            	call a:cmdline.setchar("")
                            	if a:cmdline.is_input("\<Down>") || a:cmdline.is_input("\<C-n>")
                            		let s:count = max([s:count - 1, 0])
                            	endif
                            	if a:cmdline.is_input("\<Up>") || a:cmdline.is_input("\<C-p>")
                            		let s:count = min([s:count + 1, len(s:cmdhist)])
                            	endif
                            	call a:cmdline.setline(get(s:cmdhist, s:count, a:cmdline.getline()))
                            endfunction
                            
    1              0.000003 function! s:make(...)
                            	let module = deepcopy(s:module)
                            	let module.mode = get(a:, 1, "cmd")
                            	return module
                            endfunction
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/NoInsert.vim
Sourced 1 time
Total time:   0.000176
 Self time:   0.000154

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000055   0.000036 execute join(['function! vital#_incsearch#Over#Commandline#Modules#NoInsert#import() abort', printf("return map({'make_special_chars': '', 'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
    1              0.000007 let s:module = {
                            \	"name" : "NoInsert",
                            \	"chars" : []
                            \}
                            
                            
    1              0.000004 function! s:module.is_no_insert(char)
                            	return index(self.chars, a:char) >= 0
                            endfunction
                            
                            
    1              0.000003 function! s:module.on_char_pre(cmdline)
                            	if self.is_no_insert(a:cmdline.char())
                            		call a:cmdline.setchar("", 0)
                            	endif
                            endfunction
                            
                            
    1              0.000002 function! s:make(chars)
                            	let module = deepcopy(s:module)
                            	let module.chars = type(a:chars) == type([]) ? a:chars : [a:chars]
                            	return module
                            endfunction
                            
                            
    1              0.000003 function! s:make_special_chars()
                            	let module = s:make([])
                            	function! module.is_no_insert(char)
                            		return char2nr(a:char) == 128 || char2nr(a:char) < 27
                            	endfunction
                            	return module
                            endfunction
                            
                            
    1   0.000016   0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim
Sourced 1 time
Total time:   0.000362
 Self time:   0.000332

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000062   0.000042 execute join(['function! vital#_incsearch#Over#Commandline#Modules#KeyMapping#import() abort', printf("return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:Keymapping = a:V.import("Palette.Keymapping")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Palette.Keymapping",
                            \	]
                            endfunction
                            
                            
    1              0.000012 let s:emacs = {
                            \	"name" : "KeyMapping_emacs_like"
                            \}
                            
    1              0.000004 function! s:emacs.keymapping(cmdline)
                            	return {
                            \		"\<C-f>" : {
                            \			"key" : "\<Right>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-b>" : {
                            \			"key" : "\<Left>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-n>" : {
                            \			"key" : "\<Down>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-p>" : {
                            \			"key" : "\<Up>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-a>" : {
                            \			"key" : "\<Home>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-e>" : {
                            \			"key" : "\<End>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-d>" : {
                            \			"key" : "\<Del>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-d>" : {
                            \			"key" : "\<C-w>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-b>" : {
                            \			"key" : "\<S-Left>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-f>" : {
                            \			"key" : "\<S-Right>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \	}
                            endfunction
                            
                            
    1              0.000003 function! s:make_emacs()
                            	return deepcopy(s:emacs)
                            endfunction
                            
                            
    1              0.000010 let s:vim_cmdline_mapping = {
                            \	"name" : "KeyMapping_vim_cmdline_mapping",
                            \	"_cmaps" : {}
                            \}
                            
    1              0.000004 function! s:_convert_sid(rhs, sid) abort
                            	return substitute(a:rhs, '<SID>', '<SNR>' . a:sid . '_', 'g')
                            endfunction
                            
    1              0.000003 function! s:_auto_cmap()
                            	let cmaps = {}
                            	let cmap_info = s:Keymapping.rhs_key_list("c", 0, 1)
                            	" vital-over currently doesn't support <buffer> mappings
                            	for c in filter(cmap_info, "v:val['buffer'] ==# 0")
                            		let cmaps[s:Keymapping.escape_special_key(c['lhs'])] = {
                            		\   'noremap' : c['noremap'],
                            		\   'key'  : s:Keymapping.escape_special_key(s:_convert_sid(c['rhs'], c['sid'])),
                            		\   'expr' : s:Keymapping.escape_special_key(c['expr']),
                            		\ }
                            	endfor
                            	return cmaps
                            endfunction
                            
                            
    1              0.000004 function! s:vim_cmdline_mapping.on_enter(cmdline)
                            	let self._cmaps = s:_auto_cmap()
                            	if exists("*execute")
                            		let self._old_cmap = execute("cmap")
                            	endif
                            endfunction
                            
                            
    1              0.000004 function! s:vim_cmdline_mapping.on_update(cmdline)
                            	if !exists("*execute")
                            		return
                            	endif
                            
                            	let cmap_ = execute("cmap")
                            	if self._old_cmap != cmap_
                            		let self._cmaps = s:_auto_cmap()
                            		let self._old_cmap = cmap_
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:vim_cmdline_mapping.keymapping(cmdline)
                            	return self._cmaps
                            endfunction
                            
                            
    1              0.000004 function! s:make_vim_cmdline_mapping()
                            	return deepcopy(s:vim_cmdline_mapping)
                            endfunction
                            
                            
                            
    1   0.000032   0.000024 let &cpo = s:save_cpo
    1              0.000019 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim
Sourced 1 time
Total time:   0.000444
 Self time:   0.000406

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000010 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000093   0.000065 execute join(['function! vital#_incsearch#Palette#Keymapping#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000005 scriptencoding utf-8
    1              0.000020 let s:save_cpo = &cpo
    1   0.000030   0.000022 set cpo&vim
                            
                            
    1              0.000006 let s:modep = "[nvoicsxl]"
                            
                            
    1              0.000005 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Capture  = s:V.import("Palette.Capture")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Palette.Capture",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:_capture(mode)
                            	let cmd = "map"
                            	if a:mode ==# "!"
                            		let cmd = cmd . "!"
                            	elseif a:mode =~# "[nvoicsxl]"
                            		let cmd = a:mode . cmd
                            	endif
                            	return s:Capture.command(cmd)
                            endfunction
                            
                            
    1              0.000004 function! s:capture(...)
                            	let mode = get(a:, 1, "")
                            	let modes = split(mode, '\zs')
                            	return join(map(modes, "s:_capture(v:val)"), "\n")
                            endfunction
                            
                            
    1              0.000004 function! s:_keymapping(str)
                            	return a:str =~ '^[!nvoicsxl]\s'
                            endfunction
                            
                            
    1              0.000004 function! s:capture_list(...)
                            	let mode = get(a:, 1, "")
                            	return filter(split(s:capture(mode), "\n"), "s:_keymapping(v:val)")
                            endfunction
                            
                            
    1              0.000005 function! s:escape_special_key(key)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
                            	if a:key ==# "<^?>"
                            		return "\<C-?>"
                            	endif
                            	execute 'let result = "' . substitute(escape(a:key, '\"'), '\(<.\{-}>\)', '\\\1', 'g') . '"'
                            	return result
                            endfunction
                            
                            
    1              0.000004 function! s:parse_lhs(text, ...)
                            	let mode = get(a:, 1, '[!nvoicsxl]')
                            	" NOTE: :map! Surpport : https://github.com/osyo-manga/vital-palette/issues/4
                            	if get(a:, 1, "") =~# '[!ci]'
                            		let mode = '[!ci]'
                            	endif
                            	return matchstr(a:text, mode . '\{1,3\}\s*\zs\S\{-}\ze\s\+')
                            endfunction
                            
                            
    1              0.000017 function! s:parse_lhs_list(...)
                            	let mode = get(a:, 1, "")
                            	return map(s:capture_list(mode), "s:parse_lhs(v:val, mode)")
                            endfunction
                            
                            
    1              0.000006 function! s:lhs_key_list(...)
                            	let mode = get(a:, 1, "")
                            	return map(s:parse_lhs_list(mode), "s:escape_special_key(v:val)")
                            endfunction
                            
                            
    1              0.000004 function! s:_maparg(name, mode, abbr, dict)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
                            	if a:name ==# "<^?>"
                            		return maparg("\<C-?>", a:mode, a:abbr, a:dict)
                            	endif
                            	return maparg(a:name, a:mode, a:abbr, a:dict)
                            endfunction
                            
                            
    1              0.000003 function! s:rhs_key_list(...)
                            	let mode = get(a:, 1, "")
                            	let abbr = get(a:, 2, 0)
                            	let dict = get(a:, 3, 0)
                            	
                            	let result = []
                            	for m in split(mode, '\zs')
                            		let result += map(s:parse_lhs_list(m), "s:_maparg(v:val, m, abbr, dict)")
                            	endfor
                            	return filter(result, "empty(v:val) == 0")
                            endfunction
                            
                            
    1   0.000020   0.000018 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Capture.vim
Sourced 1 time
Total time:   0.000248
 Self time:   0.000191

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000091   0.000037 execute join(['function! vital#_incsearch#Palette#Capture#import() abort', printf("return map({'extend': '', 'command': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000016 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000003 let s:verbosefiles = []
                            
    1              0.000004 function! s:_verbosefile_push(file)
                            	call add(s:verbosefiles, &verbosefile)
                            	let &verbosefile = a:file
                            	return a:file
                            endfunction
                            
                            
    1              0.000003 function! s:_verbosefile_pop()
                            	let filename = &verbosefile
                            	let &verbosefile = get(s:verbosefiles, -1)
                            	call remove(s:verbosefiles, -1)
                            	return filename
                            endfunction
                            
                            
    1              0.000003 function! s:_reset()
                            	let s:verbosefiles = []
                            endfunction
                            
                            
    1              0.000003 function! s:extend(dict, src)
                            	for [key, value] in items(a:src)
                            		let a:dict[key] = value
                            		unlet value
                            	endfor
                            endfunction
                            
                            
    1              0.000003 function! s:command(cmd, ...)
                            	" Workaround : Vim 7.3.xxx in Travis and Ubuntu
                            	" https://github.com/osyo-manga/vital-palette/issues/5
                            " 	call extend(l:, get(a:, 1, {}))
                            	if a:0 > 0
                            		call s:extend(l:, a:1)
                            	endif
                            
                            	call s:_verbosefile_push(tempname())
                            	try
                            		redir =>result
                            		silent execute a:cmd
                            	finally
                            		redir END
                            	endtry
                            	call s:_verbosefile_pop()
                            " 	let result = substitute(result, "<SRN>", "\<SNR>", "g")
                            " 	let result = substitute(result, "<SID>", "\<SID>", "g")
                            	return result
                            endfunction
                            
                            
    1   0.000017   0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/IgnoreRegexpBackwardWord.vim
Sourced 1 time
Total time:   0.000181
 Self time:   0.000161

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000063   0.000046 execute join(['function! vital#_incsearch#Over#Commandline#Modules#IgnoreRegexpBackwardWord#import() abort', printf("return map({'backward_word': '', 'make': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            " Improved backward word detection which ignore regular expression
    1              0.000007 let s:module = {
                            \	"name" : "IgnoreRegexpBackwardWord"
                            \}
                            
    1              0.000004 function! s:backward_word(str, ...)
                            	let pat = get(a:, 1, '\k\+\s*\|.')
                            	let flags = s:non_escaped_backslash .
                            	\   '\%(' . 'z[se]' .
                            	\   '\|' . '[iIkKfFpPsSdDxXoOwWhHaAlLuUetrbncCZmMvV]' .
                            	\   '\|' . '%[dxouUCVlcv]' .
                            	\   '\|' . "%'[a-zA-Z]" .
                            	\   '\|' . '%#=\d' .
                            	\   '\|' . 'z\=\d' .
                            	\   '\)'
                            	return matchstr(get(split(a:str, flags . '\s*\zs'), -1, ""),
                            	\   '\%(' . flags . '\s*\|' . pat . '\)$')
                            endfunction
                            
                            
    1              0.000006 let s:non_escaped_backslash = '\m\%(\%(^\|[^\\]\)\%(\\\\\)*\)\@<=\\'
                            
    1              0.000003 function! s:module.on_enter(cmdline)
                            	function! a:cmdline.backward_word(...)
                            		return call("s:backward_word", [self.backward()] + a:000)
                            	endfunction
                            endfunction
                            
    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction
                            
                            
    1   0.000016   0.000015 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/module_management.vim
Sourced 1 time
Total time:   0.000185
 Self time:   0.000181

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/module_management.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000011 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
    1              0.000009 let s:module_management =  {
                            \   'name' : 'IncsearchModuleManagement',
                            \   'modules' : [ ]
                            \}
                            
    1              0.000004 function! s:module_management.on_enter(cmdline) abort
                              if !exists('s:default_backward_word')
                                let s:default_backward_word = a:cmdline.backward_word
                              endif
                              for module in self.modules
                                if has_key(module, '_condition') && ! module._condition()
                                  call a:cmdline.disconnect(module.name)
                                  if module.name ==# 'IgnoreRegexpBackwardWord'
                                    function! a:cmdline.backward_word(...) abort
                                      return call(s:default_backward_word, a:000, self)
                                    endfunction
                                  endif
                                elseif empty(a:cmdline.get_module(module.name))
                                  call a:cmdline.connect(module)
                                  if has_key(module, 'on_enter')
                                    call module.on_enter(a:cmdline)
                                  endif
                                endif
                              endfor
                            endfunction
                            
    1              0.000022 function! s:module_management.priority(event) abort
                              " NOTE: to overwrite backward_word() with default function
                              return a:event ==# 'on_enter' ? 5 : 0
                            endfunction
                            
    1              0.000006 function! incsearch#over#modules#module_management#make(modules) abort
                              let m = deepcopy(s:module_management)
                              let m.modules = a:modules
                              return m
                            endfunction
                            
    1   0.000033   0.000030 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/pattern_saver.vim
Sourced 1 time
Total time:   0.000106
 Self time:   0.000104

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/pattern_saver.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            " @vimlint(EVL103, 1, a:cmdline)
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000011 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
    1              0.000009 let s:pattern_saver =  {
                            \   'name' : 'PatternSaver',
                            \   'pattern' : '',
                            \   'hlsearch' : &hlsearch
                            \}
                            
    1              0.000004 function! s:pattern_saver.on_enter(cmdline) abort
                              if ! g:incsearch#no_inc_hlsearch
                                let self.pattern = @/
                                let self.hlsearch = &hlsearch
                                if exists('v:hlsearch')
                                  let self.vhlsearch = v:hlsearch
                                endif
                                set hlsearch | nohlsearch
                              endif
                            endfunction
                            
    1              0.000003 function! s:pattern_saver.on_leave(cmdline) abort
                              if ! g:incsearch#no_inc_hlsearch
                                let is_cancel = a:cmdline.exit_code()
                                if is_cancel
                                  let @/ = self.pattern
                                endif
                                let &hlsearch = self.hlsearch
                                if exists('v:hlsearch')
                                  let v:hlsearch = self.vhlsearch
                                endif
                              endif
                            endfunction
                            
    1              0.000005 function! incsearch#over#modules#pattern_saver#make() abort
                              return deepcopy(s:pattern_saver)
                            endfunction
                            
    1   0.000015   0.000014 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bulk_input_char.vim
Sourced 1 time
Total time:   0.000104
 Self time:   0.000100

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/bulk_input_char.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000017 let s:save_cpo = &cpo
    1   0.000016   0.000014 set cpo&vim
                            
                            " IncsearchBulkInputChar bulk insert characters and avoid updating for each
                            " character input. It's useful while execution macro or pasting text clipboard.
                            " CAUTION: cannot test getchar(0) with themis.vim
    1              0.000007 let s:bulk_input_char = {
                            \   'name': 'IncsearchBulkInputChar'
                            \ }
                            
    1              0.000003 function! s:bulk_input_char.on_char_pre(cmdline) abort
                              let stack = []
                              let c = 1
                              while c
                                let c = getchar(0)
                                if c != 0
                                  let stack += [nr2char(c)]
                                elseif !empty(stack)
                                  call a:cmdline.set_input_key_stack(stack)
                                endif
                              endwhile
                            endfunction
                            
    1              0.000004 function! incsearch#over#modules#bulk_input_char#make() abort
                              return deepcopy(s:bulk_input_char)
                            endfunction
                            
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bracketed_paste.vim
Sourced 1 time
Total time:   0.000100
 Self time:   0.000097

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/bracketed_paste.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            " @vimlint(EVL103, 1, a:cmdline)
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
                            " https://github.com/haya14busa/incsearch.vim/issues/131
    1              0.000007 let s:bracketed_paste =  {
                            \   'name' : 'BracketedPaste',
                            \   't_BE' : '',
                            \}
                            
    1              0.000004 function! s:bracketed_paste.on_enter(cmdline) abort
                              if !exists('&t_BE')
                                return
                              endif
                              let self.t_BE = &t_BE
                              set t_BE=
                            endfunction
                            
    1              0.000003 function! s:bracketed_paste.on_leave(cmdline) abort
                              if !exists('&t_BE')
                                return
                              endif
                              let &t_BE = self.t_BE
                            endfunction
                            
    1              0.000004 function! incsearch#over#modules#bracketed_paste#make() abort
                              return deepcopy(s:bracketed_paste)
                            endfunction
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker
                            

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim
Sourced 1 time
Total time:   0.018844
 Self time:   0.000599

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/modules/incsearch.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000018   0.000017 set cpo&vim
                            
    1              0.000003 let s:TRUE = !0
    1              0.000003 let s:FALSE = 0
    1              0.000005 let s:DIRECTION = { 'forward': 1, 'backward': 0 } " see :h v:searchforward
                            
                            
    1   0.018306   0.000221 let s:hi = g:incsearch#highlight#_hi
    1   0.000176   0.000019 let s:U = incsearch#util#import()
                            
    1              0.000005 let s:inc = {
                            \   'name' : 'incsearch',
                            \}
                            
                            " NOTE: for InsertRegister handling
    1              0.000003 function! s:inc.priority(event) abort
                              return a:event is# 'on_char' ? 10 : 0
                            endfunction
                            
    1              0.000003 function! s:inc.on_enter(cmdline) abort
                              nohlsearch " disable previous highlight
                              let a:cmdline._w = winsaveview()
                              let hgm = incsearch#highlight#hgm()
                              let c = hgm.cursor
                              call s:hi.add(c.group, c.group, '\%#', c.priority)
                              call incsearch#highlight#update()
                            
                              " XXX: Manipulate search history for magic option
                              " In the first place, I want to omit magic flag when histadd(), but
                              " when returning cmd as expr mapping and feedkeys() cannot handle it, so
                              " remove no user intended magic flag at on_enter.
                              " Maybe I can also handle it with autocmd, should I use autocmd instead?
                              let hist = histget('/', -1)
                              if len(hist) > 2 && hist[:1] ==# incsearch#magic()
                                call histdel('/', -1)
                                call histadd('/', hist[2:])
                              endif
                            endfunction
                            
    1              0.000003 function! s:inc.on_leave(cmdline) abort
                              call s:hi.disable_all()
                              call s:hi.delete_all()
                              " redraw: hide pseud-cursor
                              redraw " need to redraw for handling non-<expr> mappings
                              if a:cmdline.getline() ==# ''
                                echo ''
                              else
                                echo a:cmdline.get_prompt() . a:cmdline.getline()
                              endif
                              " NOTE:
                              "   push rest of keymappings with feedkeys()
                              "   FIXME: assume 'noremap' but it should take care wheter or not the
                              "   mappings should be remapped or not
                              if a:cmdline.input_key_stack_string() !=# ''
                                call feedkeys(a:cmdline.input_key_stack_string(), 'n')
                              endif
                            endfunction
                            
                            " Avoid search-related error while incremental searching
    1              0.000004 function! s:on_searching(func, ...) abort
                              try
                                return call(a:func, a:000)
                              catch /E16:/  " E16: Invalid range  (with /\_[a- )
                              catch /E33:/  " E33: No previous substitute regular expression
                              catch /E53:/  " E53: Unmatched %(
                              catch /E54:/
                              catch /E55:/
                              catch /E62:/  " E62: Nested \= (with /a\=\=)
                              catch /E63:/  " E63: invalid use of \_
                              catch /E64:/  " E64: \@ follows nothing
                              catch /E65:/  " E65: Illegal back reference
                              catch /E66:/  " E66: \z( not allowed here
                              catch /E67:/  " E67: \z1 et al. not allowed here
                              catch /E68:/  " E68: Invalid character after \z (with /\za & re=1)
                              catch /E69:/  " E69: Missing ] after \%[
                              catch /E70:/  " E70: Empty \%[]
                              catch /E71:/  " E71: Invalid character after \%
                              catch /E554:/
                              catch /E678:/ " E678: Invalid character after \%[dxouU]
                              catch /E864:/ " E864: \%#= can only be followed by 0, 1, or 2. The
                                            "       automatic engine will be used
                              catch /E865:/ " E865: (NFA) Regexp end encountered prematurely
                              catch /E866:/ " E866: (NFA regexp) Misplaced @
                              catch /E867:/ " E867: (NFA) Unknown operator
                              catch /E869:/ " E869: (NFA) Unknown operator '\@m
                              catch /E870:/ " E870: (NFA regexp) Error reading repetition limits
                              catch /E871:/ " E871: (NFA regexp) Can't have a multi follow a multi !
                              catch /E874:/ " E874: (NFA) Could not pop the stack ! (with \&)
                              catch /E877:/ " E877: (NFA regexp) Invalid character class: 109
                              catch /E888:/ " E888: (NFA regexp) cannot repeat (with /\ze*)
                                call s:hi.disable_all()
                              catch
                                echohl ErrorMsg | echom v:throwpoint . ' ' . v:exception | echohl None
                              endtry
                            endfunction
                            
    1              0.000004 function! s:on_char_pre(cmdline) abort
                              " NOTE:
                              " `:call a:cmdline.setchar('')` as soon as possible!
                              let [raw_pattern, offset] = a:cmdline._parse_pattern()
                              let pattern = a:cmdline._convert(raw_pattern)
                            
                              " Interactive :h last-pattern if pattern is empty
                              if ( a:cmdline.is_input('<Over>(incsearch-next)')
                              \ || a:cmdline.is_input('<Over>(incsearch-prev)')
                              \ ) && empty(pattern)
                                call a:cmdline.setchar('')
                                " Use history instead of @/ to work with magic option and converter
                                call a:cmdline.setline(histget('/', -1) . (empty(offset) ? '' : a:cmdline._base_key) . offset)
                                " Just insert last-pattern and do not count up, but the incsearch-prev
                                " should move the cursor to reversed directly, so do not return if the
                                " command is prev
                                if a:cmdline.is_input('<Over>(incsearch-next)') | return | endif
                              endif
                            
                              if a:cmdline.is_input('<Over>(incsearch-next)')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n' " exit stay mode
                                  let a:cmdline._flag = ''
                                else
                                  let a:cmdline._vcount1 += 1
                                endif
                              elseif a:cmdline.is_input('<Over>(incsearch-prev)')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n' " exit stay mode
                                  let a:cmdline._flag = ''
                                endif
                                let a:cmdline._vcount1 -= 1
                              elseif (a:cmdline.is_input('<Over>(incsearch-scroll-f)')
                              \ &&   (a:cmdline._flag ==# '' || a:cmdline._flag ==# 'n'))
                              \ ||   (a:cmdline.is_input('<Over>(incsearch-scroll-b)') && a:cmdline._flag ==# 'b')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n' | let a:cmdline._flag = '' | endif
                                let pos_expr = a:cmdline.is_input('<Over>(incsearch-scroll-f)') ? 'w$' : 'w0'
                                let to_col = a:cmdline.is_input('<Over>(incsearch-scroll-f)')
                                \          ? s:U.get_max_col(pos_expr) : 1
                                let [from, to] = [getpos('.')[1:2], [line(pos_expr), to_col]]
                                let cnt = s:U.count_pattern(pattern, from, to)
                                let a:cmdline._vcount1 += cnt
                              elseif (a:cmdline.is_input('<Over>(incsearch-scroll-b)')
                              \ &&   (a:cmdline._flag ==# '' || a:cmdline._flag ==# 'n'))
                              \ ||   (a:cmdline.is_input('<Over>(incsearch-scroll-f)') && a:cmdline._flag ==# 'b')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n'
                                  let a:cmdline._flag = ''
                                  let a:cmdline._vcount1 -= 1
                                endif
                                let pos_expr = a:cmdline.is_input('<Over>(incsearch-scroll-f)') ? 'w$' : 'w0'
                                let to_col = a:cmdline.is_input('<Over>(incsearch-scroll-f)')
                                \          ? s:U.get_max_col(pos_expr) : 1
                                let [from, to] = [getpos('.')[1:2], [line(pos_expr), to_col]]
                                let cnt = s:U.count_pattern(pattern, from, to)
                                let a:cmdline._vcount1 -= cnt
                              endif
                            
                              " Handle nowrapscan:
                              "   if you `:set nowrapscan`, you can't move to the reversed direction
                              if !&wrapscan && (
                              \    a:cmdline.is_input('<Over>(incsearch-next)')
                              \ || a:cmdline.is_input('<Over>(incsearch-prev)')
                              \ || a:cmdline.is_input('<Over>(incsearch-scroll-f)')
                              \ || a:cmdline.is_input('<Over>(incsearch-scroll-b)')
                              \ )
                                if a:cmdline._vcount1 < 1
                                  let a:cmdline._vcount1 = 1
                                else
                                  call a:cmdline.setchar('')
                                  let [from, to] = [[a:cmdline._w.lnum, a:cmdline._w.col + 1],
                                  \       a:cmdline._flag !=# 'b'
                                  \       ? [line('$'), s:U.get_max_col('$')]
                                  \       : [1, 1]
                                  \   ]
                                  let max_cnt = s:U.count_pattern(pattern, from, to, s:TRUE)
                                  let a:cmdline._vcount1 = min([max_cnt, a:cmdline._vcount1])
                                endif
                              endif
                              if &wrapscan && a:cmdline._vcount1 < 1
                                let a:cmdline._vcount1 += s:U.count_pattern(pattern)
                              endif
                            endfunction
                            
    1              0.000003 function! s:on_char(cmdline) abort
                              if a:cmdline._does_exit_from_incsearch
                                return
                              endif
                              let [raw_pattern, offset] = a:cmdline._parse_pattern()
                            
                              if raw_pattern ==# ''
                                call s:hi.disable_all()
                                nohlsearch
                                return
                              endif
                            
                              " For InsertRegister
                              if a:cmdline.get_tap_key() ==# "\<C-r>"
                                let p = a:cmdline.getpos()
                                " Remove `"`
                                let raw_pattern = raw_pattern[:p-1] . raw_pattern[p+1:]
                                let w = winsaveview()
                                call cursor(line('.'), col('.') + len(a:cmdline.backward_word()))
                                call a:cmdline.get_module('InsertRegister').reset()
                                call winrestview(w)
                              endif
                            
                              let pattern = a:cmdline._convert(raw_pattern)
                            
                              " Improved Incremental cursor move!
                              call s:move_cursor(a:cmdline, pattern, offset)
                            
                              " Improved Incremental highlighing!
                              " case: because matchadd() doesn't handle 'ignorecase' nor 'smartcase'
                              let case = incsearch#detect_case(raw_pattern)
                              let should_separate = g:incsearch#separate_highlight && a:cmdline._flag !=# 'n'
                              let pattern_for_hi =
                              \ (a:cmdline._flag is# 'b' ? s:unescape_question_for_backward(pattern) : pattern)
                              \ . case
                              call incsearch#highlight#incremental_highlight(
                              \   pattern_for_hi,
                              \   should_separate,
                              \   a:cmdline._direction,
                              \   [a:cmdline._w.lnum, a:cmdline._w.col])
                            
                              " functional `normal! zz` after scroll for <expr> mappings
                              if ( a:cmdline.is_input('<Over>(incsearch-scroll-f)')
                              \ || a:cmdline.is_input('<Over>(incsearch-scroll-b)'))
                                call winrestview({'topline': max([1, line('.') - winheight(0) / 2])})
                              endif
                            endfunction
                            
                            " Caveat: It handle :h last-pattern, so be careful if you want to pass empty
                            " string as a pattern
    1              0.000004 function! s:move_cursor(cli, pattern, ...) abort
                              let offset = get(a:, 1, '')
                              if a:cli._flag ==# 'n' " skip if stay mode
                                return
                              endif
                              call winrestview(a:cli._w)
                              " pseud-move cursor position: this is restored afterward if called by
                              " <expr> mappings
                              if a:cli._is_expr
                                for _ in range(a:cli._vcount1)
                                  " NOTE: This cannot handle {offset} for cursor position
                                  call search(a:pattern, a:cli._flag)
                                endfor
                              else
                                " More precise cursor position while searching
                                " Caveat:
                                "   This block contains `normal`, please make sure <expr> mappings
                                "   doesn't reach this block
                                let is_visual_mode = s:U.is_visual(mode(1))
                                let cmd = incsearch#with_ignore_foldopen(
                                \   s:U.dictfunction(a:cli._build_search_cmd, a:cli),
                                \   a:cli._combine_pattern(a:pattern, offset), 'n')
                                " NOTE:
                                " :silent!
                                "   Shut up errors! because this is just for the cursor emulation
                                "   while searching
                                silent! call incsearch#execute_search(cmd)
                                if is_visual_mode
                                  let w = winsaveview()
                                  normal! gv
                                  call winrestview(w)
                                  call incsearch#highlight#emulate_visual_highlight()
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! s:inc.on_char_pre(cmdline) abort
                              call s:on_searching(function('s:on_char_pre'), a:cmdline)
                            endfunction
                            
    1              0.000002 function! s:inc.on_char(cmdline) abort
                              call s:on_searching(function('s:on_char'), a:cmdline)
                            endfunction
                            
    1              0.000005 function! s:unescape_question_for_backward(pattern) abort
                              return substitute(a:pattern, '\\?', '?', 'g')
                            endfunction
                            
    1              0.000004 function! incsearch#over#modules#incsearch#make() abort
                              return deepcopy(s:inc)
                            endfunction
                            
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/highlight.vim
Sourced 1 time
Total time:   0.018050
 Self time:   0.000870

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/highlight.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000002 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000012 let s:save_cpo = &cpo
    1   0.000017   0.000015 set cpo&vim
                            " }}}
                            
    1              0.000003 let s:TRUE = !0
    1              0.000003 let s:FALSE = 0
    1              0.000005 let s:DIRECTION = { 'forward': 1, 'backward': 0 } " see :h v:searchforward
                            
                            " Utility Helper:
    1   0.000314   0.000024 let s:U = incsearch#util#import()
                            
                            
                            " Management:
                            
    1   0.016636   0.000034 let s:hi = vital#incsearch#import('Coaster.Highlight').make()
    1              0.000005 let g:incsearch#highlight#_hi = s:hi
                            
    1              0.000004 function! incsearch#highlight#update() abort
                              " it's intuiive to call incsearch#highlight#on() & off() but there are no
                              " need to execute `:nohlsearch` when updating.
                              call s:hi.disable_all()
                              call s:hi.enable_all()
                            endfunction
                            
    1              0.000003 function! incsearch#highlight#on() abort
                              call s:hi.enable_all()
                              if ! g:incsearch#no_inc_hlsearch
                                let &hlsearch = &hlsearch
                              endif
                            endfunction
                            
    1              0.000003 function! incsearch#highlight#off() abort
                              call s:hi.disable_all()
                              if ! g:incsearch#no_inc_hlsearch
                                nohlsearch
                              endif
                            endfunction
                            
    1              0.000003 function! s:init_hl() abort
                              hi default link IncSearchMatch Search
                              hi default link IncSearchMatchReverse IncSearch
                              hi default link IncSearchCursor Cursor
                              hi default link IncSearchOnCursor IncSearch
                              hi default IncSearchUnderline term=underline cterm=underline gui=underline
                            endfunction
    1   0.000298   0.000015 call s:init_hl()
    1              0.000006 augroup plugin-incsearch-highlight
    1              0.000187   autocmd!
    1              0.000015   autocmd ColorScheme * call s:init_hl()
    1              0.000002 augroup END
                            
    1              0.000031 let s:default_highlight = {
                            \   'visual' : {
                            \       'group'    : '_IncSearchVisual',
                            \       'priority' : '10'
                            \   },
                            \   'match' : {
                            \       'group'    : 'IncSearchMatch',
                            \       'priority' : '49'
                            \   },
                            \   'match_reverse' : {
                            \       'group'    : 'IncSearchMatchReverse',
                            \       'priority' : '49'
                            \   },
                            \   'on_cursor' : {
                            \       'group'    : 'IncSearchOnCursor',
                            \       'priority' : '50'
                            \   },
                            \   'cursor' : {
                            \       'group'    : 'IncSearchCursor',
                            \       'priority' : '51'
                            \   },
                            \ }
                            
    1              0.000004 function! incsearch#highlight#hgm() abort " highlight group management
                              let hgm = copy(s:default_highlight)
                              for key in keys(hgm)
                                call extend(hgm[key], get(g:incsearch#highlight, key, {}))
                              endfor
                              return hgm
                            endfunction
                            
                            " hldict: { 'name' : lhs, 'highlight': rhs }
                            
                            " Util:
                            
                            " @return hldict
    1              0.000005 function! incsearch#highlight#capture(hlname) abort
                              " Based On: https://github.com/t9md/vim-ezbar
                              "           https://github.com/osyo-manga/vital-over
                              let hlname = a:hlname
                              if !hlexists(hlname)
                                return
                              endif
                              while 1
                                let save_verbose = &verbose
                                let &verbose = 0
                                try
                                  redir => HL_SAVE
                                  execute 'silent! highlight ' . hlname
                                  redir END
                                finally
                                  let &verbose = save_verbose
                                endtry
                                if !empty(matchstr(HL_SAVE, 'xxx cleared$'))
                                  return ''
                                endif
                                " follow highlight link
                                let ml = matchlist(HL_SAVE, 'links to \zs.*')
                                if !empty(ml)
                                  let hlname = ml[0]
                                  continue
                                endif
                                break
                              endwhile
                              let HL_SAVE = substitute(matchstr(HL_SAVE, 'xxx \zs.*'),
                              \ '[ \t\n]\+', ' ', 'g')
                              return { 'name': hlname, 'highlight': HL_SAVE }
                            endfunction
                            
    1              0.000004 function! incsearch#highlight#turn_off(hldict) abort
                              execute 'highlight' a:hldict.name 'NONE'
                            endfunction
                            
    1              0.000003 function! incsearch#highlight#turn_on(hldict) abort
                              execute 'highlight' a:hldict.name a:hldict.highlight
                            endfunction
                            
                            " Wrapper:
                            
                            " @return hlobj
    1              0.000004 function! incsearch#highlight#get_visual_hlobj() abort
                              if ! exists('s:_visual_hl')
                                let s:_visual_hl = incsearch#highlight#capture('Visual')
                              endif
                              return s:_visual_hl
                            endfunction
                            
    1              0.000003 augroup incsearch-update-visual-highlight
    1              0.000176   autocmd!
    1              0.000011   autocmd ColorScheme * if exists('s:_visual_hl') | unlet s:_visual_hl | endif
    1              0.000002 augroup END
                            
                            " Visual Highlighting Emulation:
                            
    1              0.000005 let s:INT = { 'MAX': 2147483647 }
                            
                            " NOTE:
                            "   Default highlight for visual selection has always higher priority than
                            "   defined highlight, so you have to turn off default visual highlight and
                            "   emulate it. All this function do is pseudo highlight visual selected area
                            " args: mode, visual_hl, v_start_pos, v_end_pos
    1              0.000005 function! incsearch#highlight#emulate_visual_highlight(...) abort
                              let is_visual_now = s:U.is_visual(mode(1))
                              let mode = get(a:, 1, is_visual_now ? mode(1) : visualmode())
                              let visual_hl = get(a:, 2, incsearch#highlight#get_visual_hlobj())
                              " Note: the default pos value assume visual selection is not cleared.
                              " It uses curswant to emulate visual-block
                              let v_start_pos = get(a:, 3,
                              \   (is_visual_now ? [line('v'),col('v')] : [line("'<"), col("'<")]))
                              " See: https://github.com/vim-jp/issues/issues/604
                              " getcurpos() could be negative value, so use winsaveview() instead
                              let end_curswant_pos =
                              \   (exists('*getcurpos') ? getcurpos()[4] : winsaveview().curswant + 1)
                              let v_end_pos = get(a:, 4, (is_visual_now
                              \   ? [line('.'), end_curswant_pos < 0 ? s:INT.MAX : end_curswant_pos ]
                              \   : [line("'>"), col("'>")]))
                              let pattern = incsearch#highlight#get_visual_pattern(mode, v_start_pos, v_end_pos)
                              let hgm = incsearch#highlight#hgm()
                              let v = hgm.visual
                              " NOTE: Update highlight
                              execute 'hi' 'clear' v.group
                              execute 'hi' v.group visual_hl['highlight']
                              call s:hi.add(v.group, v.group, pattern, v.priority)
                              call incsearch#highlight#update()
                            endfunction
                            
    1              0.000005 function! incsearch#highlight#get_visual_pattern(mode, v_start_pos, v_end_pos) abort
                              " NOTE: highlight doesn't work if the range is over screen height, so
                              "   limit pattern to visible window.
                              let [_, v_start, v_end, _] = s:U.sort_pos([
                              \   a:v_start_pos,
                              \   a:v_end_pos,
                              \   [line('w0'), 1],
                              \   [line('w$'), s:U.get_max_col(line('w$'))]
                              \  ])
                              if a:mode ==# 'v'
                                if v_start[0] == v_end[0]
                                  return printf('\v%%%dl%%%dc\_.*%%%dl%%%dc',
                                  \              v_start[0],
                                  \              min([v_start[1], s:U.get_max_col(v_start[0])]),
                                  \              v_end[0],
                                  \              min([v_end[1], s:U.get_max_col(v_end[0])]))
                                else
                                  return printf('\v%%%dl%%%dc\_.{-}%%%dl|%%%dl\_.*%%%dl%%%dc',
                                  \              v_start[0],
                                  \              min([v_start[1], s:U.get_max_col(v_start[0])]),
                                  \              v_end[0],
                                  \              v_end[0],
                                  \              v_end[0],
                                  \              min([v_end[1], s:U.get_max_col(v_end[0])]))
                                endif
                              elseif a:mode ==# 'V'
                                return printf('\v%%%dl\_.*%%%dl', v_start[0], v_end[0])
                              elseif a:mode ==# "\<C-v>"
                                " @vimlint(EVL102, 1, l:min_c)
                                let [min_c, max_c] = s:U.sort_num([v_start[1], v_end[1]])
                                let max_c += 1 " increment needed
                                let max_c = max_c < 0 ? s:INT.MAX : max_c
                                let mapfunc = "
                                \ printf('%%%dl%%%dc.*%%%dc',
                                \        v:val, min_c, min([max_c, s:U.get_max_col(v:val)]))
                                \ "
                                return '\v'.join(map(range(v_start[0], v_end[0]), mapfunc), '|')
                              else
                                throw 'incsearch.vim: unexpected mode ' . a:mode
                              endif
                            endfunction
                            
                            " Incremental Highlighting:
                            
    1              0.000005 function! incsearch#highlight#incremental_highlight(pattern, ...) abort
                              let should_separate_highlight = get(a:, 1, s:FALSE)
                              let direction = get(a:, 2, s:DIRECTION.forward)
                              let start_pos = get(a:, 3, getpos('.')[1:2])
                              let hgm = incsearch#highlight#hgm()
                              let [m, r, o, c] = [hgm.match, hgm.match_reverse, hgm.on_cursor, hgm.cursor]
                              let on_cursor_pattern = '\m\%#\(' . a:pattern . '\m\)'
                            
                              if '' =~# a:pattern
                                " Do not highlight for patterns which match everything
                                call s:hi.delete_all()
                              elseif ! should_separate_highlight
                                call s:hi.add(m.group, m.group, a:pattern, m.priority)
                                if ! g:incsearch#no_inc_hlsearch
                                  let @/ = a:pattern
                                  let &hlsearch = &hlsearch
                                endif
                              else
                                let [p1, p2] = (direction == s:DIRECTION.forward)
                                \   ? [incsearch#highlight#forward_pattern(a:pattern, start_pos)
                                \     ,incsearch#highlight#backward_pattern(a:pattern, start_pos)]
                                \   : [incsearch#highlight#backward_pattern(a:pattern, start_pos)
                                \     ,incsearch#highlight#forward_pattern(a:pattern, start_pos)]
                                call s:hi.add(m.group , m.group , p1 , m.priority) " right direction
                                call s:hi.add(r.group , r.group , p2 , r.priority) " reversed direction
                              endif
                              call s:hi.add(o.group , o.group , on_cursor_pattern , o.priority)
                              call s:hi.add(c.group , c.group , '\v%#'            , c.priority)
                              call incsearch#highlight#update()
                            endfunction
                            
    1              0.000005 function! incsearch#highlight#forward_pattern(pattern, from_pos) abort
                              let [line, col] = a:from_pos
                              return printf('\v(%%>%dl|%%%dl%%>%dc)\m\(%s\m\)', line, line, col, a:pattern)
                            endfunction
                            
    1              0.000004 function! incsearch#highlight#backward_pattern(pattern, from_pos) abort
                              let [line, col] = a:from_pos
                              return printf('\v(%%<%dl|%%%dl%%<%dc)\m\(%s\m\)', line, line, col, a:pattern)
                            endfunction
                            
                            
                            " Restore 'cpoptions' {{{
    1   0.000022   0.000019 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=2 shiftwidth=2
                            " vim: foldmethod=marker
                            " }}}

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim
Sourced 1 time
Total time:   0.001128
 Self time:   0.001107

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000084   0.000067 execute join(['function! vital#_incsearch#Coaster#Highlight#import() abort', printf("return map({'highlight': '', 'clear': '', 'delete': '', 'add': '', 'as_windo': '', '_vital_depends': '', 'get_hl_id': '', 'to_list': '', 'clear_all': '', 'delete_all': '', 'to_list_by': '', 'update': '', 'enable': '', 'delete_by': '', 'hl_list': '', 'make': '', 'enable_list': '', 'update_all': '', 'disable': '', 'disable_all': '', 'is_enabled': '', 'enable_all': '', 'is_added': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000017   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Window = a:V.import("Coaster.Window")
                            	let s:Gift = a:V.import("Gift")
                            	call s:_init()
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Coaster.Window",
                            \		"Gift",
                            \	]
                            endfunction
                            
                            
                            
    1              0.000008 let s:base = {
                            \	"variables" : {
                            \		"hl_list" : {},
                            \		"id_list" : {}
                            \	}
                            \}
                            
                            
    1              0.000003 function! s:base.add(name, group, pattern, ...)
                            	call self.delete(a:name)
                            	let priority = get(a:, 1, 10)
                            	let self.variables.hl_list[a:name] = {
                            \		"group" : a:group,
                            \		"pattern" : a:pattern,
                            \		"priority" : priority,
                            \		"name" : a:name,
                            \	}
                            endfunction
                            
                            
    1              0.000002 function! s:base.is_added(name)
                            	return has_key(self.variables.hl_list, a:name)
                            endfunction
                            
                            
    1              0.000002 function! s:base.hl_list()
                            	return keys(self.variables.hl_list)
                            endfunction
                            
                            
    1              0.000003 function! s:base.to_list()
                            	return values(self.variables.hl_list)
                            endfunction
                            
                            
    1              0.000003 function! s:_is_equal(__expr, __hl)
                            	let name     = a:__hl.name
                            	let group    = a:__hl.group
                            	let pattern  = a:__hl.pattern
                            	let priority = a:__hl.priority
                            	return eval(a:__expr)
                            endfunction
                            
                            
    1              0.000003 function! s:base.to_list_by(expr)
                            	return filter(values(self.variables.hl_list), "s:_is_equal(a:expr, v:val)")
                            endfunction
                            
                            
    1              0.000002 function! s:base.enable_list(...)
                            	let window = get(a:, 1, s:Gift.uniq_winnr())
                            	return keys(get(self.variables.id_list, window, {}))
                            endfunction
                            
                            
    1              0.000002 function! s:base.delete(name)
                            	if !self.is_added(a:name)
                            		return -1
                            	endif
                            	unlet! self.variables.hl_list[a:name]
                            endfunction
                            
                            
    1              0.000002 function! s:base.delete_by(expr)
                            	return map(self.to_list_by(a:expr), "self.delete(v:val.name)")
                            endfunction
                            
                            
    1              0.000003 function! s:base.delete_all()
                            	for name in self.hl_list()
                            		call self.delete(name)
                            	endfor
                            endfunction
                            
                            
    1              0.000002 function! s:base.get_hl_id(name, ...)
                            	let window = get(a:, 1, s:Gift.uniq_winnr())
                            	return get(get(self.variables.id_list, window, {}), a:name, "")
                            endfunction
                            
                            
    1              0.000002 function! s:base.is_enabled(name, ...)
                            	let window = get(a:, 1, s:Gift.uniq_winnr())
                            	return self.get_hl_id(a:name, window) != ""
                            endfunction
                            
                            
    1              0.000003 function! s:base.enable(name)
                            	let hl = get(self.variables.hl_list, a:name, {})
                            	if empty(hl)
                            		return -1
                            	endif
                            	if self.is_enabled(a:name)
                            		call self.disable(a:name)
                            	endif
                            	let winnr = s:Gift.uniq_winnr()
                            	if !has_key(self.variables.id_list, winnr)
                            		let self.variables.id_list[winnr] = {}
                            	endif
                            	let self.variables.id_list[winnr][a:name] = matchadd(hl.group, hl.pattern, hl.priority)
                            endfunction
                            
                            
    1              0.000002 function! s:base.enable_all()
                            	for name in self.hl_list()
                            		call self.enable(name)
                            	endfor
                            endfunction
                            
                            
    1              0.000003 function! s:base.disable(name)
                            	if !self.is_enabled(a:name)
                            		return -1
                            	endif
                            	let id = -1
                            	silent! let id = matchdelete(self.get_hl_id(a:name))
                            	if id == -1
                            		return -1
                            	endif
                            	let winnr = get(a:, 1, s:Gift.uniq_winnr())
                            	unlet! self.variables.id_list[winnr][a:name]
                            endfunction
                            
                            
    1              0.000002 function! s:base.disable_all()
                            	for name in self.enable_list()
                            		call self.disable(name)
                            	endfor
                            endfunction
                            
                            
    1              0.000002 function! s:base.update(name)
                            	call self.disable(a:name)
                            	call self.enable(a:name)
                            endfunction
                            
                            
    1              0.000003 function! s:base.update_all()
                            	call self.disable_all()
                            	call self.enable_all()
                            endfunction
                            
                            
    1              0.000020 function! s:base.highlight(name, group, pattern, ...)
                            	let priority = get(a:, 1, 10)
                            	call self.add(a:name, a:group, a:pattern, priority)
                            	call self.enable(a:name)
                            endfunction
                            
                            
    1              0.000005 function! s:base.clear(name)
                            	call self.disable(a:name)
                            	call self.delete(a:name)
                            endfunction
                            
                            
    1              0.000003 function! s:base.clear_all()
                            	call self.disable_all()
                            	call self.delete_all()
                            endfunction
                            
                            
    1              0.000018 function! s:base.as_windo()
                            	return self.windo
                            endfunction
                            
                            
    1              0.000004 function! s:make()
                            	let result = deepcopy(s:base)
                            	let result.windo = s:Window.as_windo(result)
                            	return result
                            endfunction
                            
                            
    1              0.000021 let s:global = deepcopy(s:base)
    1              0.000180 let s:funcs =  keys(filter(copy(s:global), "type(v:val) == type(function('tr'))"))
                            
   22              0.000056 for s:name in s:funcs
   21              0.000360 	execute
                            \		"function! s:" . s:name . "(...) \n"
                            \			"return call(s:global." . s:name . ", a:000, s:global) \n"
                            \		"endfunction"
   22              0.000032 endfor
    1              0.000003 unlet s:name
                            
                            
    1              0.000003 function! s:_init()
                            	let s:global.windo = s:Window.as_windo(s:global)
                            endfunction
                            
                            " function! s:matchadd(...)
                            " 	return {
                            " \		"id" : call("matchadd", a:000),
                            " \		"bufnr" : bufnr("%"),
                            " \	}
                            " endfunction
                            "
                            "
                            " function! s:matchdelete(id)
                            " 	if empty(a:id)
                            " 		return -1
                            " 	endif
                            " 	return s:Buffer.execute(a:id.bufnr, "call matchdelete(" . a:id.id . ")")
                            " endfunction
                            
                            
    1   0.000020   0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Window.vim
Sourced 1 time
Total time:   0.000297
 Self time:   0.000269

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000164   0.000140 execute join(['function! vital#_incsearch#Coaster#Window#import() abort', printf("return map({'as_windo': '', '_vital_depends': '', 'windo': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000006 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Buffer = a:V.import("Vim.Buffer")
                            endfunction
                            
                            
    1              0.000004 function! s:_vital_depends()
                            	return [
                            \		"Vim.Buffer",
                            \	]
                            endfunction
                            
                            
    1              0.000004 function! s:windo(func, args, ...)
                            	let dict = get(a:, 1, {})
                            	if len(tabpagebuflist()) <= 1 || s:Buffer.is_cmdwin()
                            		return call(a:func, a:args, dict)
                            	endif
                            	let pre_winnr = winnr()
                            
                            	noautocmd windo call call(a:func, a:args, dict)
                            	
                            	if pre_winnr == winnr()
                            		return
                            	endif
                            	execute pre_winnr . "wincmd w"
                            endfunction
                            
                            
    1              0.000004 function! s:as_windo(base)
                            	let windo = {}
                            	let windo.obj = a:base
                            	for [key, Value] in items(a:base)
                            		if type(function("tr")) == type(Value)
                            			execute
                            \			"function! windo.". key. "(...)\n"
                            \			"	return s:windo(self.obj." . key . ", a:000, self.obj)\n"
                            \			"endfunction"
                            		endif
                            		unlet Value
                            	endfor
                            	return windo
                            endfunction
                            
                            
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Buffer.vim
Sourced 1 time
Total time:   0.000422
 Self time:   0.000402

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000058   0.000042 execute join(['function! vital#_incsearch#Vim#Buffer#import() abort', printf("return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000065 let s:save_cpo = &cpo
    1   0.000020   0.000018 set cpo&vim
                            
    1              0.000009 let s:t_funcref = type(function('tr'))
    1              0.000004 let s:t_string = type('')
    1              0.000004 let s:t_number = type(0)
                            
    1              0.000004 function! s:_vital_loaded(V) abort
                              let s:V = a:V
                              let s:Guard = s:V.import('Vim.Guard')
                            endfunction
                            
    1              0.000003 function! s:_vital_depends() abort
                              return ['Vim.Guard']
                            endfunction
                            
    1              0.000018 if exists('*getcmdwintype')
    1              0.000003   function! s:is_cmdwin() abort
                                return getcmdwintype() !=# ''
                              endfunction
                            else
                              function! s:is_cmdwin() abort
                                return bufname('%') ==# '[Command Line]'
                              endfunction
    1              0.000002 endif
                            
    1              0.000003 function! s:open(buffer, ...) abort
                              if a:0 == 1 && (type(a:1) == s:t_string || type(a:1) == s:t_funcref)
                                " For backward compatibility
                                let options = {'opener': a:1}
                              else
                                let options = get(a:000, 0, {})
                              endif
                              let options = extend({
                                    \ 'mods': '',
                                    \ 'cmdarg': '',
                                    \ 'opener': empty(a:buffer) ? 'enew' : 'edit',
                                    \}, options
                                    \)
                            
                              let guard = s:Guard.store(['&wildignore'])
                              try
                                let &wildignore = ''
                                if type(options.opener) == s:t_funcref
                                  let loaded = !bufloaded(a:buffer)
                                  call options.opener(a:buffer)
                                elseif a:buffer is 0 || a:buffer is# ''
                                  let loaded = 1
                                  silent execute options.mods options.opener
                                  enew
                                else
                                  let loaded = !bufloaded(a:buffer)
                                  if type(a:buffer) == s:t_string
                                    execute options.mods options.opener options.cmdarg '`=a:buffer`'
                                  elseif type(a:buffer) == s:t_number
                                    silent execute options.mods options.opener
                                    execute a:buffer 'buffer'
                                  else
                                    throw 'vital: Vim.Buffer: Unknown {buffer} type.'
                                  endif
                                endif
                              finally
                                call guard.restore()
                              endtry
                              return loaded
                            endfunction
                            
    1              0.000004 function! s:get_selected_text(...) abort
                              echohl WarningMsg
                              echom "vital: Vim.Buffer: Warning: s:get_selected_text() is deprecated. Use 's:get_last_selected()'."
                              echohl None
                              return call('s:get_last_selected', a:000)
                            endfunction
                            
                            " Get the last selected text in visual mode
                            " without using |gv| to avoid |textlock|.
                            " NOTE:
                            " * This function uses |gv| only when using |CTRL-V|
                            "   because |gv| is the only way to get selected text
                            "   when using <C-v>$ .
                            "   Please see #192 for the details.
                            " * If you don't care about |textlock|,
                            "   you can use simple version of this function.
                            "   https://github.com/vim-jp/vital.vim/commit/39aae80f3839fdbeebd838ff14d87327a6b889a9
    1              0.000004 function! s:get_last_selected() abort
                              if visualmode() ==# "\<C-v>"
                                let save = getreg('"', 1)
                                let save_type = getregtype('"')
                                try
                                  normal! gv""y
                                  return @"
                                finally
                                  call setreg('"', save, save_type)
                                endtry
                              else
                                let [begin, end] = [getpos("'<"), getpos("'>")]
                                let lastchar = matchstr(getline(end[1])[end[2]-1 :], '.')
                                if begin[1] ==# end[1]
                                  let lines = [getline(begin[1])[begin[2]-1 : end[2]-2]]
                                else
                                  let lines = [getline(begin[1])[begin[2]-1 :]]
                                  \         + (end[1] - begin[1] <# 2 ? [] : getline(begin[1]+1, end[1]-1))
                                  \         + [getline(end[1])[: end[2]-2]]
                                endif
                                return join(lines, "\n") . lastchar . (visualmode() ==# 'V' ? "\n" : '')
                              endif
                            endfunction
                            
    1              0.000004 function! s:read_content(content, ...) abort
                              let options = extend({
                                    \ 'tempfile': '',
                                    \ 'fileformat': '',
                                    \ 'encoding': '',
                                    \ 'binary': 0,
                                    \ 'nobinary': 0,
                                    \ 'bad': '',
                                    \ 'edit': 0,
                                    \ 'line': '',
                                    \ 'lockmarks': 0,
                                    \}, get(a:000, 0, {}))
                              let tempfile = empty(options.tempfile) ? tempname() : options.tempfile
                              let optnames = [
                                    \ empty(options.fileformat) ? '' : '++ff=' . options.fileformat,
                                    \ empty(options.encoding) ? '' : '++enc=' . options.encoding,
                                    \ empty(options.binary) ? '' : '++bin',
                                    \ empty(options.nobinary) ? '' : '++nobin',
                                    \ empty(options.bad) ? '' : '++bad=' . options.bad,
                                    \ empty(options.edit) ? '' : '++edit',
                                    \]
                              let optname = join(filter(optnames, '!empty(v:val)'))
                              try
                                call writefile(a:content, tempfile)
                                execute printf('keepalt keepjumps %s%sread %s%s',
                                      \ options.lockmarks ? 'lockmarks ' : '',
                                      \ options.line,
                                      \ empty(optname) ? '' : optname . ' ',
                                      \ fnameescape(tempfile),
                                      \)
                              finally
                                call delete(tempfile)
                                " To remove 'tempfile' from unlisted-buffer #439
                                silent execute 'bwipeout!' fnameescape(tempfile)
                              endtry
                            endfunction
                            
    1              0.000004 function! s:edit_content(content, ...) abort
                              let options = extend({
                                    \ 'edit': 1,
                                    \ 'lockmarks': 0,
                                    \}, get(a:000, 0, {}))
                              let guard = s:Guard.store(['&l:modifiable'])
                              let saved_view = winsaveview()
                              try
                                let &l:modifiable=1
                                silent execute printf(
                                      \ 'keepjumps %s%%delete _',
                                      \ options.lockmarks ? 'lockmarks ' : '',
                                      \)
                                silent call s:read_content(a:content, options)
                                silent execute printf(
                                      \ 'keepjumps %s1delete _',
                                      \ options.lockmarks ? 'lockmarks ' : '',
                                      \)
                              finally
                                keepjumps call winrestview(saved_view)
                                call guard.restore()
                              endtry
                              setlocal nomodified
                            endfunction
                            
    1              0.000003 function! s:parse_cmdarg(...) abort
                              let cmdarg = get(a:000, 0, v:cmdarg)
                              let options = {}
                              if cmdarg =~# '++enc='
                                let options.encoding = matchstr(cmdarg, '++enc=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++ff='
                                let options.fileformat = matchstr(cmdarg, '++ff=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++bad='
                                let options.bad = matchstr(cmdarg, '++bad=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++bin'
                                let options.binary = 1
                              endif
                              if cmdarg =~# '++nobin'
                                let options.nobinary = 1
                              endif
                              if cmdarg =~# '++edit'
                                let options.edit = 1
                              endif
                              return options
                            endfunction
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Guard.vim
Sourced 1 time
Total time:   0.000550
 Self time:   0.000517

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000086   0.000062 execute join(['function! vital#_incsearch#Vim#Guard#import() abort', printf("return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000006 delfunction s:_SID
                            " ___vital___
    1              0.000015 let s:save_cpo = &cpo
    1   0.000022   0.000019 set cpo&vim
                            
                            " Use a Funcref as a special term _UNDEFINED
    1              0.000005 function! s:_undefined() abort
                              return 'undefined'
                            endfunction
    1              0.000012 let s:_UNDEFINED = function('s:_undefined')
                            
    1              0.000005 function! s:_vital_loaded(V) abort
                              let s:V = a:V
                              let s:Prelude = s:V.import('Prelude')
                              let s:List = s:V.import('Data.List')
                              let s:Dict = s:V.import('Data.Dict')
                            endfunction
    1              0.000005 function! s:_vital_depends() abort
                              return ['Prelude', 'Data.List', 'Data.Dict']
                            endfunction
    1              0.000005 function! s:_vital_created(module) abort
                              " define constant variables
                              if !exists('s:const')
                                let s:const = {}
                                let s:const.is_local_variable_supported =
                                    \ v:version > 703 || (v:version == 703 && has('patch560'))
                                " NOTE:
                                " The third argument is available from 7.4.242 but it had bug and that
                                " bug was fixed from 7.4.513
                                let s:const.is_third_argument_of_getreg_supported = has('patch-7.4.513')
                                lockvar s:const
                              endif
                              call extend(a:module, s:const)
                            endfunction
    1              0.000005 function! s:_throw(msg) abort
                              throw printf('vital: Vim.Guard: %s', a:msg)
                            endfunction
                            
    1              0.000005 let s:option = {}
    1              0.000005 function! s:_new_option(name) abort
                              if a:name !~# '^&'
                                call s:_throw(printf(
                                      \'An option name "%s" requires to be started from "&"', a:name
                                      \))
                              elseif !exists(a:name)
                                call s:_throw(printf(
                                      \'An option name "%s" does not exist', a:name
                                      \))
                              endif
                              let option = copy(s:option)
                              let option.name = a:name
                              let option.value = eval(a:name)
                              return option
                            endfunction
    1              0.000004 function! s:option.restore() abort
                              execute printf('let %s = %s', self.name, string(self.value))
                            endfunction
                            
    1              0.000004 let s:register = {}
    1              0.000005 function! s:_new_register(name) abort
                              if len(a:name) != 2
                                call s:_throw(printf(
                                      \'A register name "%s" requires to be "@" + a single character', a:name
                                      \))
                              elseif a:name !~# '^@'
                                call s:_throw(printf(
                                      \'A register name "%s" requires to be started from "@"', a:name
                                      \))
                              elseif a:name =~# '^@[:.%]$'
                                call s:_throw(printf(
                                      \'A register name "%s" is read only', a:name
                                      \))
                              elseif a:name !~# '^@[@0-9a-zA-Z#=*+~_/-]$'
                                call s:_throw(printf(
                                      \'A register name "%s" does not exist. See ":help let-register"', a:name
                                      \))
                              endif
                              let name = a:name ==# '@@' ? '' : a:name[1]
                              let register = copy(s:register)
                              let register.name = name
                              if s:const.is_third_argument_of_getreg_supported
                                let register.value = getreg(name, 1, 1)
                              else
                                let register.value = getreg(name, 1)
                              endif
                              let register.type = getregtype(name)
                              return register
                            endfunction
    1              0.000004 function! s:register.restore() abort
                              " https://github.com/vim/vim/commit/5a50c2255c447838d08d3b4895a3be3a41cd8eda
                              if has('patch-7.4.243') || self.name !=# '='
                                call setreg(self.name, self.value, self.type)
                              else
                                let @= = self.value
                              endif
                            endfunction
                            
    1              0.000005 let s:environment = {}
    1              0.000005 function! s:_new_environment(name) abort
                              if a:name !~# '^\$'
                                call s:_throw(printf(
                                      \'An environment variable name "%s" requires to be started from "$"', a:name
                                      \))
                              elseif !exists(a:name)
                                call s:_throw(printf(
                                      \'An environment variable name "%s" does not exist. While Vim cannot unlet environment variable, it requires to exist', a:name
                                      \))
                              endif
                              let environment = copy(s:environment)
                              let environment.name = a:name
                              let environment.value = eval(a:name)
                              return environment
                            endfunction
    1              0.000004 function! s:environment.restore() abort
                              execute printf('let %s = %s', self.name, string(self.value))
                            endfunction
                            
    1              0.000008 let s:variable = {}
    1              0.000005 function! s:_new_variable(name, ...) abort
                              if a:0 == 0
                                let m = matchlist(a:name, '^\([bwtg]:\)\(.*\)$')
                                if empty(m)
                                  call s:_throw(printf(
                                        \ join([
                                        \   'An variable name "%s" requires to start from b:, w:, t:, or g:',
                                        \   'while no {namespace} is specified',
                                        \ ]),
                                        \ a:name,
                                        \))
                                endif
                                let [prefix, name] = m[1 : 2]
                                let namespace = eval(prefix)
                              else
                                let name = a:name
                                let namespace = a:1
                              endif
                              let variable = copy(s:variable)
                              let variable.name = name
                              let variable.value = get(namespace, name, s:_UNDEFINED)
                              let variable.value =
                                    \ type(variable.value) == type({}) || type(variable.value) == type([])
                                    \   ? deepcopy(variable.value)
                                    \   : variable.value
                              let variable._namespace = namespace
                              return variable
                            endfunction
    1              0.000004 function! s:variable.restore() abort
                              " unlet the variable to prevent variable type mis-match in case
                              silent! unlet! self._namespace[self.name]
                              if type(self.value) == type(s:_UNDEFINED) && self.value == s:_UNDEFINED
                                " do nothing, leave the variable as undefined
                              else
                                let self._namespace[self.name] = self.value
                              endif
                            endfunction
                            
    1              0.000005 let s:instance = {}
    1              0.000005 function! s:_new_instance(instance, ...) abort
                              let shallow = get(a:000, 0, 0)
                              if !s:Prelude.is_list(a:instance) && !s:Prelude.is_dict(a:instance)
                                call s:_throw(printf(
                                      \'An instance "%s" requires to be List or Dictionary', string(a:instance)
                                      \))
                              endif
                              let instance = copy(s:instance)
                              let instance.instance = a:instance
                              let instance.values = shallow ? copy(a:instance) : deepcopy(a:instance)
                              return instance
                            endfunction
    1              0.000003 function! s:instance.restore() abort
                              if s:Prelude.is_list(self.instance)
                                call s:List.clear(self.instance)
                              else
                                call s:Dict.clear(self.instance)
                              endif
                              call extend(self.instance, self.values)
                            endfunction
                            
    1              0.000004 let s:guard = {}
    1              0.000004 function! s:store(targets) abort
                              let resources = []
                              for meta in a:targets
                                if s:Prelude.is_list(meta)
                                  if len(meta) == 1
                                    call add(resources, s:_new_instance(meta[0]))
                                  elseif len(meta) == 2
                                    if s:Prelude.is_string(meta[0])
                                      call add(resources, call('s:_new_variable', meta))
                                    else
                                      call add(resources, call('s:_new_instance', meta))
                                    endif
                                  else
                                    call s:_throw('List assignment requires one or two elements')
                                  endif
                                elseif type(meta) == type('')
                                  if meta =~# '^[bwtgls]:'
                                    " Note:
                                    " To improve an error message, handle l:XXX or s:XXX as well
                                    call add(resources, s:_new_variable(meta))
                                  elseif meta =~# '^&'
                                    call add(resources, s:_new_option(meta))
                                  elseif meta =~# '^@'
                                    call add(resources, s:_new_register(meta))
                                  elseif meta =~# '^\$'
                                    call add(resources, s:_new_environment(meta))
                                  else
                                    call s:_throw(printf(
                                          \ 'Unknown value "%s" was specified',
                                          \ meta
                                          \))
                                  endif
                                endif
                                unlet meta
                              endfor
                              let guard = copy(s:guard)
                              let guard._resources = resources
                              return guard
                            endfunction
    1              0.000004 function! s:guard.restore() abort
                              for resource in self._resources
                                call resource.restore()
                              endfor
                            endfunction
                            
    1   0.000025   0.000019 let &cpo = s:save_cpo
    1              0.000003 unlet! s:save_cpo
                            " vim:set et ts=2 sts=2 sw=2 tw=0 fdm=marker:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Prelude.vim
Sourced 1 time
Total time:   0.000837
 Self time:   0.000812

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000088   0.000068 execute join(['function! vital#_incsearch#Prelude#import() abort', printf("return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000016 let s:save_cpo = &cpo
    1   0.000017   0.000015 set cpo&vim
                            
    1              0.000006 if v:version > 703 ||
                            \  (v:version == 703 && has('patch465'))
    1              0.000003   function! s:glob(expr) abort
                                return glob(a:expr, 1, 1)
                              endfunction
                            else
                              function! s:glob(expr) abort
                                return split(glob(a:expr, 1), '\n')
                              endfunction
    1              0.000001 endif
                            
    1              0.000005 if v:version > 704 ||
                            \  (v:version == 704 && has('patch279'))
    1              0.000003   function! s:globpath(path, expr) abort
                                return globpath(a:path, a:expr, 1, 1)
                              endfunction
                            else
                              function! s:globpath(path, expr) abort
                                return split(globpath(a:path, a:expr, 1), '\n')
                              endfunction
    1              0.000001 endif
                            
                            " Wrapper functions for type().
                            " NOTE: __TYPE_FLOAT = -1 when -float.
                            " this doesn't match to anything.
    1              0.000007 if has('patch-7.4.2071')
    1              0.000022   let [
                              \   s:__TYPE_NUMBER,
                              \   s:__TYPE_STRING,
                              \   s:__TYPE_FUNCREF,
                              \   s:__TYPE_LIST,
                              \   s:__TYPE_DICT,
                              \   s:__TYPE_FLOAT] = [
                                    \   v:t_number,
                                    \   v:t_string,
                                    \   v:t_func,
                                    \   v:t_list,
                                    \   v:t_dict,
                                    \   v:t_float]
                            else
                              let [
                              \   s:__TYPE_NUMBER,
                              \   s:__TYPE_STRING,
                              \   s:__TYPE_FUNCREF,
                              \   s:__TYPE_LIST,
                              \   s:__TYPE_DICT,
                              \   s:__TYPE_FLOAT] = [
                                    \   type(3),
                                    \   type(''),
                                    \   type(function('tr')),
                                    \   type([]),
                                    \   type({}),
                                    \   has('float') ? type(str2float('0')) : -1]
    1              0.000001 endif
                            
                            " Number or Float
    1              0.000004 function! s:is_numeric(Value) abort
                              let _ = type(a:Value)
                              return _ ==# s:__TYPE_NUMBER
                              \   || _ ==# s:__TYPE_FLOAT
                            endfunction
                            
                            " Number
    1              0.000003 function! s:is_number(Value) abort
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
                            
                            " String
    1              0.000003 function! s:is_string(Value) abort
                              return type(a:Value) ==# s:__TYPE_STRING
                            endfunction
                            
                            " Funcref
    1              0.000004 function! s:is_funcref(Value) abort
                              return type(a:Value) ==# s:__TYPE_FUNCREF
                            endfunction
                            
                            " List
    1              0.000003 function! s:is_list(Value) abort
                              return type(a:Value) ==# s:__TYPE_LIST
                            endfunction
                            
                            " Dictionary
    1              0.000003 function! s:is_dict(Value) abort
                              return type(a:Value) ==# s:__TYPE_DICT
                            endfunction
                            
                            " Float
    1              0.000003 function! s:is_float(Value) abort
                              return type(a:Value) ==# s:__TYPE_FLOAT
                            endfunction
                            
                            
    1              0.000006 function! s:truncate_skipping(str, max, footer_width, separator) abort
                              call s:_warn_deprecated('truncate_skipping', 'Data.String.truncate_skipping')
                            
                              let width = s:wcswidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - s:wcswidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator
                                      \ . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                            
                              return s:truncate(ret, a:max)
                            endfunction
                            
    1              0.000004 function! s:truncate(str, width) abort
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              call s:_warn_deprecated('truncate', 'Data.String.truncate')
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ?
                                      \ printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000004 function! s:strwidthpart(str, width) abort
                              call s:_warn_deprecated('strwidthpart', 'Data.String.strwidthpart')
                            
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
    1              0.000004 function! s:strwidthpart_reverse(str, width) abort
                              call s:_warn_deprecated('strwidthpart_reverse', 'Data.String.strwidthpart_reverse')
                            
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '^.')
                                let ret = ret[len(char) :]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
                            
    1              0.000003 if v:version >= 703
                              " Use builtin function.
    1              0.000003   function! s:wcswidth(str) abort
                                call s:_warn_deprecated('wcswidth', 'Data.String.wcswidth')
                                return strwidth(a:str)
                              endfunction
                            else
                              function! s:wcswidth(str) abort
                                call s:_warn_deprecated('wcswidth', 'Data.String.wcswidth')
                            
                                if a:str =~# '^[\x00-\x7f]*$'
                                  return strlen(a:str)
                                end
                            
                                let mx_first = '^\(.\)'
                                let str = a:str
                                let width = 0
                                while 1
                                  let ucs = char2nr(substitute(str, mx_first, '\1', ''))
                                  if ucs == 0
                                    break
                                  endif
                                  let width += s:_wcwidth(ucs)
                                  let str = substitute(str, mx_first, '', '')
                                endwhile
                                return width
                              endfunction
                            
                              " UTF-8 only.
                              function! s:_wcwidth(ucs) abort
                                let ucs = a:ucs
                                if (ucs >= 0x1100
                                      \  && (ucs <= 0x115f
                                      \  || ucs == 0x2329
                                      \  || ucs == 0x232a
                                      \  || (ucs >= 0x2e80 && ucs <= 0xa4cf
                                      \      && ucs != 0x303f)
                                      \  || (ucs >= 0xac00 && ucs <= 0xd7a3)
                                      \  || (ucs >= 0xf900 && ucs <= 0xfaff)
                                      \  || (ucs >= 0xfe30 && ucs <= 0xfe6f)
                                      \  || (ucs >= 0xff00 && ucs <= 0xff60)
                                      \  || (ucs >= 0xffe0 && ucs <= 0xffe6)
                                      \  || (ucs >= 0x20000 && ucs <= 0x2fffd)
                                      \  || (ucs >= 0x30000 && ucs <= 0x3fffd)
                                      \  ))
                                  return 2
                                endif
                                return 1
                              endfunction
    1              0.000001 endif
                            
    1              0.000019 let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')
    1              0.000006 let s:is_cygwin = has('win32unix')
    1              0.000024 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
    1              0.000005 let s:is_unix = has('unix')
                            
    1              0.000004 function! s:is_windows() abort
                              return s:is_windows
                            endfunction
                            
    1              0.000003 function! s:is_cygwin() abort
                              return s:is_cygwin
                            endfunction
                            
    1              0.000002 function! s:is_mac() abort
                              return s:is_mac
                            endfunction
                            
    1              0.000003 function! s:is_unix() abort
                              return s:is_unix
                            endfunction
                            
    1              0.000004 function! s:_warn_deprecated(name, alternative) abort
                              try
                                echohl Error
                                echomsg 'Prelude.' . a:name . ' is deprecated!  Please use ' . a:alternative . ' instead.'
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000005 function! s:smart_execute_command(action, word) abort
                              execute a:action . ' ' . (a:word ==# '' ? '' : '`=a:word`')
                            endfunction
                            
    1              0.000004 function! s:escape_file_searching(buffer_name) abort
                              return escape(a:buffer_name, '*[]?{}, ')
                            endfunction
                            
    1              0.000004 function! s:escape_pattern(str) abort
                              call s:_warn_deprecated(
                                    \ 'escape_pattern',
                                    \ 'Data.String.escape_pattern',
                                    \)
                              return escape(a:str, '~"\.^$[]*')
                            endfunction
                            
    1              0.000003 function! s:getchar(...) abort
                              let c = call('getchar', a:000)
                              return type(c) == type(0) ? nr2char(c) : c
                            endfunction
                            
    1              0.000006 function! s:getchar_safe(...) abort
                              let c = s:input_helper('getchar', a:000)
                              return type(c) == type('') ? c : nr2char(c)
                            endfunction
                            
    1              0.000005 function! s:input_safe(...) abort
                              return s:input_helper('input', a:000)
                            endfunction
                            
    1              0.000005 function! s:input_helper(funcname, args) abort
                              let success = 0
                              if inputsave() !=# success
                                throw 'vital: Prelude: inputsave() failed'
                              endif
                              try
                                return call(a:funcname, a:args)
                              finally
                                if inputrestore() !=# success
                                  throw 'vital: Prelude: inputrestore() failed'
                                endif
                              endtry
                            endfunction
                            
    1              0.000008 function! s:set_default(var, val) abort
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let {a:var} = a:val
                              endif
                            endfunction
                            
    1              0.000005 function! s:substitute_path_separator(path) abort
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction
                            
    1              0.000004 function! s:path2directory(path) abort
                              return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))
                            endfunction
                            
    1              0.000004 function! s:_path2project_directory_git(path) abort
                              let parent = a:path
                            
                              while 1
                                let path = parent . '/.git'
                                if isdirectory(path) || filereadable(path)
                                  return parent
                                endif
                                let next = fnamemodify(parent, ':h')
                                if next == parent
                                  return ''
                                endif
                                let parent = next
                              endwhile
                            endfunction
                            
    1              0.000005 function! s:_path2project_directory_svn(path) abort
                              let search_directory = a:path
                              let directory = ''
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir('.svn', find_directory . ';')
                              if d ==# ''
                                return ''
                              endif
                            
                              let directory = fnamemodify(d, ':p:h:h')
                            
                              " Search parent directories.
                              let parent_directory = s:path2directory(
                                    \ fnamemodify(directory, ':h'))
                            
                              if parent_directory !=# ''
                                let d = finddir('.svn', parent_directory . ';')
                                if d !=# ''
                                  let directory = s:_path2project_directory_svn(parent_directory)
                                endif
                              endif
                              return directory
                            endfunction
                            
    1              0.000006 function! s:_path2project_directory_others(vcs, path) abort
                              let vcs = a:vcs
                              let search_directory = a:path
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir(vcs, find_directory . ';')
                              if d ==# ''
                                return ''
                              endif
                              return fnamemodify(d, ':p:h:h')
                            endfunction
                            
    1              0.000004 function! s:path2project_directory(path, ...) abort
                              let is_allow_empty = get(a:000, 0, 0)
                              let search_directory = s:path2directory(a:path)
                              let directory = ''
                            
                              " Search VCS directory.
                              for vcs in ['.git', '.bzr', '.hg', '.svn']
                                if vcs ==# '.git'
                                  let directory = s:_path2project_directory_git(search_directory)
                                elseif vcs ==# '.svn'
                                  let directory = s:_path2project_directory_svn(search_directory)
                                else
                                  let directory = s:_path2project_directory_others(vcs, search_directory)
                                endif
                                if directory !=# ''
                                  break
                                endif
                              endfor
                            
                              " Search project file.
                              if directory ==# ''
                                for d in ['build.xml', 'prj.el', '.project', 'pom.xml', 'package.json',
                                      \ 'Makefile', 'configure', 'Rakefile', 'NAnt.build',
                                      \ 'P4CONFIG', 'tags', 'gtags']
                                  let d = findfile(d, s:escape_file_searching(search_directory) . ';')
                                  if d !=# ''
                                    let directory = fnamemodify(d, ':p:h')
                                    break
                                  endif
                                endfor
                              endif
                            
                              if directory ==# ''
                                " Search /src/ directory.
                                let base = s:substitute_path_separator(search_directory)
                                if base =~# '/src/'
                                  let directory = base[: strridx(base, '/src/') + 3]
                                endif
                              endif
                            
                              if directory ==# '' && !is_allow_empty
                                " Use original path.
                                let directory = search_directory
                              endif
                            
                              return s:substitute_path_separator(directory)
                            endfunction
                            
    1   0.000021   0.000018 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/Dict.vim
Sourced 1 time
Total time:   0.000426
 Self time:   0.000387

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000104   0.000072 execute join(['function! vital#_incsearch#Data#Dict#import() abort', printf("return map({'_vital_depends': '', 'clear': '', 'max_by': '', 'foldl': '', 'pick': '', 'from_list': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
                            " Utilities for dictionary.
                            
    1              0.000013 let s:save_cpo = &cpo
    1   0.000020   0.000017 set cpo&vim
                            
    1              0.000005 function! s:_vital_loaded(V) abort
                              let s:t = a:V.import('Vim.Type').types
                            endfunction
                            
    1              0.000004 function! s:_vital_depends() abort
                              return ['Vim.Type']
                            endfunction
                            
                            
    1              0.000003 function! s:_ensure_key(key) abort
                              let t = type(a:key)
                              if t != s:t.string && t != s:t.number
                                throw 'vital: Data.Dict: Invalid key: ' . string(a:key)
                              endif
                            endfunction
                            
    1              0.000003 function! s:from_list(list) abort
                              let dict = {}
                              let i = 0
                              let len = len(a:list)
                              while i < len
                                if type(a:list[i]) == s:t.list
                                  let key_value = a:list[i]
                                  if len(key_value) != 2
                                    throw 'vital: Data.Dict: Invalid key-value pair index at ' . i
                                  endif
                                  call s:_ensure_key(key_value[0])
                                  let dict[key_value[0]] = key_value[1]
                                  let i += 1
                                else
                                  if len <= i + 1
                                    throw 'vital: Data.Dict: Invalid key-value pair index at ' . i
                                  endif
                                  call s:_ensure_key(a:list[i])
                                  let dict[a:list[i]] = a:list[i + 1]
                                  let i += 2
                                endif
                              endwhile
                              return dict
                            endfunction
                            
                            " Makes a dict from keys and values
    1              0.000003 function! s:make(keys, values, ...) abort
                              let dict = {}
                              let fill = a:0 ? a:1 : 0
                              for i in range(len(a:keys))
                                let key = type(a:keys[i]) == s:t.string ? a:keys[i] : string(a:keys[i])
                                if key ==# ''
                                  throw "vital: Data.Dict: Can't use an empty string for key."
                                endif
                                let dict[key] = get(a:values, i, fill)
                              endfor
                              return dict
                            endfunction
                            
                            " Swaps keys and values
    1              0.000003 function! s:swap(dict) abort
                              return s:make(values(a:dict), keys(a:dict))
                            endfunction
                            
                            " Makes a index dict from a list
    1              0.000003 function! s:make_index(list, ...) abort
                              let value = a:0 ? a:1 : 1
                              return s:make(a:list, [], value)
                            endfunction
                            
    1              0.000003 function! s:pick(dict, keys) abort
                              let new_dict = {}
                              for key in a:keys
                                if has_key(a:dict, key)
                                  let new_dict[key] = a:dict[key]
                                endif
                              endfor
                              return new_dict
                            endfunction
                            
    1              0.000003 function! s:omit(dict, keys) abort
                              let new_dict = copy(a:dict)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  call remove(new_dict, key)
                                endif
                              endfor
                              return new_dict
                            endfunction
                            
    1              0.000007 function! s:clear(dict) abort
                              for key in keys(a:dict)
                                call remove(a:dict, key)
                              endfor
                              return a:dict
                            endfunction
                            
    1              0.000005 function! s:_max_by(dict, expr) abort
                              let dict = s:swap(map(copy(a:dict), a:expr))
                              let key = dict[max(keys(dict))]
                              return [key, a:dict[key]]
                            endfunction
                            
    1              0.000005 function! s:max_by(dict, expr) abort
                              if empty(a:dict)
                                throw 'vital: Data.Dict: Empty dictionary'
                              endif
                              return s:_max_by(a:dict, a:expr)
                            endfunction
                            
    1              0.000004 function! s:min_by(dict, expr) abort
                              if empty(a:dict)
                                throw 'vital: Data.Dict: Empty dictionary'
                              endif
                              return s:_max_by(a:dict, '-(' . a:expr . ')')
                            endfunction
                            
    1              0.000004 function! s:_foldl(f, init, xs) abort
                              let memo = a:init
                              for [k, v] in a:xs
                                let expr = substitute(a:f, 'v:key', string(k), 'g')
                                let expr = substitute(expr, 'v:val', string(v), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
    1              0.000005 function! s:foldl(f, init, dict) abort
                              return s:_foldl(a:f, a:init, items(a:dict))
                            endfunction
                            
    1              0.000005 function! s:foldr(f, init, dict) abort
                              return s:_foldl(a:f, a:init, reverse(items(a:dict)))
                            endfunction
                            
    1   0.000027   0.000023 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Type.vim
Sourced 1 time
Total time:   0.000171
 Self time:   0.000148

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000078   0.000055 execute join(['function! vital#_incsearch#Vim#Type#import() abort', printf("return map({'_vital_created': '', 'is_predicate': '', 'is_numeric': '', 'is_special': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000016 let s:types = {
                            \   'number': 0,
                            \   'string': 1,
                            \   'func': 2,
                            \   'list': 3,
                            \   'dict': 4,
                            \   'float': 5,
                            \   'bool': 6,
                            \   'none': 7,
                            \   'job': 8,
                            \   'channel': 9,
                            \ }
    1              0.000003 lockvar 1 s:types
                            
    1              0.000014 let s:type_names = {
                            \   '0': 'number',
                            \   '1': 'string',
                            \   '2': 'func',
                            \   '3': 'list',
                            \   '4': 'dict',
                            \   '5': 'float',
                            \   '6': 'bool',
                            \   '7': 'none',
                            \   '8': 'job',
                            \   '9': 'channel',
                            \ }
    1              0.000002 lockvar 1 s:type_names
                            
    1              0.000004 function! s:_vital_created(module) abort
                              let a:module.types = s:types
                              let a:module.type_names = s:type_names
                            endfunction
                            
                            
    1              0.000003 function! s:is_numeric(value) abort
                              let t = type(a:value)
                              return t == s:types.number || t == s:types.float
                            endfunction
                            
    1              0.000004 function! s:is_special(value) abort
                              let t = type(a:value)
                              return t == s:types.bool || t == s:types.none
                            endfunction
                            
    1              0.000004 function! s:is_predicate(value) abort
                              let t = type(a:value)
                              return t == s:types.number || t == s:types.string ||
                              \ t == s:types.bool || t == s:types.none
                            endfunction

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift.vim
Sourced 1 time
Total time:   0.000331
 Self time:   0.000310

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000005 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000075   0.000058 execute join(['function! vital#_incsearch#Gift#import() abort', printf("return map({'flatten': '', 'uniq_tabpagenr': '', 'tabpagewinnr_list': '', 'execute': '', 'getwinvar': '', 'winnr': '', 'jump_window': '', '_vital_depends': '', 'uniq_winnr': '', 'setwinvar': '', 'find': '', 'openable_bufnr_list': '', 'to_fullpath': '', 'bufnr': '', 'set_current_window': '', 'tabpagewinnr': '', 'close_window': '', 'close_window_by': '', 'uniq_winnr_list': '', '_vital_loaded': '', 'find_by': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000004 delfunction s:_SID
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000019   0.000017 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Window = s:V.import("Gift.Window")
                            	let s:Tabpage = s:V.import("Gift.Tabpage")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Gift.Window",
                            \		"Gift.Tabpage",
                            \	]
                            endfunction
                            
                            
    1              0.000003 function! s:to_fullpath(filename)
                            	let name = substitute(fnamemodify(a:filename, ":p"), '\', '/', "g")
                            	if filereadable(name)
                            		return name
                            	else
                            		return a:filename
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! s:flatten(list)
                            	return eval(join(a:list, "+"))
                            endfunction
                            
                            
    1              0.000003 function! s:bufnr(expr)
                            	return type(a:expr) == type([])
                            \		 ? s:bufnr(s:uniq_winnr(a:expr[1], a:expr[0]))
                            \		 : s:Window.bufnr(a:expr)
                            endfunction
                            
                            
    1              0.000004 function! s:openable_bufnr_list()
                            	return map(s:tabpagewinnr_list(), "s:bufnr([v:val[0], v:val[1]])")
                            endfunction
                            
                            
    1              0.000004 function! s:tabpagewinnr(...)
                            	return a:0 == 0 ? s:tabpagewinnr(s:uniq_winnr())
                            \		 : s:Window.tabpagewinnr(a:1)
                            endfunction
                            
                            
    1              0.000004 function! s:tabpagewinnr_list()
                            	return s:Window.tabpagewinnr_list()
                            " 	return s:flatten(map(range(1, tabpagenr("$")), "map(range(1, tabpagewinnr(v:val, '$')), '['.v:val.', v:val]')"))
                            endfunction
                            
                            
                            
    1              0.000003 function! s:uniq_winnr(...)
                            	return call(s:Window.uniq_nr, a:000, s:Window)
                            endfunction
                            
                            
    1              0.000003 function! s:winnr(uniqnr)
                            	let [tabnr, winnr] = s:Window.tabpagewinnr(a:uniqnr)
                            	return winnr
                            endfunction
                            
                            
    1              0.000003 function! s:uniq_winnr_list(...)
                            	return map(s:tabpagewinnr_list(), "s:uniq_winnr(v:val[1], v:val[0])")
                            endfunction
                            
                            
                            
    1              0.000002 function! s:find(expr)
                            	let gift_find_result = []
                            	for [tabnr, winnr] in s:tabpagewinnr_list()
                            		let bufnr = s:bufnr([tabnr, winnr])
                            		if eval(a:expr)
                            			call add(gift_find_result, [tabnr, winnr])
                            		endif
                            	endfor
                            	return gift_find_result
                            endfunction
                            
                            
    1              0.000003 function! s:find_by(expr)
                            	if type(a:expr) == type(function("tr"))
                            		return filter(s:tabpagewinnr_list(), "a:expr(s:bufnr([v:val[0], v:val[1]]), v:val[0], v:val[1])")
                            	else
                            		return s:find(a:expr)
                            	endif
                            endfunction
                            
                            
    1              0.000004 function! s:jump_window(expr)
                            	return type(a:expr) == type([])
                            \		 ? s:jump_window(s:uniq_winnr(a:expr[1], a:expr[0]))
                            \		 : s:Window.jump(a:expr)
                            endfunction
                            
                            
    1              0.000004 function! s:set_current_window(expr)
                            	return s:jump_window(a:expr)
                            endfunction
                            
                            
    1              0.000003 function! s:close_window(expr, ...)
                            	let close_cmd = get(a:, 1, "close")
                            	return type(a:expr) == type([])
                            \		 ? s:close_window(s:uniq_winnr(a:expr[1], a:expr[0]), close_cmd)
                            \		 : s:Window.close(a:expr, close_cmd)
                            endfunction
                            
                            
    1              0.000003 function! s:close_window_by(expr, ...)
                            	let close_cmd = get(a:, 1, "close")
                            	return map(map(s:find(a:expr), "s:uniq_winnr(v:val[1], v:val[0])"), 's:close_window(v:val, close_cmd)')
                            endfunction
                            
                            
    1              0.000003 function! s:execute(expr, execute)
                            	return type(a:expr) == type([])
                            \		 ? s:execute(s:uniq_winnr(a:expr[1], a:expr[0]), a:execute)
                            \		 : s:Window.execute(a:expr, a:execute)
                            endfunction
                            
                            
    1              0.000003 function! s:getwinvar(uniq_winnr, varname, ...)
                            	let def = get(a:, 1, "")
                            	return s:Window.getvar(a:uniq_winnr, a:varname, def)
                            endfunction
                            
                            
    1              0.000004 function! s:setwinvar(uniq_winnr, varname, val)
                            	return s:Window.setvar(a:uniq_winnr, a:varname, a:val)
                            endfunction
                            
                            
    1              0.000003 function! s:uniq_tabpagenr(...)
                            	return call(s:Tabpage.uniq_nr, a:000, s:Tabpage)
                            endfunction
                            
                            
                            
    1   0.000017   0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Window.vim
Sourced 1 time
Total time:   0.000328
 Self time:   0.000304

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000071   0.000051 execute join(['function! vital#_incsearch#Gift#Window#import() abort', printf("return map({'flatten': '', 'tabpagewinnr_list': '', 'execute': '', 'close': '', 'numbering': '', 'set_prefix': '', '_vital_depends': '', 'exists': '', 'jump': '', 'setvar': '', 'bufnr': '', 'uniq_nr': '', 'make_uniq_nr': '', 'tabpagewinnr': '', 'getvar': '', '_vital_loaded': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000005 delfunction s:_SID
                            " ___vital___
    1              0.000003 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000018   0.000016 set cpo&vim
                            
                            
    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Tabpage = s:V.import("Gift.Tabpage")
                            endfunction
                            
                            
    1              0.000003 function! s:_vital_depends()
                            	return [
                            \		"Gift.Tabpage",
                            \	]
                            endfunction
                            
                            
    1              0.000013 let s:prefix = expand("<sfile>:p:h:h:t")
    1              0.000003 function! s:set_prefix(prefix)
                            	let s:prefix = a:prefix
                            endfunction
                            
    1              0.000003 function! s:flatten(list)
                            	return eval(join(a:list, "+"))
                            endfunction
                            
                            
    1              0.000004 function! s:tabpagewinnr_list()
                            	return s:flatten(map(range(1, tabpagenr("$")), "map(range(1, tabpagewinnr(v:val, '$')), '['.v:val.', v:val]')"))
                            endfunction
                            
                            
    1              0.000005 if !exists("s:uniq_counter")
    1              0.000004 	let s:uniq_counter = 0
    1              0.000001 endif
    1              0.000003 function! s:make_uniq_nr()
                            	let s:uniq_counter += 1
                            	return s:uniq_counter
                            endfunction
                            
                            
    1              0.000003 function! s:numbering(...)
                            	let winnr = get(a:, 1, winnr())
                            	let tabnr = get(a:, 2, tabpagenr())
                            	let uniq_nr = s:make_uniq_nr()
                            	call settabwinvar(tabnr, winnr, s:prefix . "_gift_uniq_winnr", uniq_nr)
                            	return uniq_nr
                            endfunction
                            
                            
    1              0.000002 function! s:uniq_nr(...)
                            	let winnr = get(a:, 1, winnr())
                            	let tabnr = get(a:, 2, tabpagenr())
                            	let uniq_nr = get(gettabwinvar(tabnr, winnr, ""), s:prefix . "_gift_uniq_winnr", -1)
                            	if uniq_nr == -1
                            		let uniq_nr = s:numbering(winnr, tabnr)
                            	endif
                            	return uniq_nr
                            endfunction
                            
                            
    1              0.000002 function! s:exists(nr)
                            	let [tabnr, winnr] = s:tabpagewinnr(a:nr)
                            	return tabnr != 0 && winnr != 0
                            endfunction
                            
                            
    1              0.000003 function! s:tabpagewinnr(nr)
                            	if a:nr == 0
                            		return s:tabpagewinnr(s:uniq_nr())
                            	endif
                            	let tabwinnrs = s:tabpagewinnr_list()
                            	for [tabnr, winnr] in tabwinnrs
                            		if s:uniq_nr(winnr, tabnr) == a:nr
                            			return [tabnr, winnr]
                            		endif
                            	endfor
                            	return [0, 0]
                            endfunction
                            
                            
    1              0.000003 function! s:getvar(nr, varname, ...)
                            	let def = get(a:, 1, "")
                            	let [tabnr, winnr] = s:tabpagewinnr(a:nr)
                            	return get(gettabwinvar(tabnr, winnr, ""), a:varname, def)
                            endfunction
                            
                            
    1              0.000004 function! s:setvar(nr, varname, val)
                            	let [tabnr, winnr] = s:tabpagewinnr(a:nr)
                            	if tabnr == 0 || winnr == 0
                            		return
                            	endif
                            	return settabwinvar(tabnr, winnr, a:varname, a:val)
                            endfunction
                            
                            
    1              0.000003 function! s:bufnr(nr)
                            	let [tabnr, winnr] = s:tabpagewinnr(a:nr)
                            	return winnr >= 1 ? get(tabpagebuflist(tabnr), winnr-1, -1) : -1
                            endfunction
                            
                            
                            
    1              0.000002 function! s:jump(nr)
                            	let [tabnr, winnr] = s:tabpagewinnr(a:nr)
                            	if tabnr == 0 || winnr == 0
                            		return -1
                            	endif
                            
                            	execute "tabnext" tabnr
                            	execute winnr . "wincmd w"
                            endfunction
                            
                            
    1              0.000004 function! s:close(nr, close_cmd)
                            	call s:execute(a:nr, a:close_cmd)
                            " 	let current = gift#uniq_winnr()
                            " 	let result = s:jump(a:nr)
                            " 	if result == -1
                            " 		return -1
                            " 	endif
                            " 	execute a:close_cmd
                            " 	return s:jump(current)
                            endfunction
                            
                            
    1              0.000003 function! s:execute(nr, expr)
                            	let current = s:uniq_nr()
                            	let result = s:jump(a:nr)
                            	if result == -1
                            		return -1
                            	endif
                            	execute a:expr
                            	return s:jump(current)
                            endfunction
                            
                            
                            
                            
                            
    1   0.000016   0.000014 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Tabpage.vim
Sourced 1 time
Total time:   0.000245
 Self time:   0.000223

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000004 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000051   0.000035 execute join(['function! vital#_incsearch#Gift#Tabpage#import() abort', printf("return map({'uniq_nr': '', 'make_uniq_nr': '', 'numbering': '', 'set_prefix': ''}, \"vital#_incsearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000003 delfunction s:_SID
                            " ___vital___
    1              0.000002 scriptencoding utf-8
    1              0.000030 let s:save_cpo = &cpo
    1   0.000059   0.000055 set cpo&vim
                            
                            
    1              0.000017 let s:prefix = expand("<sfile>:p:h:h:t")
    1              0.000005 function! s:set_prefix(prefix)
                            	let s:prefix = a:prefix
                            endfunction
                            
                            
    1              0.000004 let s:uniq_counter = 0
    1              0.000003 function! s:make_uniq_nr()
                            	let s:uniq_counter += 1
                            	return s:uniq_counter
                            endfunction
                            
                            
    1              0.000003 function! s:numbering(...)
                            	let tabnr = get(a:, 1, tabpagenr())
                            	let uniq_nr = s:make_uniq_nr()
                            	call settabvar(tabnr, s:prefix . "_gift_uniq_tabpagenr", uniq_nr)
                            	return uniq_nr
                            endfunction
                            
                            
    1              0.000003 function! s:uniq_nr(...)
                            	let tabnr = get(a:, 1, tabpagenr())
                            	let uniq_nr = get(gettabvar(tabnr, ""), s:prefix . "_gift_uniq_tabpagenr", -1)
                            	if uniq_nr == -1
                            		let uniq_nr = s:numbering(tabnr)
                            	endif
                            	return uniq_nr
                            endfunction
                            
                            
    1   0.000018   0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim
Sourced 1 time
Total time:   0.000383
 Self time:   0.000218

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/over/extend.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000003 scriptencoding utf-8
    1              0.000015 let s:save_cpo = &cpo
    1   0.000019   0.000018 set cpo&vim
                            
    1              0.000003 let s:TRUE = !0
    1              0.000003 let s:FALSE = 0
    1              0.000007 let s:non_escaped_backslash = '\m\%(\%(^\|[^\\]\)\%(\\\\\)*\)\@<=\\'
                            
    1   0.000180   0.000017 let s:U = incsearch#util#import()
                            
    1              0.000004 function! incsearch#over#extend#enrich(cli) abort
                              return extend(a:cli, s:cli)
                            endfunction
                            
    1              0.000010 let s:cli = {
                            \   '_does_exit_from_incsearch': s:FALSE,
                            \   '_return_cmd': '',
                            \   '_converter_cache': {}
                            \ }
                            
    1              0.000003 function! s:cli._generate_command(input) abort
                              let is_cancel = self.exit_code()
                              if is_cancel
                                return s:U.is_visual(self._mode) ? '\<ESC>gv' : "\<ESC>"
                              else
                                call self._call_execute_event()
                                let [pattern, offset] = incsearch#parse_pattern(a:input, self._base_key)
                                " TODO: implement convert input method
                                let p = self._combine_pattern(self._convert(pattern), offset)
                                return self._build_search_cmd(p)
                              endif
                            endfunction
                            
                            " @return search cmd
    1              0.000003 function! s:cli._build_search_cmd(pattern, ...) abort
                              let mode = get(a:, 1, self._mode)
                              let op = (mode ==# 'no')      ? v:operator
                              \      : s:U.is_visual(mode) ? 'gv'
                              \      : ''
                              let zv = (&foldopen =~# '\vsearch|all' && mode !=# 'no' ? 'zv' : '')
                              " NOTE:
                              "   Should I consider o_v, o_V, and o_CTRL-V cases and do not
                              "   <Esc>? <Esc> exists for flexible v:count with using s:cli._vcount1,
                              "   but, if you do not move the cursor while incremental searching,
                              "   there are no need to use <Esc>.
                              let esc = self._has_count ? "\<Esc>" : ''
                              let register = esc is# '' ? '' : '"' . v:register
                              let cnt = self._vcount1 is# 1 ? '' : self._vcount1
                              let prefix = esc .  register . (esc is# '' ? '' : op) . cnt
                              return printf("%s%s%s\<CR>%s", prefix, self._base_key, a:pattern, zv)
                            endfunction
                            
                            "" Call on_execute_pre and on_execute event
                            " assume current position is the destination and a:cli._w is the position to
                            " start search
    1              0.000002 function! s:cli._call_execute_event(...) abort
                              let view = get(a:, 1, winsaveview())
                              try
                                call winrestview(self._w)
                                call self.callevent('on_execute_pre')
                              finally
                                call winrestview(view)
                              endtry
                              call self.callevent('on_execute')
                            endfunction
                            
    1              0.000002 function! s:cli._parse_pattern() abort
                              if v:version == 704 && !has('patch421')
                                " Ignore \ze* which clash vim 7.4 without 421 patch
                                " Assume `\m`
                                let [p, o] = incsearch#parse_pattern(self.getline(), self._base_key)
                                let p = (p =~# s:non_escaped_backslash . 'z[se]\%(\*\|\\+\)' ? '' : p)
                                return [p, o]
                              else
                                return incsearch#parse_pattern(self.getline(), self._base_key)
                              endif
                            endfunction
                            
    1              0.000003 function! s:cli._combine_pattern(pattern, offset) abort
                              return empty(a:offset) ? a:pattern : a:pattern . self._base_key . a:offset
                            endfunction
                            
    1              0.000002 function! s:cli._convert(pattern) abort
                              if a:pattern is# ''
                                return a:pattern
                              elseif empty(self._converters)
                                return incsearch#magic() . a:pattern
                              elseif has_key(self._converter_cache, a:pattern)
                                return self._converter_cache[a:pattern]
                              else
                                let ps = [incsearch#magic() . a:pattern]
                                for l:Converter in self._converters
                                  let l:Convert = type(l:Converter) is type(function('function'))
                                  \ ? l:Converter : l:Converter.convert
                                  let ps += [l:Convert(a:pattern)]
                                  unlet l:Converter
                                endfor
                                " Converters may return upper case even if a:pattern doesn't contain upper
                                " case letter, so prepend case flag explicitly
                                " let case = incsearch#detect_case(a:pattern)
                                let case = incsearch#detect_case(a:pattern)
                                let self._converter_cache[a:pattern] =  case . s:U.regexp_join(ps)
                                return self._converter_cache[a:pattern]
                              endif
                            endfunction
                            
    1              0.000003 function! s:cli._exit_incsearch(...) abort
                              let cmd = get(a:, 1, '')
                              let self._return_cmd = cmd
                              let self._does_exit_from_incsearch = s:TRUE
                              call self.exit()
                            endfunction
                            
    1   0.000018   0.000017 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/incsearch.vim/autoload/incsearch/autocmd.vim
Sourced 1 time
Total time:   0.000419
 Self time:   0.000412

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/incsearch/autocmd.vim
                            " AUTHOR: haya14busa
                            " License: MIT license
                            "=============================================================================
    1              0.000006 scriptencoding utf-8
    1              0.000022 let s:save_cpo = &cpo
    1   0.000025   0.000022 set cpo&vim
                            
    1              0.000137 noremap  <silent><expr> <Plug>(_incsearch-nohlsearch) incsearch#autocmd#auto_nohlsearch(0)
    1              0.000066 noremap! <silent><expr> <Plug>(_incsearch-nohlsearch) incsearch#autocmd#auto_nohlsearch(0)
    1              0.000030 nnoremap <silent>       <Plug>(_incsearch-nohlsearch) :<C-u>nohlsearch<CR>
    1              0.000026 xnoremap <silent>       <Plug>(_incsearch-nohlsearch) :<C-u>nohlsearch<CR>gv
                            
                            " Make sure move cursor by search related action __after__ calling this
                            " function because the first move event just set nested autocmd which
                            " does :nohlsearch
                            " @expr
    1              0.000007 function! incsearch#autocmd#auto_nohlsearch(nest) abort
                              " NOTE: see this value inside this function in order to toggle auto
                              " :nohlsearch feature easily with g:incsearch#autocmd#auto_nohlsearch option
                              if !g:incsearch#auto_nohlsearch | return '' | endif
                              return s:auto_nohlsearch(a:nest)
                            endfunction
                            
    1              0.000003 function! incsearch#autocmd#is_set() abort
                              return exists('#incsearch-auto-nohlsearch#CursorMoved')
                            endfunction
                            
    1              0.000006 function! s:auto_nohlsearch(nest) abort
                              " NOTE: :h autocmd-searchpat
                              "   You cannot implement this feature without feedkeys() because of
                              "   :h autocmd-searchpat
                              augroup incsearch-auto-nohlsearch
                                autocmd!
                                autocmd InsertEnter * :call <SID>attach_on_insert_leave() | autocmd! incsearch-auto-nohlsearch
                                execute join([
                                \   'autocmd CursorMoved *'
                                \ , repeat('autocmd incsearch-auto-nohlsearch CursorMoved * ', a:nest)
                                \ , 'call feedkeys("\<Plug>(_incsearch-nohlsearch)", "m")'
                                \ , '| autocmd! incsearch-auto-nohlsearch'
                                \ ], ' ')
                              augroup END
                              return ''
                            endfunction
                            
    1              0.000003 function! s:attach_on_insert_leave() abort
                              augroup incsearch-auto-nohlsearch-on-insert-leave
                                autocmd!
                                autocmd InsertLeave * :call incsearch#autocmd#auto_nohlsearch(1)
                                \ | autocmd! incsearch-auto-nohlsearch-on-insert-leave
                              augroup END
                              return ''
                            endfunction
                            
    1   0.000026   0.000022 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " __END__
                            " vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker

SCRIPT  /home/kc/.vim/plugged/riv.vim/autoload/riv/list.vim
Sourced 1 time
Total time:   0.001081
 Self time:   0.001076

count  total (s)   self (s)
                            "=============================================
                            "    Name: list.vim
                            "    File: list.vim
                            " Summary: bullet list and enum list
                            "  Author: Rykka G.F
                            "  Update: 2012-07-07
                            "=============================================
    1              0.000016 let s:cpo_save = &cpo
    1   0.000026   0.000024 set cpo-=C
                            
    1              0.000004 let s:p = g:_riv_p
    1              0.000004 let s:e = g:_riv_e
                            " Search Relation: "{{{
                            " the searchpos and setpos version
                            " it's heavy though.
    1              0.000005 fun! s:get_all_list(row) "{{{
                                " return the current list's row number
                                " return 0 if not exists.
                                
                                let row = prevnonblank(a:row)
                            
                                let save_pos = getpos('.')
                                call cursor(row,1)
                            
                                while getline(row) !~ s:p.all_list && row != 0
                                    let idt = indent(row)
                                    if idt == 0 
                                        let row = 0
                                        break
                                    endif
                                    let idt_ptn = '^\s\{,'.(idt-1).'}\S'
                                    let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                endwhile
                                
                                call setpos('.',save_pos)
                            
                                return row
                            endfun "}}}
    1              0.000003 fun! s:get_list(row) "{{{
                                let row = prevnonblank(a:row)
                            
                                let save_pos = getpos('.')
                                call cursor(row,1)
                            
                                while getline(row) !~ s:p.b_e_list && row != 0
                                    let idt = indent(row)
                                    if idt == 0 
                                        let row = 0
                                        break
                                    endif
                                    let idt_ptn = '^\s\{,'.(idt-1).'}\S'
                                    let [row, col] = searchpos(idt_ptn, 'b',0,100)
                                endwhile
                                
                                call setpos('.',save_pos)
                            
                                return row
                            endfun "}}}
    1              0.000004 fun! s:get_older(row) "{{{
                                " check if a list item have an older item, 
                                " which have same indent with the list item ,
                                " and no between line's indent < them
                                let row = s:get_list(a:row)
                                if row == 0
                                    return 0
                                else
                            
                                    let save_pos = getpos('.')
                                    call cursor(row,1)
                            
                                    let c_idt = indent(row)
                            
                                    let idt_ptn = '^\s\{,'.c_idt.'}\S'
                                    let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                    let idt = indent(row)
                                    
                                    while getline(row) !~ s:p.b_e_list && row != 0
                                        if idt <= c_idt
                                            let row = 0
                                            break
                                        endif
                                        let idt_ptn = '^\s\{,'.idt.'}\S'
                                        let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                        let idt = indent(row)
                                    endwhile
                            
                            
                                    call setpos('.',save_pos)
                            
                                    return idt == c_idt ? row : 0
                                endif
                            endfun "}}}
    1              0.000003 fun! s:get_parent(row) "{{{
                               
                                let row = s:get_list(a:row)
                                if row == 0
                                    return 0
                                else
                            
                                    let save_pos = getpos('.')
                            
                                    let c_idt = indent(row)
                                    if c_idt == 0 
                                        return 0
                                    endif
                                    let idt_ptn = '^\s\{,'.(c_idt-1).'}\S'
                            
                                    call cursor(row,1)
                                    let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                    let idt = indent(row)
                                    
                                    while getline(row) !~ s:p.b_e_list && row != 0
                                        if idt == 0 
                                            let row = 0
                                            break
                                        endif
                                        let idt_ptn = '^\s\{,'.idt.'}\S'
                                        let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                        let idt = indent(row)
                                    endwhile
                            
                                    call setpos('.',save_pos)
                            
                                    return idt < c_idt ? row : 0
                                endif
                            endfun "}}}
                            
                            " the buf obj dict version.
                            " but should not rely on it.
                            " cause the buffer is always changing.
    1              0.000004 fun! s:buf_get_older(row) "{{{
                                let c_row = s:get_list(a:row)
                                if c_row == 0
                                    return 0
                                else
                                    if !exists("b:riv_obj[c_row]")
                                        return s:get_older(c_row)
                                    endif
                                    let obj = b:riv_obj[c_row]
                                    let older = riv#fold#get_prev_brother(obj)
                            
                                    if !empty(older) && nextnonblank(older.end+1) == obj.bgn
                                        return older.bgn
                                    endif
                                    return 0
                                endif
                            endfun "}}}
    1              0.000004 fun! s:buf_get_parent(row) "{{{
                                let c_row = s:get_list(a:row)
                                if c_row == 0
                                    return 0
                                else
                                    if !exists("b:riv_obj[c_row]")
                                        return s:get_parent(c_row)
                                    endif
                                    let parent = b:riv_obj[b:riv_obj[c_row].parent]
                                    if !empty(parent) && parent.bgn != 'list_root'
                                        return parent.bgn
                                    endif
                                    return 0
                                endif
                            endfun "}}}
    1              0.000004 fun! s:buf_get_child(row) "{{{
                                let c_row = s:get_list(a:row)
                                if c_row == 0
                                    return 0
                                else
                                    if !exists("b:riv_obj[c_row]")
                                        return s:get_child(c_row)
                                    endif
                                    return  b:riv_obj[c_row].child
                                endif
                                
                            endfun "}}}
                            
    1              0.000004 fun! riv#list#get_all_list(row) "{{{
                                return s:get_all_list(a:row)
                            endfun "}}}
    1              0.000003 fun! riv#list#get_list(row) "{{{
                                return s:get_list(a:row)
                            endfun "}}}
    1              0.000003 fun! riv#list#get_older(row) "{{{
                                return s:get_older(a:row)
                            endfun "}}}
    1              0.000003 fun! riv#list#get_parent(row) "{{{
                                return s:get_parent(a:row)
                            endfun "}}}
                            "}}}
                            
                            " List: "{{{
    1              0.000003 fun! s:new_list_item(act) "{{{
                                " create new list with act: 
                                " '1'  : child 
                                " '0'  : new
                                " '-1' : parent
                              
                                let row = line('.')
                                let cur_list = s:get_all_list(row)
                                if cur_list == 0
                                    let list_str = s:list_str(1 , '', '' , "*", " ") 
                                else
                                    let line = getline(cur_list)
                            
                                    " if it's field list , then just use it's indent.
                                    if line =~ s:p.field_list
                                        let idt = repeat(' ', indent(cur_list))
                                        let line = getline('.')
                                        let line = substitute(line, '^\s*', idt, '')
                                        call setline(row, line)
                                        return
                                    endif
                            
                                    let is_roman = s:is_roman(cur_list)
                                    let idt = ''
                            
                                    let [type , idt , num , attr, space] = 
                                                \ riv#list#stat(line, is_roman)
                                    if type == -1
                                        return s:list_str(1 , '', '' , "*", " ") 
                                    endif
                            
                                    if a:act == 1
                                        " calc the child idt
                                        let idt = idt . space . repeat(' ',len(num.attr))
                            
                                        let level = s:stat2level(type, num, attr) 
                                        let [type,num,attr] = s:level2stat(level+1)
                                    elseif a:act == -1
                                        let parent = s:get_parent(cur_list)
                                        if parent
                                            " use parent's attributes
                                            let is_roman = s:is_roman(parent)
                                            let [type , idt , num , attr, space] = 
                                                        \ riv#list#stat(getline(parent), is_roman)
                                            let num = s:next_list_num(num, is_roman)
                                        else
                                            let level = s:stat2level(type, num, attr) 
                                            let [type,num,attr] = s:level2stat(level-1)
                                            let idt = substitute(idt, repeat(' ',len(num.attr)+1),'','')
                                        endif
                                    else
                                        let num = s:next_list_num(num, is_roman)
                                    endif
                                    let list_str = s:list_str(type,idt,num,attr,space)
                                endif
                                let line = getline('.')
                                let line = substitute(line, '^\s*', list_str, '')
                                
                                call setline(row, line)
                            endfun "}}}
    1              0.000003 fun! riv#list#new(act) "{{{
                                " For Sub and Sup List, insert two line if it's not blank
                                " Else check the blank line before.
                                let row = line('.')
                                let line_c = getline(row)
                                let line_p = getline(row-1)
                                let cmd = ''
                                if a:act == 0
                                    if line_c =~ '\S'
                                        let cmd .= "\<CR>"
                                    endif
                                else
                                    if line_c =~ '\S'
                                        let cmd .= "\<CR>\<CR>"
                                    elseif line_p =~ '\S' && line_c !~ '\S'
                                        let cmd .= "\<CR>"
                                    endif
                                endif
                                
                                exe "norm! \<Esc>gi\<C-G>u".cmd
                            
                                call s:new_list_item(a:act)
                            
                                norm! $
                            
                            endfun "}}}
                            
    1              0.000004 fun! s:is_roman(row) "{{{
                                let line = getline(a:row)
                                if line =~ '^\c\s*(\=[imlcxvd][).]\s'
                                    let older = s:get_older(a:row)
                                    if older==0 
                                        " if no older , then 'i' is roman
                                        return line =~ '^\c\s*(\=i[).]\s'
                                    else
                                        " if has older , then when older is 'rr' is roman
                                        return getline(older) =~ '^\c\s*(\=[imlcxvd]\{2,}[).]\s'
                                    endif
                                else
                                    return line =~ '^\c\s*(\=[imlcxvd]\{2,}[).]\s'
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! riv#list#stat(line,...) "{{{
                                " return [type , idt , num , attr, space]
                                " [1,' ', 1, '*', ' ']
                                let is_roman = a:0 ? a:1 : 0
                                let ma = matchlist(a:line, s:p.list_checker)
                                let idt = matchstr(a:line,'^\s*')
                                if empty(ma)
                                    return [-1,idt,0,0,0]
                                endif
                                if !empty(ma[1])
                                    return [1, idt, '' , ma[1], ma[8]]
                                elseif !empty(ma[2])
                                    let len= len(ma[2])
                                    return [2,idt,ma[2][  : len-2], ma[2][len-1], ma[8]]
                                elseif !empty(ma[3]) 
                                    let len= len(ma[3])
                                    return [3,idt,ma[3][1 : len-2], "()", ma[8]]
                                elseif !empty(ma[4]) 
                                    " we should check if 'i. ... d.' is a roman numeral or alphabet
                                    if ( match(ma[4], '\c[imlcxvd]') == -1 || is_roman == 0)
                                        return [4,idt,ma[4][0], ma[4][1], ma[8]]
                                    else
                                        return [6,idt,ma[4][0], ma[4][1], ma[8]]
                                    endif
                                elseif !empty(ma[5]) 
                                    if ( match(ma[5], '\c[imlcxvd]') == -1 || is_roman == 0)
                                        return [5,idt,ma[5][1], "()", ma[8]]
                                    else
                                        return [7,idt,ma[5][1], "()", ma[8]]
                                    endif
                                elseif !empty(ma[6])
                                    let len= len(ma[6])
                                    return [6,idt,ma[6][  : len-2], ma[6][len-1], ma[8]]
                                elseif !empty(ma[7])
                                    let len= len(ma[7])
                                    return [7,idt,ma[7][1 : len-2], "()", ma[8]]
                                endif
                            endfun "}}}
    1              0.000005 fun! s:list_str(type,idt,num,attr, space) "{{{
                                if a:attr == "()"
                                    return a:idt ."(".a:num .")" . a:space
                                else
                                    return a:idt . a:num .  a:attr . a:space
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! s:num2nr(num,...) "{{{
                                let is_roman = a:0 ? a:1 : 0
                                if a:num == ''
                                    return 0
                                elseif a:num =~ '\d\+'
                                    return a:num
                                elseif a:num =~ '^[A-Za-z]$' &&
                                        \ ( match(a:num, '\c[imlcxvd]') == -1 || is_roman == 0)
                                    if a:num =~ '\u'
                                        return char2nr(a:num)-64
                                    else
                                        return char2nr(a:num)-96
                                    endif
                                elseif a:num =~ '\c[imlcxvd]\+'
                                    return riv#roman#to_nr(toupper(a:num))
                                endif
                            endfun "}}}
    1              0.000003 fun! s:nr2num(n,type) "{{{
                                " return alphabet are all '\u'
                                if a:type=='1'
                                    return ''
                                elseif a:type=='2' || a:type=='3'
                                    return a:n<=0 ? 1 : a:n
                                elseif a:type=='4' || a:type=='5'
                                    return a:n > 26 ? 'Z' : a:n <= 0 ? 'A' : nr2char(a:n+64)
                                elseif a:type=='6' || a:type=='7'
                                    return riv#roman#from_nr(a:n)
                                endif
                            endfun "}}}
    1              0.000026 fun! s:next_list_num(num,...) "{{{
                                let is_roman = a:0 ? a:1 : 0
                                if a:num == '' || a:num == '#'
                                    return a:num
                                elseif a:num =~ '\d\+'
                                    return a:num+1
                                elseif a:num =~ '^[A-Za-z]$' &&
                                        \ ( match(a:num, '\c[imlcxvd]') == -1 || is_roman == 0)
                                    if a:num=="z"
                                        return "z"
                                    elseif a:num=="Z"
                                        return "Z"
                                    else
                                        return nr2char(char2nr(a:num)+1)
                                    endif
                                elseif a:num =~ '\c[imlcxvd]\+'
                                    let nr =riv#roman#to_nr(toupper(a:num))
                                    if a:num =~ '\U'
                                        return tolower(riv#roman#from_nr(nr+1))
                                    else
                                        return riv#roman#from_nr(nr+1)
                                    endif
                                endif
                            endfun "}}}
                            
                            " Level and stats "{{{
                            "    *   +   -             =>
                            "    1.  A.  a.  I.  i.    =>
                            "    1)  A)  a)  I)  i)    =>
                            "   (1) (A) (a) (I) (i)
    1              0.000004 fun! riv#list#level(line,...) "{{{
                                let is_roman = a:0 ? a:1 : 0
                                let [type , idt , num , attr, space] = riv#list#stat(a:line,is_roman)
                                if type!=-1
                                    return s:stat2level(type,num,attr)
                                else
                                    return -1
                                endif
                            endfun "}}}
                            " type num attr
    1              0.000026 let s:list_stats= [
                            \ [1, '',  '*'],  [1, '',  '+'] , [1, '',   '-'],
                            \ [2, '1', '.'],  [4, 'A', '.'],  [4, 'a', '.'],  [6, 'I', '.'],  [6, 'i', '.'], 
                            \ [2, '1', ')'],  [4, 'A', ')'],  [4, 'a', ')'],  [6, 'I', ')'],  [6, 'i', ')'], 
                            \ [3, '1', '()'], [5, 'A', '()'], [5, 'a', '()'], [7, 'I', '()'], [7, 'i', '()'],
                            \]
    1              0.000005 fun! s:stat2level(type, num, attr) "{{{
                                " return level
                                if a:type == 1
                                    return stridx('*+-', a:attr)
                                elseif a:type == 2
                                    return stridx('.)', a:attr)*5  + 3
                                elseif a:type == 3
                                    return  13
                                else
                                    let is_lower = match(a:num,'\U')!=-1
                                    if a:type == 4
                                        return  4 + stridx('.)', a:attr)*5  +  is_lower
                                    elseif a:type == 5
                                        return  14 +  is_lower
                                    elseif a:type == 6
                                        return  6 + stridx('.)', a:attr)*5  +  is_lower
                                    elseif a:type == 7
                                        return  16 +  is_lower
                                    endif
                                endif
                                return 0
                            endfun "}}}
    1              0.000004 fun! s:level2stat(level) "{{{
                                " return type , num , attr
                                if a:level >= len(s:list_stats)
                                    return s:list_stats[-1]
                                elseif a:level < 0
                                    return s:list_stats[0]
                                endif
                                return s:list_stats[a:level]
                            endfun "}}}
                            "}}}
                            "}}}
                            
    1              0.000003 fun! s:list_object(line) "{{{
                                " groups: indent, attr , white
                                return riv#ptn#match_object(a:line,s:p.list_white)
                            endfun "}}}
    1              0.000004 fun! s:rmv_list(line) "{{{
                                return substitute(a:line,s:p.list_white, '\1','')
                            endfun "}}}
                            
    1              0.000004 fun! riv#list#fix_col(col,item_end,sft) "{{{
                                " fix col pos base on item_end and shift length.
                                if a:col > a:item_end
                                    return a:col + a:sft
                                elseif ( a:item_end + a:sft <= a:col && a:item_end >= a:col )
                                    return a:item_end + a:sft 
                                else
                                    return a:col
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! riv#list#delete() "{{{
                                let [row, col] = [line('.'), col('.')]
                                let line = getline(row)
                                let prv_len = strwidth(line)
                                let end = matchend(line, s:p.b_e_list)
                                if end!= -1
                                    let line = s:rmv_list(line)
                                    call setline(row,line)
                                    call cursor(row, riv#list#fix_col(col, end, (strwidth(line) - prv_len)))
                                else
                                    call riv#warning(s:e.NOT_LIST_ITEM)
                                endif
                            endfun "}}}
                            " the type are '*' , '1.' , 'a.' , 'A)' ,'i)'
    1              0.000005 let s:change_levels = [0,3,5,9,12]
    1              0.000003 fun! riv#list#change(id) "{{{
                                let [row, col] = [line('.'), col('.')]
                                let line = getline(row)
                                
                                let prv_len = strwidth(line)
                                let end = matchend(line, g:_riv_p.b_e_list)
                                
                                let id = a:id>=len(s:change_levels) ? len(s:change_levels)-1 : a:id
                                let [type,num,attr] = s:level2stat(s:change_levels[id])
                                let list_str = s:list_str(type,'',num,attr,'')
                                if end == -1
                                    let line = substitute(line, '^\s*', '\0'.list_str.' ', '')
                                else
                                    let line = substitute(line, s:p.list_white , '\1'.list_str.'\3', '')
                                endif
                                call setline(row, line)
                                call cursor(row, riv#list#fix_col(col, end, (strwidth(line) - prv_len)))
                            endfun "}}}
                            
    1              0.000004 fun! riv#list#toggle_type(i) "{{{
                                " Change current list type with different level type
                                let [row, col]= [line('.'), col('.')]
                                let line = getline('.')
                                if line =~ '^\c\s*(\=[imlcxvd][).]'
                                    let is_roman = s:is_roman(row)
                                else
                                    let is_roman = 0
                                endif
                                let idt = matchstr(line, '^\s*')
                                let [type , idt , num , attr, space] = riv#list#stat(line, is_roman)
                                let prv_len = strwidth(line)
                                if type==-1
                                    let prv_ls_end = matchend(line, '^\s*')
                                    let list_str = s:list_str(1 , '', '' , "*", " ") 
                                    let line = substitute(line, '^\s*', list_str, '')
                                else
                                    let prv_ls_end = matchend(line, s:p.b_e_list)
                                    let level = s:stat2level(type, num, attr) 
                                    if a:i == 0
                                        let list_str = idt
                                    else
                                        let [type,num,attr] = s:level2stat(level+a:i)
                                        let list_str = s:list_str(type,idt,num,attr,space)
                                    endif
                                    let line = substitute(line, s:p.b_e_list , list_str, '')
                                endif
                                call setline(row, line)
                                let mod_len = strwidth(line)
                                let mod_ls_end = prv_ls_end + mod_len - prv_len
                                if col >= prv_ls_end
                                    let sft = mod_ls_end - prv_ls_end
                                    call cursor(row, col + sft )
                                elseif col <= prv_ls_end && col >= mod_ls_end
                                    call cursor(row, mod_ls_end )
                                endif
                            endfun "}}}
                            
    1              0.000003 fun! riv#list#toggle() "{{{
                                " toggle current list item
                                let end = matchend(getline('.'), s:p.b_e_list)
                                if end!= -1
                                    call riv#list#delete()
                                else
                                    call riv#list#change(0)
                                endif
                            endfun "}}}
                            
    1              0.000004 fun! riv#list#fixed_col(row,col,sft) "{{{
                                " add prev line idt
                                " check block indent
                                " if it's in list context
                                "   if row is not list, use it's indent
                                "   if row is list , use parent indent when "-" 
                                "                    use older indent when "+"
                                " else check exp mark
                                let pnb_row = prevnonblank(a:row - 1)
                                if pnb_row == 0
                                    return a:col + a:sft
                                endif
                                let f_idts = [indent(pnb_row)+1]
                                
                                let blk_row = riv#ptn#get(g:_riv_p.literal_block, a:row)
                                if blk_row
                                    let f_idts += [indent(blk_row)+1+&sw]
                                endif
                            
                                let lst_row = riv#list#get_all_list(a:row)
                                if lst_row 
                                    if a:row != lst_row
                                        let lst_idt = indent(lst_row)+1
                                        let lst_cdt  =riv#list#get_con_idt(getline(lst_row))
                                        let f_idts += [lst_idt,lst_cdt]
                                    else
                                        if a:sft > 0 
                                            let old_row = riv#list#get_older(lst_row)
                                        elseif a:sft < 0
                                            let old_row = riv#list#get_parent(lst_row)
                                        endif
                                        if exists("old_row") && old_row
                                            let old_idt = indent(old_row)+1
                                            let old_cdt  =riv#list#get_con_idt(getline(old_row))
                                            let f_idts += [old_idt, old_cdt]
                                        endif
                                    endif
                                else
                                    let exp_row = riv#ptn#get(g:_riv_p.exp_mark, a:row)
                                    if exp_row
                                        let exp_cdt = riv#ptn#exp_con_idt(getline(exp_row))
                                        let f_idts += [exp_cdt]
                                    endif
                                endif
                            
                                return riv#ptn#fix_sfts(a:col,f_idts,a:sft)
                            endfun "}}}
    1              0.000004 fun! riv#list#fixed_sft(row,col,sft) "{{{
                                return riv#list#fixed_col(a:row,a:col,a:sft) - a:col
                            endfun "}}}
                            
    1              0.000004 fun! riv#list#shift(direction) range "{{{
                                " direction "+" or "-" or "="
                                let line = getline(a:firstline) 
                                let [row,col]  = [a:firstline, indent(a:firstline)+1]
                            
                                " calculate shifting with a:firstline
                                if a:direction == '+'
                                    let vec = riv#list#fixed_sft(row,col,&sw)
                                elseif a:direction == "-"
                                    let vec = riv#list#fixed_sft(row,col,-&sw)
                                else
                                    let vec = 0
                                endif
                            
                                " A fix shift idt list
                                " [0,fix1,fix2,....] 
                                " each item's index is one indent level,
                                " the value is for the line which > the indent.
                                " so a line's fix is sft_fix[line-1]
                                "
                                " let c_idt = indent(line)
                                " if c_idt > len
                                "   add item to fill to sft_idt[c_idt]
                                " if c_idt < len
                                "   trunc sft_idt to sft_idt[c_idt]
                                "   
                                " apply sft_fix[c_idt-1] 
                                " if it's a list , calc the new idt (sft_fix[c_idt-1] + n_item_len-p_item_len ) 
                                
                                let s:sft_fix = [0]
                                if a:firstline == a:lastline
                                    call s:shift_vec(a:firstline, vec,0)
                                    call cursor(line('.'), col('.')+vec)
                                else
                                    for line in range(a:firstline,a:lastline)
                                        call s:shift_vec(line, vec,1)
                                    endfor
                                    normal! gv
                                endif
                            endfun "}}}
    1              0.000004 fun! s:shift_vec(row,vec,...) "{{{
                                let line = getline(a:row)
                                if line =~ '^\s*$' | return | endif
                            
                                let indent = indent(a:row)
                                
                                " change the sft_fix list length to current indent + 2
                                " s:sft_fix[indent] is the fix indent for same indent with current row
                                " s:sft_fix[indent+1] for indent > current row
                                let len = len(s:sft_fix)
                                if indent > len - 2 
                                    let l = map(range(indent-len+2), 's:sft_fix[-1]')
                                    call extend(s:sft_fix, l )
                                elseif indent < len - 2 
                                    call remove(s:sft_fix, (indent+2), -1)
                                endif
                                " apply the indent fix
                                let cur_indent = indent + a:vec + s:sft_fix[indent]
                                let line = s:set_idt(line, cur_indent)
                            
                                let is_roman = s:is_roman(a:row)
                                let [type , idt , num , attr, space] =  riv#list#stat(line, is_roman)
                                let nr = s:num2nr(num, is_roman)
                            
                                if type != -1 && a:vec != 0
                                    if a:vec > 0
                                        let level = s:stat2level(type, num, attr) 
                                        let [type,num,attr] = s:level2stat(level+1)
                                    elseif a:vec < 0
                                        let level = s:stat2level(type, num, attr) 
                                        let [type,num,attr] = s:level2stat(level-1)
                                    endif
                                
                                    let num = num=~'\U' ? tolower(s:nr2num(nr,type)) : s:nr2num(nr,type)
                            
                                    let p_len = len(line)
                                    let line = substitute(line, s:p.b_e_list,
                                                \ s:list_str(type,idt,num,attr,space), '')
                                    let s:sft_fix[indent+1] = s:sft_fix[indent] +  len(line) - p_len
                                endif
                            
                                call setline(a:row,line)
                            
                                if type != -1
                                    call s:fix_nr(a:row,indent)
                                endif
                            endfun "}}}
    1              0.000004 fun! s:fix_nr(row, indent) "{{{
                                " fix list nr , based on previous list item if exists, else use 1
                                let line = getline(a:row)
                                let older = s:get_older(a:row)
                                if older 
                                    let is_roman = s:is_roman(older)
                                    let [type , idt , num , attr, space] = riv#list#stat(getline(older),
                                                                            \is_roman)
                                    let nr = s:num2nr(num, is_roman) + 1
                                else
                                    let [type , idt , num , attr, space] = riv#list#stat(line, s:is_roman(a:row))
                                    let nr = 1
                                endif
                                let num = num=~'\U' ? tolower(s:nr2num(nr,type)) : s:nr2num(nr,type)
                                let p_len = len(line)
                                let line = substitute(line, s:p.b_e_list,
                                            \ s:list_str(type,idt,num,attr,space), '')
                                let s:sft_fix[a:indent+1] += len(line) - p_len
                                call setline(a:row,line)
                            endfun "}}}
    1              0.000004 fun! s:set_idt(line, indent) "{{{
                                if a:indent > 0
                                    return substitute(a:line, '^\s*', repeat(' ', a:indent), '')
                                else
                                    return substitute(a:line, '^\s*', '', '')
                                endif
                            endfun "}}}
                            
    1              0.000004 fun! riv#list#get_con_idt(line) "{{{
                                return matchend(a:line, s:p.all_list)+1  
                            endfun "}}}
                            
    1              0.000003 fun! s:SID() "{{{
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
                            endfun "}}}
    1              0.000002 fun! riv#list#SID() "{{{
                                return '<SNR>'.s:SID().'_'
                            endfun "}}}
    1   0.000022   0.000019 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:180
Called 2 times
Total time:   0.001741
 Self time:   0.000641

count  total (s)   self (s)
    2   0.000052   0.000024   let path = s:Slash(a:path)
    2              0.000016   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    2              0.000007   elseif empty(path)
                                return ''
    2              0.000013   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    2              0.000003   else
    2              0.000029     let path = fnamemodify(path, ':p:h:s?/$??')
    2              0.000002   endif
    2              0.000027   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    2              0.000008   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    2              0.000003   endif
    2              0.000027   let root = resolve(path)
    2              0.000006   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    2              0.000002   endif
    2              0.000005   let previous = ""
    2              0.000018   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    2   0.000053   0.000021   call s:Tree(env_git_dir)
    3              0.000046   while root !=# previous
    3              0.000043     if root =~# '\v^//%([^/]+/?)?$'
                                  break
    3              0.000003     endif
    3              0.000024     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
    3              0.000003     endif
    3              0.000012     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
    3              0.000013     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
    3              0.000004     endif
    3              0.000048     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    3              0.000038     let type = getftype(dir)
    3   0.001053   0.000042     if type ==# 'dir' && FugitiveIsGitDir(dir)
    2              0.000008       return dir
    1              0.000003     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
    1              0.000003     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
    1   0.000040   0.000011     elseif FugitiveIsGitDir(root)
                                  return root
    1              0.000001     endif
    1              0.000003     let previous = root
    1              0.000005     let root = fnamemodify(root, ':h')
    1              0.000002   endwhile
                              return ''

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 7 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    7              0.000129   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    7              0.000012   endif

FUNCTION  <SNR>218__reset()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:34
Called 10 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
   10              0.000038 	let s:cmdhist = []
   10              0.000025 	let s:count = 0
   10              0.000047 	let s:is_match_mode = 0 " <Up>/<Down>: true, <C-n>/<C-p>: false

FUNCTION  <SNR>147_UpdateCacheIfNecessary()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:78
Called 33860 times
Total time:   0.559590
 Self time:   0.559447

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
33860              0.249545     if !has_key(g:ale_buffer_info[a:buffer], 'count')
    1   0.000159   0.000016         call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
33860              0.053129     endif

FUNCTION  7()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 122 times
Total time:   0.000967
 Self time:   0.000967

count  total (s)   self (s)
  122              0.000897   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  8()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:12
Called 106 times
Total time:   0.002935
 Self time:   0.002085

count  total (s)   self (s)
  106              0.000890   let spc = empty(a:contents) ? '' : g:airline_symbols.space
  106   0.001939   0.001089   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  9()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 412 times
Total time:   0.003793
 Self time:   0.003793

count  total (s)   self (s)
  412              0.003532   call add(self._sections, [a:group, a:contents])

FUNCTION  signature#utils#IsValidMarker()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/utils.vim:183
Called 780 times
Total time:   0.009029
 Self time:   0.009029

count  total (s)   self (s)
  780              0.008389   return (  (b:SignatureIncludeMarkers =~# a:marker) && (a:marker != ' ') )

FUNCTION  <SNR>278__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Guard.vim:19
Called 1 time
Total time:   0.005332
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000020   let s:V = a:V
    1   0.002144   0.000012   let s:Prelude = s:V.import('Prelude')
    1   0.000123   0.000017   let s:List = s:V.import('Data.List')
    1   0.003044   0.000012   let s:Dict = s:V.import('Data.Dict')

FUNCTION  vital#_easymotion#Over#Exception#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Exception.vim:5
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000027     return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>197__exists_autoload_func_with_source()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:240
Called 31 times
Total time:   0.024007
 Self time:   0.002277

count  total (s)   self (s)
   31              0.000387   if exists('*' . a:funcname)
                                " Return true if a given func is already defined
                                return 1
   31              0.000040   endif
                              " source a file which may include a given func definition and try again.
   31              0.000974   let path = 'autoload/' . substitute(substitute(a:funcname, '#[^#]*$', '.vim', ''), '#', '/', 'g')
   31   0.022129   0.000399   call s:_runtime(path)
   31              0.000247   return exists('*' . a:funcname)

FUNCTION  incsearch#over#modules#insert_register#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/insert_register.vim:34
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return deepcopy(s:InsertRegister)

FUNCTION  incsearch#over#modules#pattern_saver#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/pattern_saver.vim:41
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return deepcopy(s:pattern_saver)

FUNCTION  AutoPairsSpace()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:423
Called 1086 times
Total time:   0.558827
 Self time:   0.462223

count  total (s)   self (s)
 1086              0.006351   if !b:autopairs_enabled
                                return "\<SPACE>"
 1086              0.002786   end
                            
 1086   0.119474   0.022870   let [before, after, ig] = s:getline()
                            
10860              0.043315   for [open, close, opt] in b:AutoPairsList
 9774              0.027157     if close == ''
                                  continue
 9774              0.014112     end
 9774              0.146217     if before =~ '\V'.open.'\v$' && after =~ '^\V'.close
                                  if close =~ '\v^[''"`]$'
                                    return "\<SPACE>"
                                  else
                                    return "\<SPACE>\<SPACE>".s:Left
                                  end
 9774              0.016029     end
10860              0.020114   endfor
 1086              0.006157   return "\<SPACE>"

FUNCTION  <SNR>194_SetLines()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:496
Called 2 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    6              0.000024     for [line_num, line] in a:lines
    4              0.000099         keepjumps call setline(line_num, line[a:key])
    6              0.000011     endfor

FUNCTION  <SNR>263__reset()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/History.vim:28
Called 18 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
   18              0.000064 	let s:cmdhist = []
   18              0.000055 	let s:count = 0
   18              0.000082 	let s:is_match_mode = 0 " <Up>/<Down>: true, <C-n>/<C-p>: false

FUNCTION  <SNR>213_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim:34
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	return deepcopy(s:module)

FUNCTION  <SNR>190_GroupCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:161
Called 50 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
   50              0.000176     if s:supports_sign_groups
   50              0.000115         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:112
Called 17276 times
Total time:   6.063994
 Self time:   0.327783

count  total (s)   self (s)
17276   6.052888   0.316677   return airline#extensions#ale#get('error')

FUNCTION  incsearch#with_ignore_foldopen()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:441
Called 15 times
Total time:   0.002304
 Self time:   0.000648

count  total (s)   self (s)
   15              0.000066   let foldopen_save = &foldopen
   15   0.000139   0.000117   let &foldopen=''
   15              0.000048   try
   15   0.001819   0.000201     return call(a:F, a:000)
   15              0.000030   finally
   15   0.000150   0.000134     let &foldopen = foldopen_save
   15              0.000027   endtry

FUNCTION  <SNR>194_findMotion()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:527
Called 2 times
Total time:   1.073014
 Self time:   0.000624

count  total (s)   self (s)
                                " Find Motion: S,F,T
    2              0.000012     let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " store cursor pos because 'n' key find motion could be jump to offscreen
    2              0.000015     let s:current.original_position = [line('.'), col('.')]
    2              0.000027     let s:current.is_search = a:num_strokes == -1 ? 1: 0
    2              0.000009     let s:flag.regexp = a:num_strokes == -1 ? 1 : 0 " TODO: remove?
                            
    2              0.000011     if g:EasyMotion_add_search_history && a:num_strokes == -1
    2              0.000013         let s:previous['input'] = @/
                                else
                                    let s:previous['input'] = get(s:previous, 'input', '')
    2              0.000004     endif
    2   1.072282   0.000305     let input = EasyMotion#command_line#GetInput( a:num_strokes, s:previous.input, a:direction)
    2              0.000014     let s:previous['input'] = input
                            
                                " Check that we have an input char
    2              0.000010     if empty(input)
                                    return ''
    2              0.000003     endif
                            
    2   0.000473   0.000060     let re = s:convertRegep(input)
                            
    2              0.000008     if g:EasyMotion_add_search_history && a:num_strokes == -1
    2              0.000024         let history_re = substitute(re, '\\c\|\\C', '', '')
    2              0.000006         let @/ = history_re "For textobject: 'gn'
    2              0.000025         call histadd('search', history_re)
    2              0.000004     endif
                            
    2              0.000004     return re

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:476
Called 476 times
Total time:   0.404384
 Self time:   0.205466

count  total (s)   self (s)
  476              0.002808     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
  952              0.010842     for l:original_filetype in split(a:original_filetypes, '\.')
  476   0.083607   0.011962         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
  476   0.047690   0.010063         let l:linter_names = s:GetLinterNames(l:original_filetype)
  476   0.097715   0.008069         let l:all_linters = ale#linter#GetAll(l:filetype)
  476              0.002073         let l:filetype_linters = []
                            
  476              0.004582         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
  475              0.002364             let l:filetype_linters = l:all_linters
    1              0.000005         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
    4              0.000012             for l:linter in l:all_linters
    3              0.000020                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
    7              0.000019                 for l:name in l:name_list
    4              0.000040                     if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
    4              0.000007                     endif
    7              0.000009                 endfor
    4              0.000005             endfor
  476              0.001317         endif
                            
  476              0.004900         call extend(l:possibly_duplicated_linters, l:filetype_linters)
  952              0.002115     endfor
                            
  476              0.002084     let l:name_list = []
  476              0.001988     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
 3794              0.011324     for l:linter in reverse(l:possibly_duplicated_linters)
 3318              0.020373         if index(l:name_list, l:linter.name) < 0
 3318              0.018697             call add(l:name_list, l:linter.name)
 3318              0.018910             call add(l:combined_linters, l:linter)
 3318              0.004983         endif
 3794              0.005647     endfor
                            
  476              0.002516     return reverse(l:combined_linters)

FUNCTION  <SNR>201_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:112
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000015 	let result = deepcopy(s:base)
    1              0.000003 	return result

FUNCTION  <SNR>196_adjust_screen()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:252
Called 8 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
    8              0.000028     if s:save_direction != 'b'
                                    " Forward
    8              0.000064         keepjumps call setpos('.', s:orig_line_start)
    8              0.000246         normal! zt
                                else
                                    " Backward
                                    keepjumps call setpos('.', s:orig_line_end)
                                    normal! zb
    8              0.000010     endif

FUNCTION  <SNR>105_reset_untracked_cache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:304
Called 51 times
Total time:   0.010484
 Self time:   0.008576

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
   51              0.000312   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
   51              0.000110   endif
                            
   51              0.000969   let file = expand("%:p")
  153              0.001046   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
  102   0.005140   0.003232     call airline#extensions#branch#update_untracked_config(file, vcs)
  102              0.000810     let s:vcs_config[vcs].untracked = {}
  153              0.000426   endfor

FUNCTION  <SNR>209_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:66
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return deepcopy(s:module)

FUNCTION  <SNR>139_GenericStopTimer()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:21
Called 2079 times
Total time:   0.058029
 Self time:   0.058029

count  total (s)   self (s)
 2079              0.056165   execute 'if '.a:timer.' != -1 |'. '  call timer_stop('.a:timer.') |'. '  let 'a:timer.' = -1 |'. 'endif'

FUNCTION  <SNR>217_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:57
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000006 	let result = deepcopy(s:module)
    1              0.000008 	let result.prefix = get(a:, 1, "vital-over(".s:vname.") Exception")
    1              0.000005 	let result.command = get(a:, 2, "echom")
    1              0.000002 	return result

FUNCTION  <SNR>191_FixList()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:54
Called 50 times
Total time:   0.003808
 Self time:   0.002652

count  total (s)   self (s)
   50   0.001869   0.000713     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
   50              0.000149     let l:new_list = []
                            
   50              0.000140     for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
   50              0.000094     endfor
                            
   50              0.000138     return l:new_list

FUNCTION  riv#action#ins_enter()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/action.vim:86
Called 152 times
Total time:   0.011847
 Self time:   0.011847

count  total (s)   self (s)
  152              0.008033     if getline('.') =~ s:p.table
                                    call riv#table#newline('cont')
  152              0.000357     else
                                    " exe "norm! \<Esc>gi\<CR>\<Right>"
                                    " exe "norm! \<Esc>a\<C-G>u\<C-M>"
  152              0.001797         call feedkeys("\<Esc>gi\<C-G>u\<C-M>",'n')
                                    " norm! o
  152              0.000247     endif

FUNCTION  vital#_incsearch#Data#List#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/List.vim:7
Called 1 time
Total time:   0.000925
 Self time:   0.000627

count  total (s)   self (s)
    1   0.000924   0.000626 return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'shift': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'drop_while': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'map_accum': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''}, "vital#_incsearch#function('<SNR>241_' . v:key)")

FUNCTION  <SNR>156_NewWindow()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:17
Called 1 time
Total time:   0.146351
 Self time:   0.001647

count  total (s)   self (s)
    1              0.000007   let position = get(g:, 'vista_sidebar_position', 'vertical botright')
    1              0.000005   let width = get(g:, 'vista_sidebar_width', 30)
    1              0.000005   let open = position.' '.width.'new'
    1   0.085565   0.001297   silent execute open '__vista__'
                            
    1   0.060702   0.000266   execute 'setlocal filetype='.vista#sidebar#WhichFileType()
                            
                              " FIXME when to delete?
    1              0.000009   if has_key(t:vista.source, 'fpath')
    1              0.000051     let w:vista_first_line_hi_id = matchaddpos('MoreMsg', [1])
    1              0.000002   endif

FUNCTION  <SNR>260_doautocmd_user()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:29
Called 70 times
Total time:   0.008764
 Self time:   0.005755

count  total (s)   self (s)
   70              0.000473 	let group =  a:prefix . "-vital-over-commandline-doautocmd-dummy"
   70              0.000388 	if !has_key(s:cache_command, a:prefix)
    1              0.000005 		let s:cache_command[a:prefix] = {}
   70              0.000105 	endif
                            
   70              0.000515 	if !has_key(s:cache_command[a:prefix], a:command)
    8              0.000328 		execute "autocmd " . group			. " User " . a:command." silent! execute ''"
                            
    8              0.000051 		if v:version > 703 || v:version == 703 && has("patch438")
    8              0.000080 			let s:cache_command[a:prefix][a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:prefix][a:command] = "doautocmd User " . a:command
    8              0.000012 		endif
   70              0.000089 	endif
                            
   70   0.004986   0.001977 	execute s:cache_command[a:prefix][a:command]

FUNCTION  <SNR>244_as_key_config()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim:29
Called 6 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    6              0.000032 	let base = {		"noremap" : 0,		"lock"    : 0,		"expr"    : 0,	}
    6              0.000088 	return type(a:config) == type({}) ? extend(base, a:config)		 : extend(base, {		 	"key" : a:config,		 })

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:199
Called 17283 times
Total time:  37.485985
 Self time:   4.156444

count  total (s)   self (s)
17283              0.122318   if !has_key(s:contexts, a:winnr)
                                return ''
17283              0.043628   endif
17283              0.124007   let context = s:contexts[a:winnr]
                            
17283              0.115319   if get(w:, 'airline_active', 1)
17280              0.095963     let l:m = mode(1)
17280              0.056378     if l:m ==# "i"
 8796              0.047702       let l:mode = ['insert']
 8484              0.038916     elseif l:m[0] ==# "i"
 4760              0.022579       let l:mode = ['insert']
 3724              0.010383     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
 3724              0.012994     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
 3724              0.061393     elseif l:m[0] =~# '\v(v|V||s|S|)'
   62              0.000302       let l:mode = ['visual']
 3662              0.010080     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
 3662              0.013348     elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
 3662              0.010544     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
 3662              0.017208     elseif l:m[0:1] ==# 'ni'
  177              0.000870       let l:mode = ['normal']
  177              0.000428       let l:m = 'ni'
 3485              0.005499     else
 3485              0.019929       let l:mode = ['normal']
17280              0.026428     endif
17280              0.137003     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
17280              0.025517     endif
17280              0.172395     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
12343              0.059945       let l:m = l:m[0]
17280              0.026749     endif
17280              0.162171     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    3              0.000004   else
    3              0.000013     let l:mode = ['inactive']
    3              0.000026     let w:airline_current_mode = get(g:airline_mode_map, '__')
17283              0.026517   endif
                            
17283              0.105467   if g:airline_detect_modified && &modified
16115              0.107863     call add(l:mode, 'modified')
17283              0.027286   endif
                            
17283              0.066037   if g:airline_detect_paste && &paste
   11              0.000042     call add(l:mode, 'paste')
17283              0.026365   endif
                            
17283              0.132694   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
17283              0.026844   endif
                            
17283              0.072531   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
17283              0.025059   endif
                            
17283              0.061052   if &readonly || ! &modifiable
  229              0.001707     call add(l:mode, 'readonly')
17283              0.023757   endif
                            
17283              0.119841   let mode_string = join(l:mode)
17283              0.128016   if get(w:, 'airline_lastmode', '') != mode_string
  541   0.418385   0.014644     call airline#highlighter#highlight_modified_inactive(context.bufnr)
  541  32.873020   0.019564     call airline#highlighter#highlight(l:mode, context.bufnr)
  541   0.088357   0.016013     call airline#util#doautocmd('AirlineModeChanged')
  541              0.003075     let w:airline_lastmode = mode_string
17283              0.026147   endif
                            
17283              0.037624   return ''

FUNCTION  vital#_incsearch#Gift#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift.vim:7
Called 1 time
Total time:   0.000394
 Self time:   0.000273

count  total (s)   self (s)
    1   0.000393   0.000272 return map({'flatten': '', 'uniq_tabpagenr': '', 'tabpagewinnr_list': '', 'execute': '', 'getwinvar': '', 'winnr': '', 'jump_window': '', '_vital_depends': '', 'uniq_winnr': '', 'setwinvar': '', 'find': '', 'openable_bufnr_list': '', 'to_fullpath': '', 'bufnr': '', 'set_current_window': '', 'tabpagewinnr': '', 'close_window': '', 'close_window_by': '', 'uniq_winnr_list': '', '_vital_loaded': '', 'find_by': ''}, "vital#_incsearch#function('<SNR>282_' . v:key)")

FUNCTION  <SNR>281__vital_created()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Type.vim:38
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000006   let a:module.types = s:types
    1              0.000005   let a:module.type_names = s:type_names

FUNCTION  vista#renderer#default#Render()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:302
Called 1 time
Total time:   0.001687
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000010   if empty(t:vista.raw)
                                return []
    1              0.000002   endif
                            
    1   0.001671   0.000015   return s:Render()

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:168
Called 17067 times
Total time:   0.494895
 Self time:   0.494895

count  total (s)   self (s)
17067              0.130862   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
   51              0.000095     return
17016              0.158596   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
17016              0.025486   endif

FUNCTION  <SNR>245_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules.vim:29
Called 9 times
Total time:   0.009121
 Self time:   0.000460

count  total (s)   self (s)
    9   0.008746   0.000151 	let module = s:get(a:name)
    9   0.000371   0.000305 	return call(module.make, a:000, module)

FUNCTION  vista#fold#Expr()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/fold.vim:10
Called 4 times
Total time:   0.000284
 Self time:   0.000235

count  total (s)   self (s)
    4              0.000027   if getline(v:lnum) =~# '^$'
    1              0.000003     return 0
    3              0.000004   endif
                            
    3   0.000087   0.000061   let cur_indent = s:HeadingWhitespaces(getline(v:lnum))
    3   0.000077   0.000054   let next_indent = s:HeadingWhitespaces(getline(v:lnum+1))
                            
    3              0.000007   if cur_indent < next_indent
    1              0.000003     return '>'.next_indent
    2              0.000003   else
    2              0.000004     return cur_indent
                              endif

FUNCTION  <SNR>239_is_input_waiting()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:491
Called 14 times
Total time:   0.000972
 Self time:   0.000972

count  total (s)   self (s)
   14              0.000874 	let num = len(filter(copy(a:keymapping), 'stridx(v:key, a:input) == 0'))
   14              0.000083 	return num > 1 || (num == 1 && !has_key(a:keymapping, a:input))

FUNCTION  <SNR>132_close_cb()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:110
Called 1 time
Total time:   0.194624
 Self time:   0.000413

count  total (s)   self (s)
    1   0.000096   0.000035   call s:PrepareContainer()
                            
   12              0.000102   while ch_status(a:channel, {'part': 'out'}) ==# 'buffered'
   11              0.000047     let line = ch_read(a:channel)
   11   0.002273   0.000184     call s:TagParser(line, s:data)
   12              0.000018   endwhile
                            
    1   0.192074   0.000013   call s:ApplyExtracted()

FUNCTION  530()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:72
Called 33 times
Total time:   0.005097
 Self time:   0.001530

count  total (s)   self (s)
   33              0.000155   if v:version == 704 && !has('patch421')
                                " Ignore \ze* which clash vim 7.4 without 421 patch
                                " Assume `\m`
                                let [p, o] = incsearch#parse_pattern(self.getline(), self._base_key)
                                let p = (p =~# s:non_escaped_backslash . 'z[se]\%(\*\|\\+\)' ? '' : p)
                                return [p, o]
   33              0.000051   else
   33   0.004350   0.000783     return incsearch#parse_pattern(self.getline(), self._base_key)
                              endif

FUNCTION  <SNR>253_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:143
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  <SNR>132_GetLanguageSpecificOptition()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:53
Called 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000002   let opt = ''
                            
    1              0.000001   try
    1              0.000014     let types = g:vista#types#uctags#{a:filetype}#
                                let lang = types.lang
                                let kinds = join(keys(types.kinds), '')
                                let opt = printf('--language-force=%s --%s-kinds=%s', lang, lang, kinds)
                              " Ignore Vim(let):E121: Undefined variable
    1              0.000020   catch /^Vim\%((\a\+)\)\=:E121/
    1              0.000002   endtry
                            
    1              0.000002   return opt

FUNCTION  <SNR>197_new()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:37
Called 14 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
   14              0.000148   let base = deepcopy(s:Vital)
   14              0.000061   let base._plugin_name = a:plugin_name
   14              0.000031   return base

FUNCTION  <SNR>136_Pyeval()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:79
Called 50592046 times
Total time: 3898.286359
 Self time: 3898.286359

count  total (s)   self (s)
50592046            155.812601   if s:using_python3
50592046            3696.773382     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  531()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:84
Called 21 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   21              0.000171   return empty(a:offset) ? a:pattern : a:pattern . self._base_key . a:offset

FUNCTION  <SNR>120_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:166
Called 838 times
Total time:   0.068359
 Self time:   0.068359

count  total (s)   self (s)
  838              0.003033   if a:self._context.active
                                " active window
  810              0.002455     let contents = []
  810              0.010892     let content_parts = split(a:contents, '__accent')
 1209              0.003879     for cpart in content_parts
  399              0.006216       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  399              0.002326       call add(contents, cpart)
 1209              0.002432     endfor
  810              0.004972     let line = join(contents, a:group)
  810              0.009830     let line = substitute(line, '__restore__', a:group, 'g')
   28              0.000052   else
                                " inactive window
   28              0.000677     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   28              0.000453     let line = substitute(line, '%#__restore__#', '', 'g')
  838              0.001271   endif
  838              0.002064   return line

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:228
Called 50 times
Total time:   0.015188
 Self time:   0.001804

count  total (s)   self (s)
   50   0.005227   0.000852     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
   50   0.009822   0.000813     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>36_matchend()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:162
Called 257 times
Total time:   0.007262
 Self time:   0.007262

count  total (s)   self (s)
  257              0.004110     let m = matchstr(a:text, '\V'.a:open.'\v$')
  257              0.001816     if m == ""
  237              0.000598       return []
   20              0.000030     end
   20              0.000254     return [a:text, strpart(a:text, 0, len(a:text)-len(m)), m]

FUNCTION  riv#ptn#get_phase_idx()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:78
Called 2077 times
Total time:   0.057217
 Self time:   0.057217

count  total (s)   self (s)
                                " if cursor is in a phase ,return it's idx , else return -1
 2077              0.023263     let ptn = printf('`[^`]*\%%%dc[^`]*`__\?\|\%%%dc`[^`]*`__\?', a:col, a:col)
 2077              0.030365     return match(a:line, ptn)

FUNCTION  <SNR>132_GetCustomCmd()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:22
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000014   if exists('g:vista_ctags_cmd') && has_key(g:vista_ctags_cmd, a:ft)
                                return g:vista_ctags_cmd[a:ft]
    2              0.000003   endif
    2              0.000005   return v:null

FUNCTION  156()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:73
Called 44 times
Total time:   0.981914
 Self time:   0.001102

count  total (s)   self (s)
   44   0.981889   0.001077 	return call("s:call", [self.slots(), a:func] + a:000)

FUNCTION  incsearch#over#modules#exit#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/exit.vim:26
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return deepcopy(s:incsearch_exit)

FUNCTION  vital#_easymotion#Vim#Guard#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Guard.vim:5
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000039     return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  incsearch#parse_pattern()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:278
Called 36 times
Total time:   0.003083
 Self time:   0.003083

count  total (s)   self (s)
                              " search_key : '/' or '?'
                              " expr       : {pattern\/pattern}/{offset}
                              " expr       : {pattern}/;/{newpattern} :h //;
                              " return     : [{pattern\/pattern}, {offset}]
   36              0.000129   let very_magic = '\v'
   36              0.000132   let pattern  = '(%(\\.|.){-})'
   36              0.000247   let slash = '(\' . a:search_key . '&[^\\"|[:alnum:][:blank:]])'
   36              0.000095   let offset = '(.*)'
                            
   36              0.000272   let parse_pattern = very_magic . pattern . '%(' . slash . offset . ')?$'
   36              0.001325   let result = matchlist(a:expr, parse_pattern)[1:3]
   36              0.000314   if type(result) == type(0) || empty(result)
                                return []
   36              0.000054   endif
   36              0.000156   unlet result[1]
   36              0.000082   return result

FUNCTION  <SNR>145_on_exit_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:121
Called 82 times
Total time:   0.007869
 Self time:   0.003949

count  total (s)   self (s)
   82   0.006527   0.002607     call s:untracked_output(self, self.buf)
   82              0.000585     if has_key(s:untracked_jobs, self.file)
   50              0.000362       call remove(s:untracked_jobs, self.file)
   82              0.000121     endif

FUNCTION  <SNR>101_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:95
Called 27473 times
Total time:   0.747245
 Self time:   0.747245

count  total (s)   self (s)
27473              0.215966   if !hlexists(a:group)
                                return 0
27473              0.294653   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
27473              0.040399   endif
27473              0.051271   return 1

FUNCTION  <SNR>194_EasyMotion()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:1192
Called 2 times
Total time:   0.338217
 Self time:   0.003246

count  total (s)   self (s)
    2   0.000074   0.000037     let config = extend(s:default_config(), get(a:, 1, {}))
                                " Store s:current original_position & cursor_position {{{
                                " current cursor pos.
    2              0.000015     let s:current.cursor_position = [line('.'), col('.')]
                                " original start position.  This value could be changed later in visual
                                " mode
    2              0.000014     let s:current.original_position = get(s:current, 'original_position', s:current.cursor_position)
                                "}}}
                            
    2              0.000148     let win_first_line = line('w0') " visible first line num
    2              0.000009     let win_last_line  = line('w$') " visible last line num
                            
                                " Store the target positions list
                                " e.g. targets = [ [line, col], [line2, col2], ...]
    2              0.000004     let targets = []
                            
                                " Store info for Repeat motion {{{
    2              0.000005     if s:flag.dot_repeat != 1
                                    " Store Regular Expression
    2              0.000009         let s:previous['regexp'] = a:regexp
    2              0.000009         let s:previous['direction'] = a:direction
    2              0.000010         let s:previous['operator'] = v:operator
                            
                                    " Note: 'is_inclusive' value could be changed later when
                                    " bi-directional find motion depend on 'true' direction the cursor
                                    " will move.
    2              0.000010         let s:previous['is_inclusive'] = a:is_inclusive
                            
                                    " For special motion flag
    2              0.000009         let s:previous['line_flag'] = s:flag.within_line
    2              0.000021         let s:previous['bd_t_flag'] = s:flag.bd_t " bi-directional t motion
    2              0.000004     endif "}}}
                            
                                " To avoid side effect of overwriting buffer for tpope/repeat
                                " store current b:changedtick. Use this value later
    2              0.000008     let s:current.changedtick = b:changedtick
                            
    2              0.000003     try
                                    " -- Reset properties -------------------- {{{
                                    " Save original value and set new value
    2   0.000811   0.000024         call s:SaveValue()
    2   0.001408   0.000104         call s:turn_off_hl_error()
                                    " }}}
                                    " Setup searchpos args {{{
    2              0.000010         let search_direction = (a:direction == 1 ? 'b' : '')
    2              0.000010         let search_stopline = a:direction == 1 ? win_first_line : win_last_line
                            
    2              0.000005         if s:flag.within_line == 1
                                        let search_stopline = s:current.original_position[0]
    2              0.000003         endif
                                    "}}}
                            
                                    " Handle visual mode {{{
    2              0.000007         if ! empty(a:visualmode)
                                        " Decide at where visual mode start {{{
                                        normal! gv
                                        let v_start = [line("'<"),col("'<")] " visual_start_position
                                        let v_end   = [line("'>"),col("'>")] " visual_end_position
                            
                                        let v_original_pos = s:GetVisualStartPosition( s:current.cursor_position, v_start, v_end, search_direction)
                                        "}}}
                            
                                        " Reselect visual text {{{
                                        keepjumps call cursor(v_original_pos)
                                        exec "normal! " . a:visualmode
                                        keepjumps call cursor(s:current.cursor_position)
                                        "}}}
                                        " Update s:current.original_position
                                        " overwrite original start position
                                        let s:current.original_position = v_original_pos
    2              0.000003         endif "}}}
                            
                                    " Handle bi-directional t motion {{{
    2              0.000004         if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 0) "forward
    2              0.000002         else
    2              0.000006             let regexp = a:regexp
    2              0.000003         endif
                                    "}}}
                            
                                    " Handle dot repeat with count
    2              0.000004         if s:flag.count_dot_repeat
                                        let cursor_char = EasyMotion#helper#get_char_by_coord(s:current.cursor_position)
                                        if cursor_char =~# regexp
                                            call add(targets, s:current.cursor_position)
                                        endif
    2              0.000002         endif
                            
                                    " Construct match dict {{{
                                    " Note: searchpos() has side effect which jump cursor position.
                                    "       You can disable this side effect by add 'n' flags,
                                    "       but in this case, it's better to allows jump side effect
                                    "       to gathering matched targets coordinates.
    2              0.000031         let pos = searchpos(regexp, search_direction . (config.accept_cursor_pos ? 'c' : ''), search_stopline)
    4              0.000006         while 1
                                        " Reached end of search range
    4              0.000012             if pos == [0, 0]
    2              0.000004                 break
    2              0.000003             endif
                            
                                        " Skip folded lines {{{
    2   0.000051   0.000028             if EasyMotion#helper#is_folded(pos[0])
                                            if search_direction ==# 'b'
                                                " FIXME: Hmm... I should use filter()
                                                " keepjumps call cursor(foldclosed(pos[0]), 0)
                                            else
                                                keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                            endif
    2              0.000032             else
    2              0.000023                 call add(targets, pos)
    2              0.000002             endif
                                        "}}}
    2              0.000031             let pos = searchpos(regexp, search_direction, search_stopline)
    4              0.000006         endwhile
                                    "}}}
                            
                                    " Handle bidirection "{{{
                                    " For bi-directional t motion {{{
    2              0.000005         if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 1) "backward
    2              0.000003         endif
                                    "}}}
                                    " Reconstruct match dict
    2              0.000004         if a:direction == 2
                                        " Backward
                            
                                        " Jump back cursor_position
    2              0.000016             keepjumps call cursor(s:current.cursor_position[0], s:current.cursor_position[1])
                            
    2              0.000006             let targets2 = []
    2              0.000004             if s:flag.within_line == 0
    2              0.000006                 let search_stopline = win_first_line
                                        else
                                            let search_stopline = s:current.cursor_position[0]
    2              0.000002             endif
    3              0.000006             while 1
                                            " TODO: refactoring
    3              0.000178                 let pos = searchpos(regexp, 'b', search_stopline)
                                            " Reached end of search range
    3              0.000011                 if pos == [0, 0]
    2              0.000004                     break
    1              0.000002                 endif
                            
                                            " Skip folded lines {{{
    1   0.000120   0.000090                 if EasyMotion#helper#is_folded(pos[0])
                                                " keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                                continue
    1              0.000002                 endif
                                            "}}}
                            
    1              0.000006                 call add(targets2, pos)
    3              0.000006             endwhile
                                        " Merge match target dict"{{{
    2              0.000005             let t1 = 0 " forward
    2              0.000004             let t2 = 0 " backward
    2              0.000006             let targets3 = []
    4              0.000041             while t1 < len(targets) || t2 < len(targets2)
                                            " Forward -> Backward -> F -> B -> ...
    2              0.000008                 if t1 < len(targets)
    2              0.000012                     call add(targets3, targets[t1])
    2              0.000006                     let t1 += 1
    2              0.000003                 endif
    2              0.000007                 if t2 < len(targets2)
    1              0.000005                     call add(targets3, targets2[t2])
    1              0.000002                     let t2 += 1
    2              0.000003                 endif
    4              0.000006             endwhile
    2              0.000005             let targets = targets3
                                        "}}}
    2              0.000003         endif
                                    "}}}
                                    " Handle no match"{{{
    2              0.000008         let targets_len = len(targets)
    2              0.000005         if targets_len == 0
                                        call s:Throw('No matches')
    2              0.000002         endif
                                    "}}}
                            
                                    " Attach specific key as marker to gathered matched coordinates
    2              0.000041         let GroupingFn = function('s:GroupingAlgorithm' . s:grouping_algorithms[g:EasyMotion_grouping])
    2   0.002329   0.000142         let groups = GroupingFn(targets, split(g:EasyMotion_keys, '\zs'))
                            
                                    " -- Shade inactive source --------------- {{{
    2              0.000010         if g:EasyMotion_do_shade && targets_len != 1 && s:flag.dot_repeat != 1
    1              0.000002             if a:direction == 1 " Backward
                                            let shade_hl_re = s:flag.within_line ? '^.*\%#' : '\%'. win_first_line .'l\_.*\%#'
    1              0.000003             elseif a:direction == 0 " Forward
                                            let shade_hl_re = s:flag.within_line ? '\%#.*$' : '\%#\_.*\%'. win_last_line .'l'
    1              0.000002             else " Both directions
    1              0.000004                 let shade_hl_re = s:flag.within_line ? '^.*\%#.*$' : '\_.*'
    1              0.000001             endif
                            
    1   0.000079   0.000031             call EasyMotion#highlight#add_highlight( shade_hl_re, g:EasyMotion_hl_group_shade)
    1              0.000003             if g:EasyMotion_cursor_highlight
    1              0.000003                 let cursor_hl_re = '\%#'
    1   0.000029   0.000018                 call EasyMotion#highlight#add_highlight(cursor_hl_re, g:EasyMotion_hl_inc_cursor)
    1              0.000001             endif
    2              0.000003         endif
                                    " }}}
                            
                                    " -- Jump back before prompt for visual scroll {{{
                                    " Because searchpos() change current cursor position and
                                    " if you just use cursor(s:current.cursor_position) to jump back,
                                    " current line will become middle of line window
    2              0.000007         if ! empty(a:visualmode)
                                        keepjumps call winrestview({'lnum' : s:current.cursor_position[0], 'topline' : win_first_line})
    2              0.000002         else
                                        " for adjusting cursorline
    2              0.000011             keepjumps call cursor(s:current.cursor_position)
    2              0.000004         endif
                                    "}}}
                            
                                    " -- Prompt user for target group/character {{{
    2              0.000005         if s:flag.dot_repeat != 1
    2   0.327234   0.000052             let coords = s:PromptUser(groups)
                                    else
                                        let coords = s:DotPromptUser(groups)
    2              0.000002         endif
                                    "}}}
                            
                                    " -- Update cursor position -------------- {{{
                                    " First, jump back cursor to original position
    2              0.000014         keepjumps call cursor(s:current.original_position)
                            
                                    " Consider EasyMotion as jump motion :h jump-motion
    2              0.000022         normal! m`
                            
                                    " Update selection for visual mode {{{
    2              0.000008         if ! empty(a:visualmode)
                                        exec 'normal! ' . a:visualmode
    2              0.000003         endif
                                    " }}}
                            
                                    " For bi-directional motion, checking again whether the motion is
                                    " inclusive is necessary. This value will might be updated later
    2              0.000009         let is_inclusive_check = a:is_inclusive
                                    " For bi-directional motion, store 'true' direction for dot repeat
                                    " to handling inclusive/exclusive motion
    2              0.000005         if a:direction == 2
    2   0.000129   0.000075             let true_direction = EasyMotion#helper#is_greater_coords(   s:current.original_position, coords) > 0 ? 0 : 1
                                            " forward : backward
                                    else
                                        let true_direction = a:direction
    2              0.000003         endif
                            
    2              0.000005         if s:flag.dot_repeat == 1
                                        " support dot repeat {{{
                                        " Use visual mode to emulate dot repeat
                                        normal! v
                            
                                        " Deal with exclusive {{{
                                        if s:dot_repeat.is_inclusive == 0
                                            " exclusive
                                            if s:dot_repeat.true_direction == 0 "Forward
                                                let coords[1] -= 1
                                            elseif s:dot_repeat.true_direction == 1 "Backward
                                                " Shift visual selection to left by making cursor one key
                                                " left.
                                                normal! hoh
                                            endif
                                        endif "}}}
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " Execute previous operator
                                        let cmd = s:dot_repeat.operator
                                        if s:dot_repeat.operator ==# 'c'
                                            let cmd .= getreg('.')
                                        endif
                                        exec 'normal! ' . cmd
                                        "}}}
    2              0.000002         else
                                        " Handle inclusive & exclusive {{{
                                        " Overwrite inclusive flag for special case {{{
    2              0.000006             if s:flag.find_bd == 1 && true_direction == 1
                                            " Note: For bi-directional find motion s(f) & t
                                            " If true_direction is backward, the motion is 'exclusive'
                                            let is_inclusive_check = 0 " overwrite
                                            let s:previous.is_inclusive = 0 " overwrite
    2              0.000004             endif "}}}
    2              0.000004             if is_inclusive_check
                                            " Note: {{{
                                            " Inclusive motion requires that we eat one more
                                            " character to the right by forcing the motion to inclusive
                                            " if we're using a forward motion because
                                            " > :h exclusive
                                            " > Note that when using ':' any motion becomes characterwise
                                            " > exclusive.
                                            " and EasyMotion use ':'
                                            " See: h: o_v }}}
                                            normal! v
    2              0.000002             endif " }}}
                            
    2              0.000007             if s:current.is_operator && s:flag.linewise
                                            " TODO: Is there better solution?
                                            " Maike it linewise
                                            normal! V
    2              0.000002             endif
                            
                                        " Adjust screen especially for visual scroll & offscreen search {{{
                                        " Otherwise, cursor line will move middle line of window
    2              0.000170             keepjumps call winrestview({'lnum' : win_first_line, 'topline' : win_first_line})
                            
                                        " Jump to destination
    2              0.000023             keepjumps call cursor(coords[0], coords[1])
                            
                                        " To avoid side effect of overwriting buffer {{{
                                        " for tpope/vim-repeat
                                        " See: :h b:changedtick
    2              0.000011             if exists('g:repeat_tick')
                                            if g:repeat_tick == s:current.changedtick
                                                let g:repeat_tick = b:changedtick
                                            endif
    2              0.000003             endif "}}}
    2              0.000003         endif
                            
                                    " Set tpope/vim-repeat {{{
    2              0.000012         if s:current.is_operator == 1 && !(v:operator ==# 'y' && match(&cpo, 'y') == -1)
                                        " Store previous info for dot repeat {{{
                                        let s:dot_repeat.regexp = a:regexp
                                        let s:dot_repeat.direction = a:direction
                                        let s:dot_repeat.line_flag = s:flag.within_line
                                        let s:dot_repeat.is_inclusive = is_inclusive_check
                                        let s:dot_repeat.operator = v:operator
                                        let s:dot_repeat.bd_t_flag = s:flag.bd_t " Bidirectional t motion
                                        let s:dot_repeat.true_direction = true_direction " Check inclusive
                                        "}}}
                                        silent! call repeat#set("\<Plug>(easymotion-dotrepeat)")
    2              0.000004         endif "}}}
                            
                                    " Highlight all the matches by n-key find motions {{{
    2              0.000012         if s:current.is_search == 1 && s:current.is_operator == 0 && g:EasyMotion_add_search_history
                                        " It seems let &hlsearch=&hlsearch doesn't work when called
                                        " in script, so use :h feedkeys() instead.
                                        " Ref: :h v:hlsearch
                                        " FIXME: doesn't work with `c` operator
    2   0.000396   0.000055             call EasyMotion#helper#silent_feedkeys( ":let &hlsearch=&hlsearch\<CR>", 'hlsearch', 'n')
    2              0.000003         endif "}}}
                            
    2   0.000359   0.000103         call s:Message('Jumping to [' . coords[0] . ', ' . coords[1] . ']')
    2              0.000013         let s:EasyMotion_is_cancelled = 0 " Success
                                    "}}}
                                catch /^EasyMotion:.*/
                                    redraw
                            
                                    " Show exception message
                                    " The verbose option will take precedence
                                    if g:EasyMotion_verbose == 1 && g:EasyMotion_ignore_exception != 1
                                        echo v:exception
                                    endif
                            
                                    let s:previous['regexp'] = a:regexp
                                    " -- Activate EasyMotion ----------------- {{{
                                    let s:EasyMotion_is_active = 1
                                    call EasyMotion#attach_active_autocmd() "}}}
                            
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                catch
                                    call s:Message(v:exception . ' : ' . v:throwpoint)
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
    2              0.000004     finally
                                    " -- Restore properties ------------------ {{{
    2   0.001361   0.000141         call s:RestoreValue()
    2   0.000478   0.000035         call s:turn_on_hl_error()
    2   0.000118   0.000024         call EasyMotion#reset()
                                    " }}}
                                    " -- Remove shading ---------------------- {{{
    2   0.000417   0.000039         call EasyMotion#highlight#delete_highlight()
                                    " }}}
                            
    2              0.000009         if s:EasyMotion_is_cancelled == 0 " Success
                                        " -- Landing Highlight ------------------- {{{
    2              0.000007             if g:EasyMotion_landing_highlight
                                            call EasyMotion#highlight#add_highlight(a:regexp, g:EasyMotion_hl_move)
                                            call EasyMotion#highlight#attach_autocmd()
    2              0.000003             endif "}}}
                                        " -- Activate EasyMotion ----------------- {{{
    2              0.000008             let s:EasyMotion_is_active = 1
    2   0.000640   0.000064             call EasyMotion#attach_active_autocmd() "}}}
    2              0.000003         endif
    2              0.000004     endtry

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 6379 times
Total time:   5.867935
 Self time:   0.401347

count  total (s)   self (s)
 6379              0.015774   try
 6379   3.957973   0.099174     call <sid>map_keys()
                              catch
                                " no-op
 6379              0.014104   endtry
 6379              0.048208   let cur = bufnr('%')
 6379              0.046797   if cur == s:current_bufnr && &columns == s:column_width
 6373              0.080380     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
 6273              0.026732       return s:current_tabline
  100              0.000237     endif
  106              0.000137   endif
                            
  106   0.021280   0.002705   let b = airline#extensions#tabline#new_builder()
  106              0.000711   let tab_bufs = tabpagebuflist(tabpagenr())
  106              0.000451   let show_buf_label_first = 0
                            
  106              0.000669   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
  106              0.000163   endif
  106              0.000260   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
  106              0.000154   endif
                            
  106              0.000825   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
  106              0.000373   let b.overflow_group = 'airline_tabhid'
  106   0.005900   0.002368   let b.buffers = airline#extensions#tabline#buflist#list()
  106              0.000596   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
  106              0.000150   endif
                            
  106              0.000355   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
  106              0.000978   if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
  106              0.000155   endif
                            
  106              0.000294   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
  106              0.000995   let current_buffer = max([index(b.buffers, cur), 0])
  106              0.000772   let last_buffer = len(b.buffers) - 1
  106   0.005069   0.001112   call b.insert_titles(current_buffer, 0, last_buffer)
                            
  106   0.001976   0.000924   call b.add_section('airline_tabfill', '')
  106   0.001531   0.000681   call b.split()
  106   0.001451   0.000717   call b.add_section('airline_tabfill', '')
  106              0.000295   if !show_buf_label_first
  106   0.008536   0.002559     call airline#extensions#tabline#add_label(b, 'buffers', 1)
  106              0.000159   endif
                            
  106   0.005032   0.002420   call airline#extensions#tabline#add_tab_label(b)
                            
  106              0.000542   let s:current_bufnr = cur
  106              0.000494   let s:column_width = &columns
  106   1.571948   0.001448   let s:current_tabline = b.build()
  106              0.000885   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
  106              0.000765   return s:current_tabline

FUNCTION  <SNR>287_get_all_list()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/list.vim:16
Called 3 times
Total time:   0.000642
 Self time:   0.000642

count  total (s)   self (s)
                                " return the current list's row number
                                " return 0 if not exists.
                                
    3              0.000016     let row = prevnonblank(a:row)
                            
    3              0.000013     let save_pos = getpos('.')
    3              0.000012     call cursor(row,1)
                            
    6              0.000377     while getline(row) !~ s:p.all_list && row != 0
    5              0.000026         let idt = indent(row)
    5              0.000010         if idt == 0 
    2              0.000004             let row = 0
    2              0.000004             break
    3              0.000006         endif
    3              0.000018         let idt_ptn = '^\s\{,'.(idt-1).'}\S'
    3              0.000044         let [row,col] = searchpos(idt_ptn, 'b',0,100)
    6              0.000016     endwhile
                                
    3              0.000021     call setpos('.',save_pos)
                            
    3              0.000006     return row

FUNCTION  vital#_incsearch#Over#Commandline#Modules#CursorMove#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/CursorMove.vim:7
Called 1 time
Total time:   0.000028
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000028   0.000021 return map({'make': ''}, "vital#_incsearch#function('<SNR>250_' . v:key)")

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:131
Called 17139 times
Total time:   0.307873
 Self time:   0.307873

count  total (s)   self (s)
17139              0.113003   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
17139              0.026285   endif
17139              0.052239   return s:has_fugitive

FUNCTION  <SNR>232_SID()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:50
Called 20 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
   20              0.000658   return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')

FUNCTION  <SNR>142_tabline_evaluated_length()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:223
Called 532 times
Total time:   0.097683
 Self time:   0.015469

count  total (s)   self (s)
  532   0.097359   0.015145   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>235__import_func_name()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:204
Called 40 times
Total time:   0.001675
 Self time:   0.001166

count  total (s)   self (s)
   40   0.001646   0.001137   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  365()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:45
Called 14 times
Total time:   0.000458
 Self time:   0.000292

count  total (s)   self (s)
   14   0.000423   0.000257 	let self.col = s:_clamp(a:pos, 0, self.length())
   14              0.000027 	return self

FUNCTION  <SNR>101_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:25
Called 23106 times
Total time:   0.435236
 Self time:   0.435236

count  total (s)   self (s)
23106              0.158211   if index(a:list, a:name) == -1
16218              0.086693     call add(a:list, a:name)
16218              0.032883     return 1
 6888              0.010828   else
 6888              0.030430     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
 6888              0.009797     endif
 6888              0.013774     return 0
                              endif

FUNCTION  <SNR>139_GetInfoUnderCursor()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:54
Called 3 times
Total time:   0.000565
 Self time:   0.000446

count  total (s)   self (s)
    3              0.000021   let raw_cur_line = getline('.')
                            
    3              0.000014   if empty(raw_cur_line)
                                return [v:null, v:null]
    3              0.000005   endif
                            
                              " tag like s:StopCursorTimer has `:`, so we can't simply use split(tag, ':')
    3              0.000022   let last_semicoln_idx = strridx(raw_cur_line, ':')
    3              0.000026   let lnum = raw_cur_line[last_semicoln_idx+1:]
                            
                              " TODO use range info of LSP symbols?
    3              0.000021   if t:vista.provider ==# 'coc'
                                let tag = vista#util#Trim(raw_cur_line[:stridx(raw_cur_line, ':')-1])
                                let source_line = t:vista.source.line_trimmed(lnum)
                                return [tag, source_line]
    3              0.000018   elseif t:vista.provider ==# 'markdown' || t:vista.provider ==# 'rst'
                                if line('.') < 3
                                  return [v:null, v:null]
                                endif
                                " The first two lines are for displaying fpath. the lnum is 1-based, while
                                " idex is 0-based.
                                " So it's line('.') - 3 instead of line('.').
                                let tag = vista#extension#{t:vista.provider}#GetHeader(line('.')-3)
                                if tag is# v:null
                                  return [v:null, v:null]
                                endif
                                let source_line = t:vista.source.line_trimmed(lnum)
                                return [tag, source_line]
    3              0.000004   endif
                            
    3   0.000133   0.000040   let source_line = t:vista.source.line_trimmed(lnum)
    3              0.000013   if empty(source_line)
    1              0.000005     return [v:null, v:null]
    2              0.000004   endif
                            
                              " For scoped tag
                              " Currently vlnum_cache is ctags provider only.
    2              0.000018   if has_key(t:vista, 'vlnum_cache') && t:vista.provider ==# 'ctags'
    2   0.000055   0.000029     let tagline = t:vista.get_tagline_under_cursor()
    2              0.000009     if !empty(tagline)
    2              0.000010       return [tagline.name, source_line]
                                endif
                              endif
                            
                              " For scopeless tag
                              " peer_ilog(PEER,FORMAT,...):90
                              let trimmed_line = vista#util#Trim(raw_cur_line)
                              let left_parenthsis_idx = stridx(trimmed_line, '(')
                              if left_parenthsis_idx > -1
                                " Ignore the visibility symbol, e.g., +test2()
                                let tag = s:RemoveVisibility(trimmed_line[0 : left_parenthsis_idx-1])
                                return [tag, source_line]
                              endif
                            
                              " Since we include the space ` `, we need to trim the result later.
                              " / --> github.com/golang/dep/gps:11
                              if t:vista.provider ==# 'markdown'
                                let matched = matchlist(trimmed_line, '\([a-zA-Z:#_.,/<> ]\-\+\)\(H\d:\d\+\)$')
                              else
                                let matched = matchlist(trimmed_line, '\([a-zA-Z:#_.,/<> ]\-\+\):\(\d\+\)$')
                              endif
                            
                              let tag = get(matched, 1, '')
                            
                              if empty(tag)
                                let tag = raw_cur_line[:last_semicoln_idx-1]
                              endif
                            
                              let tag = s:RemoveVisibility(vista#util#Trim(tag))
                            
                              return [tag, source_line]

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 17054 times
Total time:   0.707237
 Self time:   0.347164

count  total (s)   self (s)
17054   0.693501   0.333428   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '‚Ä¶' : '>') : &filetype

FUNCTION  signature#sign#Remove()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/sign.vim:38
Called 780 times
Total time:   0.075807
 Self time:   0.066778

count  total (s)   self (s)
                              " Description: Remove signs for marks/markers from the specified line number
                              " Arguments:
                              "   sign : The mark/marker whose sign is to be placed/removed/toggled
                              "   lnum : Line number from which the sign is to be removed
                              "          If sign is a marker and lnum is 0, the sign will be removed from all lines
                              "          If sign is a mark   and lnum is 0, the lnum will be found and the sign will be removed from that line
                            
                              "echom "DEBUG: sign = " . a:sign . ",  lnum = " . a:lnum
                            
                              " If Signature is not enabled, return
  780              0.006005   if !b:sig_enabled | return | endif
                            
                              " Remove sign for markers
  780   0.025065   0.016036   if signature#utils#IsValidMarker(a:sign)
                                let b:sig_markers[a:lnum] = substitute(b:sig_markers[a:lnum], "\\C" . escape( a:sign, '$^' ), "", "")
                            
                                " If there are no markers on the line, delete signs on that line
                                if b:sig_markers[a:lnum] == ""
                                  call remove(b:sig_markers, a:lnum)
                                endif
                                call s:RefreshLine(a:lnum)
                            
                              " Remove sign for marks
  780              0.001369   else
                                " For marks, if a:lnum == 0, find out the line where the mark was placed
  780              0.002368     if a:lnum == 0
  780              0.008810       let l:arr = keys(filter(copy(b:sig_marks), 'v:val =~# a:sign'))
  780              0.005328       if empty(l:arr) | return | endif
                                else
                                  let l:arr = [a:lnum]
                                endif
                                if (v:version >= 800)
                                  call assert_true(len(l:arr) == 1, "Multiple marks found where one was expected")
                                elseif (len(l:arr) != 1)
                                  echoerr "Multiple marks found where one was expected"
                                endif
                            
                                for l:lnum in l:arr
                                  " FIXME: Placed guard to avoid triggering issue #53
                                  if has_key(b:sig_marks, l:lnum)
                                    let b:sig_marks[l:lnum] = substitute(b:sig_marks[l:lnum], "\\C" . a:sign, "", "")
                                    " If there are no marks on the line, delete signs on that line
                                    if b:sig_marks[l:lnum] == ""
                                      call remove(b:sig_marks, l:lnum)
                                    endif
                                  endif
                                  call s:RefreshLine(l:lnum)
                                endfor
                              endif

FUNCTION  <SNR>231_Error()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:424
Called 1 time
Total time:   0.060657
 Self time:   0.000035

count  total (s)   self (s)
    1   0.060656   0.000034   return call(function('s:_echohl'), [a:msg, 'ErrorMsg'] + a:000)

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 9 times
Total time:   0.000540
 Self time:   0.000540

count  total (s)   self (s)
    9              0.000139   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    9              0.000011   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 17056 times
Total time:   0.219974
 Self time:   0.219974

count  total (s)   self (s)
17056              0.082967   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
17056              0.026211   endif
17056              0.031782   return ''

FUNCTION  <SNR>215__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:21
Called 1 time
Total time:   0.000090
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000087   0.000008 	let s:String  = s:V.import("Over.String")

FUNCTION  <SNR>136_OnBlankLine()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:892
Called 5578 times
Total time:   1.317088
 Self time:   0.108751

count  total (s)   self (s)
 5578   1.311710   0.103373   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  ale#handlers#writegood#ResetOptions()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/writegood.vim:4
Called 1 time
Total time:   0.000095
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000039   0.000014     call ale#Set('writegood_options', '')
    1   0.000027   0.000010     call ale#Set('writegood_executable', 'write-good')
    1   0.000028   0.000013     call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))

FUNCTION  <SNR>260__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:15
Called 1 time
Total time:   0.001252
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000004 	let s:V = a:V
    1   0.001246   0.000011 	let s:E  = s:V.import("Over.Exception")

FUNCTION  incsearch#over#extend#enrich()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:16
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000008   return extend(a:cli, s:cli)

FUNCTION  <SNR>231_emulate_search_error()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:354
Called 3 times
Total time:   0.064439
 Self time:   0.001123

count  total (s)   self (s)
    3              0.000043   let from = get(a:, 1, winsaveview())
    3              0.000016   let keyseq = (a:direction == s:DIRECTION.forward ? '/' : '?')
    3              0.000011   let old_errmsg = v:errmsg
    3              0.000011   let v:errmsg = ''
                              " NOTE:
                              "   - XXX: Handle `n` and `N` preparation with s:silent_after_search()
                              "   - silent!: Do not show error and warning message, because it also
                              "     echo v:throwpoint for error and save messages in message-history
                              "   - Unlike v:errmsg, v:warningmsg doesn't set if it use :silent!
                              " Get first error
    3   0.001261   0.000053   silent! call incsearch#execute_search(keyseq . "\<CR>")
    3              0.000276   call winrestview(from)
    3              0.000013   if g:incsearch#do_not_save_error_message_history
                                if v:errmsg !=# ''
                                  call s:Error(v:errmsg)
                                else
                                  let v:errmsg = old_errmsg
                                endif
    3              0.000005   else
                                " NOTE: show more than two errors e.g. `/\za`
    3              0.000019     let last_error = v:errmsg
    3              0.000005     try
                                  " Do not use silent! to show warning
    3   0.001538   0.000087       call incsearch#execute_search(keyseq . "\<CR>")
    1              0.000026     catch /^Vim\%((\a\+)\)\=:E/
    1              0.000045       let first_error = matchlist(v:exception, '\v^Vim%(\(\a+\))=:(E.*)$')[1]
    1   0.060683   0.000026       call s:Error(first_error, 'echom')
    1              0.000005       if last_error !=# '' && last_error !=# first_error
                                    call s:Error(last_error, 'echom')
    1              0.000001       endif
    3              0.000009     finally
    3              0.000278       call winrestview(from)
    3              0.000006     endtry
    3              0.000012     if v:errmsg ==# ''
    2              0.000010       let v:errmsg = old_errmsg
    3              0.000003     endif
    3              0.000004   endif

FUNCTION  EasyMotion#helper#should_case_sensitive()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:75
Called 10 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
   10              0.000026     if !a:is_search
                                    if g:EasyMotion_smartcase == 0
                                        return 0
                                    else
                                        " return 1 if input didn't match uppercase letter
                                        return match(a:input, '\u') == -1
                                    endif
   10              0.000015     endif
                            
   10              0.000125     if (g:EasyMotion_smartcase == 1 && match(a:input, '\u') == -1) ||  (&ignorecase && &smartcase && match(a:input, '\u') == -1) ||  (&ignorecase && !&smartcase)
   10              0.000016         return 1
                                endif
                                return 0

FUNCTION  <SNR>101_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:164
Called 5898 times
Total time:   1.387855
 Self time:   1.387855

count  total (s)   self (s)
                              " a:list needs to have 5 items!
 5898              0.014653   let res = ''
 5898              0.014355   let i = -1
35388              0.079878   while i < 4
29490              0.071963     let i += 1
29490              0.138116     let item = get(a:list, i, '')
29490              0.070236     if item is ''
 8561              0.015603       continue
20929              0.030138     endif
20929              0.042681     if i == 0
 4323              0.024725       let res .= ' guifg='.item
16606              0.034307     elseif i == 1
 3862              0.016237       let res .= ' guibg='.item
12744              0.025783     elseif i == 2
 5898              0.031521       let res .= ' ctermfg='.item
 6846              0.013411     elseif i == 3
 5439              0.025994       let res .= ' ctermbg='.item
 1407              0.002671     elseif i == 4
 1407              0.012514       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
20929              0.031160     endif
26827              0.058817   endwhile
 5898              0.014815   return res

FUNCTION  <SNR>25_dopopd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:485
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000019   if !exists('w:fzf_pushd')
    3              0.000006     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet w:fzf_pushd

FUNCTION  signature#sign#Refresh()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/sign.vim:157
Called 15 times
Total time:   0.196956
 Self time:   0.021525

count  total (s)   self (s)
                              " Description: Add signs for new marks/markers and remove signs for deleted marks/markers
                              " Arguments:   Specify an argument to force a sign refresh
                            
   15   0.009265   0.000454   call s:InitializeVars(a:0 && a:1)
                              " If Signature is not enabled, return
   15              0.000130   if !b:sig_enabled | return | endif
                            
  795   0.049038   0.002604   for i in signature#mark#GetList('free', 'buf_curr')
                                " ... remove it
  780   0.090002   0.014195     call signature#sign#Remove(i, 0)
  795              0.001685   endfor
                            
                              " Add signs for marks ...
   15   0.043876   0.000516   for [l:mark, l:lnum, _] in signature#mark#GetList('used', 'buf_curr')
                                " ... if mark is not present in our b:sig_marks list or if it is present but at the wrong line,
                                " remove the old sign and add a new one
                                if (  !has_key(b:sig_marks, l:lnum) || (b:sig_marks[l:lnum] !~# l:mark) || a:0 )
                                  call signature#sign#Remove(l:mark, 0)
                                  call signature#sign#Place (l:mark, l:lnum)
                                endif
   15              0.000035   endfor
                            
   15   0.001583   0.000564   call signature#sign#ToggleDummy()
                            
                              " We do not add signs for markers as SignRefresh is executed periodically and we don't have a way to determine if the
                              " marker already has a sign or not

FUNCTION  <SNR>231__echohl()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:432
Called 1 time
Total time:   0.060622
 Self time:   0.060622

count  total (s)   self (s)
    1              0.000010   let echocmd = get(a:, 1, 'echo')
    1              0.060469   redraw | echo ''
    1              0.000094   exec 'echohl' a:hlgroup
    1              0.000034   exec echocmd string(a:msg)
    1              0.000012   echohl None

FUNCTION  <SNR>232__528()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:195
Called 1 time
Total time:   0.000096
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000096   0.000028   return call(<SNR>232_funcmanage()['_528']['func'], a:000, <SNR>232_funcmanage()['_528']['dict'])

FUNCTION  <SNR>191_SetListsImpl()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:78
Called 50 times
Total time:   0.040898
 Self time:   0.014528

count  total (s)   self (s)
   50              0.000953     let l:title = expand('#' . a:buffer . ':p')
                            
   50              0.000197     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
   50              0.000149     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
   50   0.001472   0.000821         let l:ids = s:WinFindBuf(a:buffer)
                            
  100              0.000287         for l:id in l:ids
   50              0.000449             if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
   50              0.000077             else
   50   0.004761   0.000953                 call setloclist(l:id, s:FixList(a:buffer, a:loclist))
   50              0.000403                 call setloclist(l:id, [], 'r', {'title': l:title})
   50              0.000069             endif
  100              0.000163         endfor
   50              0.000066     endif
                            
                                " Save the current view before opening/closing any window
   50              0.000599     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
   50   0.003154   0.000790     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
   50              0.000066     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
   50   0.001727   0.000718     if !ale#engine#IsCheckingBuffer(a:buffer)
   50   0.019359   0.000821         call s:CloseWindowIfNeeded(a:buffer)
   50              0.000058     endif

FUNCTION  <SNR>194_PromptUser()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:969
Called 2 times
Total time:   0.327182
 Self time:   0.309903

count  total (s)   self (s)
                                " Recursive
    2              0.000010     let group_values = values(a:groups)
                            
                                " -- If only one possible match, jump directly to it {{{
    2              0.000006     if len(group_values) == 1
    1              0.000004         if mode(1) ==# 'no'
                                        " Consider jump to first match
                                        " NOTE: matchstr() handles multibyte characters.
                                        let s:dot_repeat['target'] = matchstr(g:EasyMotion_keys, '^.')
    1              0.000001         endif
    1              0.107852         redraw
    1              0.000005         return group_values[0]
    1              0.000002     endif
                                " }}}
                            
                                " -- Prepare marker lines ---------------- {{{
    1              0.000002     let lines = {}
                            
    1   0.000251   0.000021     let coord_key_dict = s:CreateCoordKeyDict(a:groups)
                            
    1              0.000003     let prev_col_num = 0
    3              0.000013     for dict_key in sort(coord_key_dict[0])
                                    " NOTE: {{{
                                    " let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                                    " Perform <Plug>(easymotion-w)
                                    "
                                    " lines[line_num]['orig']:
                                    "   Lorem ipsum dolor sit amet consectetur adipisicing
                                    "
                                    " {target_char}:
                                    "   {L}orem {i}psum {d}olor {s}it {a}met {c}onsectetur {a}dipisicing
                                    "
                                    " lines[line_num]['marker'], {marker_chars}:
                                    "   {A}orem {B}psum {C}olor {D}it {E}met {F}onsectetur {G}dipisicing
                                    "   2-key-combo: {marker_chars} could be 1 or 2 chars like {AB}
                                    "
                                    " }}}
                            
                                    " Prepare original line and marker line {{{
    2              0.000022         let [line_num, col_num] = split(dict_key, ',')
                            
    2              0.000010         let line_num = str2nr(line_num)
    2              0.000009         let col_num = str2nr(col_num)
    2              0.000011         if ! has_key(lines, line_num)
    2              0.000014             let current_line = getline(line_num)
    2              0.000023             let lines[line_num] = { 'orig': current_line, 'marker': current_line, 'mb_compensation': 0, }
                                        " mb_compensation -> multibyte compensation
    2              0.000005             let prev_col_num = 0
    2              0.000003         endif "}}}
                            
                                    " Multibyte Compensation: {{{
                                    " Solve multibyte issues by matching the byte column
                                    " number instead of the visual column
                                    " Compensate for byte difference between marker
                                    " character and target character
                                    "
                                    " This has to be done in order to match the correct
                                    " column; \%c matches the byte column and not display
                                    " column.
    2              0.000021         let col_num = max([prev_col_num + 1,  col_num - lines[line_num]['mb_compensation']])
    2              0.000007         let prev_col_num = col_num
                                    "}}}
                            
                                    " Prepare marker characters {{{
    2              0.000011         let marker_chars = coord_key_dict[1][dict_key]
    2   0.000059   0.000049         let marker_chars_len = EasyMotion#helper#strchars(marker_chars)
                                    "}}}
                            
                                    " Replace {target} with {marker} & Highlight {{{
    2              0.000005         let col_add = 0 " Column add byte length
                                    " Disable two-key-combo feature?
    2              0.000011         let marker_max_length = g:EasyMotion_disable_two_key_combo == 1 ? 1 : 2
    4              0.000018         for i in range(min([marker_chars_len, marker_max_length]))
    2              0.000022             let marker_char = split(marker_chars, '\zs')[i]
                                        " EOL {{{
    2              0.000017             if strlen(lines[line_num]['marker']) < col_num + col_add
                                            " Append marker chars if target is EOL
                                            let lines[line_num]['marker'] .= ' '
    2              0.000004             endif "}}}
                            
    2              0.000013             let target_col_regexp = '\%' . (col_num + col_add) . 'c.'
    2              0.000057             let target_char = matchstr(lines[line_num]['marker'], target_col_regexp)
    2              0.000016             let space_len = strdisplaywidth(target_char) - strdisplaywidth(marker_char)
                                        " Substitute marker character
    2              0.000013             let substitute_expr = marker_char . repeat(' ', space_len)
                            
    2              0.000057             let lines[line_num]['marker'] = substitute( lines[line_num]['marker'], target_col_regexp, escape(substitute_expr,'&'), '')
                            
                                        " Highlight targets {{{
    2              0.000019             let _hl_group =   (marker_chars_len == 1) ? g:EasyMotion_hl_group_target   : (i == 0) ? g:EasyMotion_hl2_first_group_target   : g:EasyMotion_hl2_second_group_target
                            
    2              0.000011             if exists('*matchaddpos')
    2   0.000149   0.000042                 call EasyMotion#highlight#add_pos_highlight( line_num, col_num + col_add, _hl_group)
                                        else
                                            call EasyMotion#highlight#add_highlight( '\%' . line_num . 'l' . target_col_regexp, _hl_group)
    2              0.000004             endif
                                        "}}}
                            
                                        " Add marker/target length difference for multibyte compensation
    2              0.000022             let lines[line_num]['mb_compensation'] += strlen(target_char) - strlen(substitute_expr)
                                        " Shift column
    2              0.000009             let col_add += strlen(marker_char)
    4              0.000008         endfor
                                    "}}}
    3              0.000006     endfor
                            
    1              0.000006     let lines_items = items(lines)
                                " }}}
                            
                                " -- Put labels on targets & Get User Input & Restore all {{{
                                " Save undo tree
    1   0.011238   0.000213     let undo_lock = EasyMotion#undo#save()
    1              0.000003     try
                                    " Set lines with markers {{{
    1   0.000124   0.000031         call s:SetLines(lines_items, 'marker')
    1              0.107332         redraw "}}}
                            
                                    " Get target character {{{
    1   0.000123   0.000020         call s:Prompt('Target key')
    1   0.000119   0.000015         let char = s:GetChar()
                                    "}}}
                            
                                    " Convert uppercase {{{
    1              0.000006         if g:EasyMotion_use_upper == 1 && match(g:EasyMotion_keys, '\l') == -1
                                        let char = toupper(char)
    1              0.000002         endif "}}}
                            
                                    " Jump first target when Enter or Space key is pressed "{{{
    1              0.000008         if (char ==# "\<CR>" && g:EasyMotion_enter_jump_first == 1) ||  (char ==# "\<Space>" && g:EasyMotion_space_jump_first == 1)
                                        " NOTE: matchstr() is multibyte aware.
                                        let char = matchstr(g:EasyMotion_keys, '^.')
    1              0.000002         endif "}}}
                            
                                    " For dot repeat {{{
    1              0.000004         if mode(1) ==# 'no'
                                        " Store previous target when operator pending mode
                                        if s:current.dot_prompt_user_cnt == 0
                                            " Store
                                            let s:dot_repeat['target'] = char
                                        else
                                            " Append target chars
                                            let s:dot_repeat['target'] .= char
                                        endif
    1              0.000001         endif "}}}
                            
    1              0.000001     finally
                                    " Restore original lines
    1   0.000081   0.000027         call s:SetLines(lines_items, 'orig')
                            
                                    " Un-highlight targets {{{
    1   0.000099   0.000022         call EasyMotion#highlight#delete_highlight( g:EasyMotion_hl_group_target, g:EasyMotion_hl2_first_group_target, g:EasyMotion_hl2_second_group_target, )
                                    " }}}
                            
                                    " Restore undo tree
    1   0.005484   0.000008         call undo_lock.restore()
                            
    1              0.093217         redraw
    1              0.000005     endtry "}}}
                            
                                " -- Check if we have an input char ------ {{{
    1              0.000009     if empty(char)
                                    call s:Throw('Cancelled')
    1              0.000002     endif
                                " }}}
                                " -- Check if the input char is valid ---- {{{
    1              0.000005     if ! has_key(a:groups, char)
                                    call s:Throw('Invalid target')
    1              0.000001     endif
                                " }}}
                            
    1              0.000006     let target = a:groups[char]
                            
    1              0.000019     if type(target) == type([])
                                    " Return target coordinates
    1              0.000002         return target
                                else
                                    " Prompt for new target character
                                    let s:current.dot_prompt_user_cnt += 1
                                    return s:PromptUser(target)
                                endif

FUNCTION  <SNR>190_UpdateLineNumbers()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:256
Called 50 times
Total time:   0.003236
 Self time:   0.003236

count  total (s)   self (s)
   50              0.000200     let l:line_map = {}
   50              0.000201     let l:line_numbers_changed = 0
                            
   50              0.000558     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
   50              0.000079     endfor
                            
   50              0.000137     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
   50              0.000149     endfor
                            
                                " When the line numbers change, sort the list again
   50              0.000161     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
   50              0.000061     endif

FUNCTION  <SNR>164_GetLinterNames()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:439
Called 476 times
Total time:   0.037627
 Self time:   0.037627

count  total (s)   self (s)
  476              0.004122     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
  476              0.001848     if l:buffer_ale_linters is# 'all'
                                    return 'all'
  476              0.000784     endif
                            
                                " b:ale_linters can be set to a List.
  476              0.002790     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
  476              0.000653     endif
                            
                                " Try to get a buffer-local setting for the filetype
  476              0.002929     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
  476              0.000648     endif
                            
                                " Try to get a global setting for the filetype
  476              0.002693     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
  476              0.000657     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
  476              0.001416     if g:ale_linters_explicit
                                    return []
  476              0.000613     endif
                            
                                " Try to get a default setting for the filetype
  476              0.003389     if has_key(s:default_ale_linters, a:original_filetype)
    1              0.000006         return s:default_ale_linters[a:original_filetype]
  475              0.000792     endif
                            
  475              0.001009     return 'all'

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:380
Called 476 times
Total time:   0.089646
 Self time:   0.060787

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
  476   0.015688   0.005972     if ale#util#InSandbox()
                                    return []
  476              0.000727     endif
                            
  476              0.001917     let l:combined_linters = []
                            
  952              0.003926     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
  476              0.003291         if !has_key(s:runtime_loaded_map, l:filetype)
    3   0.030714   0.011571             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
    3              0.000023             let s:runtime_loaded_map[l:filetype] = 1
  476              0.000910         endif
                            
  476              0.006230         call extend(l:combined_linters, get(s:linters, l:filetype, []))
  952              0.001980     endfor
                            
  476              0.001728     return l:combined_linters

FUNCTION  <SNR>108_ale_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:126
Called 112 times
Total time:   0.001513
 Self time:   0.001513

count  total (s)   self (s)
  112              0.000801   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
  112              0.000183   endif

FUNCTION  EasyMotion#S()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:132
Called 2 times
Total time:   1.411464
 Self time:   0.000195

count  total (s)   self (s)
    2              0.000007     if a:direction == 1
                                    let is_inclusive = 0
    2              0.000002     else
                                    " Note: Handle bi-direction later because 'f' motion is inclusive but
                                    " 'F' motion is exclusive
    2              0.000016         let is_inclusive = mode(1) ==# 'no' ? 1 : 0
    2              0.000003     endif
    2              0.000014     let s:flag.find_bd = a:direction == 2 ? 1 : 0
    2   1.073060   0.000046     let re = s:findMotion(a:num_strokes, a:direction)
    2   0.000071   0.000033     if s:handleEmpty(re, a:visualmode) | return | endif
    2   0.338270   0.000053     call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
    2              0.000008     return s:EasyMotion_is_cancelled

FUNCTION  vital#_easymotion#Data#Dict#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/Dict.vim:5
Called 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000069     return map({'pick': '', 'clear': '', 'max_by': '', 'foldl': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>139_ApplyHighlight()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:301
Called 1 time
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
    1              0.000009   if exists('w:vista_highlight_id')
                                call matchdelete(w:vista_highlight_id)
                                unlet w:vista_highlight_id
    1              0.000002   endif
                            
    1              0.000007   if get(g:, 'vista_highlight_whole_line', 0)
                                let hi_pos = a:lnum
    1              0.000002   else
    1              0.000006     let cur_line = getline(a:lnum)
                                " Current line may contains +,-,~, use `\S` is incorrect to find the right
                                " starting postion.
    1              0.000022     let [_, start, _] = matchstrpos(cur_line, '[a-zA-Z0-9_,#:]')
                            
                                " If we know the tag, then what we have to do is to use the length of tag
                                " based on the starting point.
                                "
                                " start is 0-based, while the column used in matchstrpos is 1-based.
    1              0.000003     if a:0 == 1
    1              0.000010       let hi_pos = [a:lnum, start+1, strlen(a:1)]
                                else
                                  let [matched, end, _] = matchstrpos(cur_line, ':\d\+$')
                                  let hi_pos = [a:lnum, start+1, end - start]
    1              0.000001     endif
    1              0.000002   endif
                            
    1              0.000060   let w:vista_highlight_id = matchaddpos('IncSearch', [hi_pos])
                            
    1              0.000004   if a:ensure_visible
                                execute 'normal!' a:lnum.'z.'
    1              0.000002   endif

FUNCTION  <SNR>129_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:272
Called 24 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
   24              0.000124   return a:from_count == 0 && a:to_count > 0

FUNCTION  627()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 3 times
Total time:   0.000265
 Self time:   0.000142

count  total (s)   self (s)
    3              0.000017     let bufnum = get(self.buffers, a:i, -1)
    3              0.000021     if bufnum == -1
                                  return ''
    3              0.000004     endif
    3   0.000177   0.000054     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000011     if bufnum == bufnr('%')
    3              0.000017       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000003     endif
    3              0.000006     return group

FUNCTION  riv#path#is_directory()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:136
Called 169 times
Total time:   0.002678
 Self time:   0.002678

count  total (s)   self (s)
  169              0.002537     return a:name =~ '\w[\\/]$' 

FUNCTION  305()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:84
Called 70 times
Total time:   0.001342
 Self time:   0.000814

count  total (s)   self (s)
   70   0.001292   0.000764 	return self.line.str()

FUNCTION  306()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:89
Called 14 times
Total time:   0.000681
 Self time:   0.000124

count  total (s)   self (s)
   14   0.000676   0.000119 	return self.line.set(a:line)

FUNCTION  308()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:99
Called 21 times
Total time:   0.000500
 Self time:   0.000500

count  total (s)   self (s)
                            	" 1 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å¶„ÇÇ‰∏äÊõ∏„Åç„Åô„Çã
                            	" 0 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞‰∏äÊõ∏„Åç„Åó„Å™„ÅÑ
   21              0.000111 	let overwrite = get(a:, 1, 1)
   21              0.000072 	if overwrite || self.variables.is_setted == 0
   18              0.000069 		let self.variables.input = a:char
   18              0.000052 		let self.variables.is_setted = 1
   21              0.000135 	endif

FUNCTION  309()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:110
Called 14 times
Total time:   0.000149
 Self time:   0.000111

count  total (s)   self (s)
   14   0.000143   0.000105 	return self.line.pos()

FUNCTION  409()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/exit.vim:18
Called 15 times
Total time:   0.000983
 Self time:   0.000323

count  total (s)   self (s)
   15   0.000748   0.000171   if   a:cmdline.is_input("\<CR>") || a:cmdline.is_input("\<NL>")
    3   0.000078   0.000021     call a:cmdline.setchar('')
    3   0.000049   0.000023     call a:cmdline.exit(self.exit_code)
   15              0.000022   endif

FUNCTION  riv#ptn#get_tar_idx()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:102
Called 2077 times
Total time:   0.105420
 Self time:   0.105420

count  total (s)   self (s)
                                " return the index of target link.
                                " >>> echo riv#ptn#get_tar_idx(".. _aaa: a.html",3)
                                " 0
 2077              0.083698     if a:col <= matchend(a:line, g:_riv_p.link_line_target)
                                    return 0
 2077              0.004138     else
 2077              0.004367         return -1
                                endif

FUNCTION  <SNR>235__dot_to_sharp()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:235
Called 40 times
Total time:   0.000509
 Self time:   0.000509

count  total (s)   self (s)
   40              0.000489   return substitute(a:name, '\.', '#', 'g')

FUNCTION  <SNR>196_inc_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:271
Called 8 times
Total time:   0.000934
 Self time:   0.000426

count  total (s)   self (s)
    8   0.000565   0.000202     call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
    8   0.000082   0.000053     if s:search.line.length() > 0
                                    " Error occur when '\zs' without '!'
    8   0.000249   0.000133         silent! call EasyMotion#highlight#add_highlight(a:re, g:EasyMotion_hl_inc_search)
    8              0.000012     endif

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:279
Called 541 times
Total time:   0.024697
 Self time:   0.017941

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
  541              0.009221   let g:airline#visual_active = (mode() =~? '[vs]')
  541   0.014113   0.007357   call airline#update_tabline()

FUNCTION  629()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 3 times
Total time:   0.000245
 Self time:   0.000121

count  total (s)   self (s)
    3              0.000015     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
    3              0.000003     endif
    3   0.000176   0.000052     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000011     if bufnum == bufnr('%')
    3              0.000016       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000003     endif
    3              0.000005     return group

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:186
Called 5652 times
Total time:   0.154410
 Self time:   0.154410

count  total (s)   self (s)
 5652              0.036327     let l:full_name = 'ale_' . a:variable_name
 5652              0.062035     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
 5652              0.047540     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>240_split_by_keys()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:137
Called 31 times
Total time:   0.001737
 Self time:   0.000693

count  total (s)   self (s)
   31   0.001714   0.000670 	return s:_split_keystring(a:str, "\\%(\<Plug>\\|<Over>\\)(.\\{-})\\zs\\|")

FUNCTION  310()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:115
Called 14 times
Total time:   0.000565
 Self time:   0.000107

count  total (s)   self (s)
   14   0.000559   0.000101 	return self.line.set_pos(a:pos)

FUNCTION  312()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:125
Called 15 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   15              0.000054 	if self.variables.tap_key == a:key
                            		let self.variables.tap_key = ""
                            		return 1
   15              0.000021 	endif

FUNCTION  313()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:133
Called 702 times
Total time:   0.002298
 Self time:   0.002298

count  total (s)   self (s)
  702              0.002056 	return self.variables.tap_key

FUNCTION  314()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:138
Called 687 times
Total time:   0.016887
 Self time:   0.012665

count  total (s)   self (s)
  687              0.003567 	let prekey = get(a:, 1, "")
  687   0.012924   0.008702 	return self.get_tap_key() ==# prekey		&& self.char() ==# a:key
                            " \		&& self.char() == (prekey . a:key)

FUNCTION  317()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:156
Called 31 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
   31              0.000099 	return self.variables.prompt

FUNCTION  riv#list#get_all_list()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/list.vim:176
Called 3 times
Total time:   0.000703
 Self time:   0.000061

count  total (s)   self (s)
    3   0.000701   0.000059     return s:get_all_list(a:row)

FUNCTION  <SNR>135_ClearOtherEvents()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/autocmd.vim:9
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000007   for augroup in s:registered
    1              0.000005     if augroup != a:group && exists('#'.augroup)
                                  execute 'autocmd!' augroup
    1              0.000002     endif
    2              0.000005   endfor

FUNCTION  454()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:57
Called 21 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   21              0.000107 	return keys(self.variables.hl_list)

FUNCTION  riv#insert#fixed_sft()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/insert.vim:120
Called 6 times
Total time:   0.004851
 Self time:   0.000104

count  total (s)   self (s)
    6   0.004845   0.000098     return riv#insert#fixed_col(a:row, a:col, a:sft) - a:col

FUNCTION  <SNR>260_get_cmdline()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:92
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000017 	if !exists("s:cmdline")
                            		execute s:E.throw_cmd("Undefined cmdline object.", "Over.Commandline.Modules.Doautocmd")
    3              0.000006 	endif
    3              0.000007 	return s:cmdline

FUNCTION  <SNR>194_should_use_regexp()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:643
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000011     return g:EasyMotion_use_regexp == 1 && s:flag.regexp == 1

FUNCTION  vital#_incsearch#Palette#Keymapping#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:7
Called 1 time
Total time:   0.000190
 Self time:   0.000135

count  total (s)   self (s)
    1   0.000189   0.000134 return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>266_' . v:key)")

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:166
Called 24 times
Total time:   0.005090
 Self time:   0.001049

count  total (s)   self (s)
   24   0.002567   0.000653   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
   24   0.002493   0.000366   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  vital#_incsearch#Vim#Guard#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Guard.vim:7
Called 1 time
Total time:   0.000084
 Self time:   0.000060

count  total (s)   self (s)
    1   0.000083   0.000059 return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>278_' . v:key)")

FUNCTION  <SNR>134_PrependFpath()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:29
Called 1 time
Total time:   0.000046
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000006   if exists('t:vista.source.fpath')
    1   0.000020   0.000009     let width = winwidth(t:vista.winnr())
    1              0.000003     let fpath = t:vista.source.fpath
                                " Shorten the file path if it's too long
    1              0.000004     if len(fpath) > width
                                  let fpath = '..'.fpath[len(fpath)-width+4 : ]
    1              0.000001     endif
    1              0.000005     return [fpath, ''] + a:lines
                              endif
                            
                              return a:lines

FUNCTION  vista#popup#Close()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/popup.vim:105
Called 2 times
Total time:   0.000094
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000093   0.000043   call s:ClosePopup()

FUNCTION  <SNR>132_WrapCmd()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:188
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000023       return split(&shell) + split(&shellcmdflag) + [a:cmd]

FUNCTION  <SNR>95_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 6 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
    6              0.000074   if !exists('w:airline_section_{a:name}')
    6              0.000070     let w:airline_section_{a:name} = g:airline_section_{a:name}
    6              0.000012   endif

FUNCTION  320()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:171
Called 15 times
Total time:   0.000792
 Self time:   0.000334

count  total (s)   self (s)
   15              0.000036 	if a:0
                            		call self.line.set(a:1)
   15              0.000022 	endif
   15   0.000599   0.000141 	call self.line.input(a:word)

FUNCTION  321()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:178
Called 14 times
Total time:   0.000224
 Self time:   0.000112

count  total (s)   self (s)
   14   0.000216   0.000104 	return self.line.forward()

FUNCTION  324()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:193
Called 36 times
Total time:   0.015262
 Self time:   0.010667

count  total (s)   self (s)
   36              0.000220 	if type(a:module) == type("")
    9   0.009288   0.000167 		return call(self.connect, [s:Module.make(a:module)] + a:000, self)
   27              0.000037 	endif
   27              0.000088 	if empty(a:module)
                            		return
   27              0.000032 	endif
   27              0.000135 	let name = a:0 > 0 ? a:1 : a:module.name
   27   0.002560   0.000466 	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(name))
   27              0.000089 	if empty(slot)
   27   0.001037   0.000413 		call self.variables.modules.connect({ "name" : name, "module" : a:module })
                            	else
                            		let slot.slot.module = a:module
   27              0.000035 	endif
                            " 	let self.variables.modules[name] = a:module

FUNCTION  325()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:211
Called 3 times
Total time:   0.000439
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000439   0.000041 	return self.variables.modules.disconnect_by(		"get(v:val.slot, 'name', '') == " . string(a:name)	)
                            " 	unlet self.variables.modules[a:name]

FUNCTION  326()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:219
Called 6 times
Total time:   0.001012
 Self time:   0.000147

count  total (s)   self (s)
    6   0.000960   0.000095 	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(a:name))
    6              0.000047 	return empty(slot) ? {} : slot.slot.module

FUNCTION  327()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:225
Called 84 times
Total time:   1.410908
 Self time:   0.002975

count  total (s)   self (s)
   84   0.097851   0.001353 	call self.variables.modules.sort_by("has_key(v:val.slot.module, 'priority') ? v:val.slot.module.priority('" . a:event . "') : 0")
   84   1.312942   0.001507 	return self.variables.modules.call(a:event, [self])
                            " 	call map(filter(copy(self.variables.modules), "has_key(v:val, a:event)"), "v:val." . a:event . "(self)")

FUNCTION  <SNR>156_ClearAugroups()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:107
Called 1 time
Total time:   0.000571
 Self time:   0.000571

count  total (s)   self (s)
    3              0.000015   for aug in a:000
    2              0.000021     if exists('#'.aug)
    1              0.000501       execute 'autocmd!' aug
    2              0.000007     endif
    3              0.000006   endfor

FUNCTION  riv#create#auto_mkdir()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/create.vim:363
Called 51 times
Total time:   0.002545
 Self time:   0.002545

count  total (s)   self (s)
   51              0.001415     let dir = expand('%:p:h')
   51              0.000457     if !isdirectory(dir)
                                    call mkdir(dir,'p')
   51              0.000302     endif

FUNCTION  <SNR>136_OnVimLeave()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:556
Called 1 time
Total time:   0.010746
 Self time:   0.010746

count  total (s)   self (s)
                              " Workaround a NeoVim issue - not shutting down timers correctly
                              " https://github.com/neovim/neovim/issues/6840
    6              0.000028   for poller in values( s:pollers )
    5              0.000031     call timer_stop( poller.id )
    6              0.000012   endfor
    1              0.010665   exec s:python_command "ycm_state.OnVimLeave()"

FUNCTION  vista#util#Join()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:101
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000010   return join(a:000, '')

FUNCTION  signature#sign#ToggleDummy()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/sign.vim:198
Called 15 times
Total time:   0.001019
 Self time:   0.001019

count  total (s)   self (s)
                              " Description: Places a dummy sign to prevent flickering of the gutter when the mark is moved or the line containing
                              "              a mark/marker is deleted and then the delete is undone
                              " Arguments: (optional) 0 : force remove
                              "                       1 : force place
                            
   15              0.000232   let l:place  = a:0 ?  a:1 : (len(b:sig_marks) + len(b:sig_markers) == 1) && !b:sig_DummyExists
   15              0.000221   let l:remove = a:0 ? !a:1 : (len(b:sig_marks) + len(b:sig_markers) == 0) &&  b:sig_DummyExists
                            
   15              0.000046   if (l:place)
                                sign define Signature_Dummy
                                execute 'sign place 666 line=1 name=Signature_Dummy buffer=' . bufnr('%')
                                let b:sig_DummyExists = 1
   15              0.000052   elseif (l:remove)
                                silent! execute 'sign unplace 666 buffer=' . bufnr('%')
                                let b:sig_DummyExists = 0
   15              0.000026   endif

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:156
Called 543 times
Total time:   0.072508
 Self time:   0.018861

count  total (s)   self (s)
  543   0.071951   0.018304   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>232_dictfunction()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:183
Called 15 times
Total time:   0.002051
 Self time:   0.001488

count  total (s)   self (s)
   15              0.000122   if has('patch-7.4.1842')
   15              0.000086     let funcname = '_' . get(a:dictfunc, 'name')
                              else
                                let funcname = '_' . matchstr(string(a:dictfunc), '\d\+')
   15              0.000019   endif
   15              0.000174   let s:funcmanage[funcname] = {   'func': a:dictfunc,   'dict': a:dict }
   15   0.000739   0.000176   let prefix = '<SNR>' . s:SID() . '_'
   15              0.000116   let fm = printf("%sfuncmanage()['%s']", prefix, funcname)
   15              0.000510   execute join([   printf('function! s:%s(...) abort', funcname),   printf("  return call(%s['func'], a:000, %s['dict'])", fm, fm),          'endfunction' ], "\n")
   15              0.000160   return function(printf('%s%s', prefix, funcname))

FUNCTION  <SNR>215_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:159
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  incsearch#_go()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:124
Called 3 times
Total time:   1.578281
 Self time:   0.000733

count  total (s)   self (s)
    3   0.000082   0.000052   if s:U.is_visual(a:config.mode) && !a:config.is_expr
                                normal! gv
    3              0.000005   endif
    3   0.067417   0.000272   let cli = incsearch#cli#make(a:config)
    3   1.429921   0.000068   let input = s:get_input(cli)
    3              0.000023   if cli._does_exit_from_incsearch
                                " Outer incsearch-plugin handle it so do not something in paticular
                                return cli._return_cmd
    3              0.000005   else
                                " After getting input, generate command, take aftercare, and return
                                " command.
    3              0.000036     let l:F = function(cli._flag is# 'n' ? 's:stay' : 's:search')
    3   0.013163   0.000055     let cmd = l:F(cli, input)
    3              0.000010     if !a:config.is_expr
    3              0.000015       let should_set_jumplist = (cli._flag !=# 'n')
    3   0.067526   0.000114       call s:set_search_related_stuff(cli, cmd, should_set_jumplist)
    3              0.000012       if a:config.mode is# 'no'
                                    call s:set_vimrepeat(cmd)
    3              0.000004       endif
    3              0.000003     endif
    3              0.000008     return cmd
                              endif

FUNCTION  331()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:249
Called 14 times
Total time:   0.000200
 Self time:   0.000107

count  total (s)   self (s)
   14   0.000195   0.000102 	return self.__keymapping__()

FUNCTION  334()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:265
Called 14 times
Total time:   0.991932
 Self time:   0.000416

count  total (s)   self (s)
   14   0.964172   0.000149 	call self.callevent("on_draw_pre")
   14   0.027744   0.000251 	call self.callevent("on_draw")

FUNCTION  335()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:271
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000010 	let self.variables.exit = 1
    3              0.000015 	let self.variables.exit_code = get(a:, 1, 0)

FUNCTION  338()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:287
Called 28 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   28              0.000114 	return self.variables.enable_keymapping

FUNCTION  339()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:297
Called 12 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
   12              0.000043 	return self.variables.exit_code

FUNCTION  <SNR>231_silent_after_search()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:318
Called 3 times
Total time:   0.000333
 Self time:   0.000262

count  total (s)   self (s)
                              " :h function-search-undo
    3              0.000050   let m = get(a:, 1, mode(1))
    3              0.000010   if m !=# 'no' " guard for operator-mapping
    3   0.000234   0.000163     let cmd = join([   (s:U.is_visual(m) ? "\<Plug>(_incsearch-esc)" : ''),   "\<Plug>(_incsearch-hlsearch)",   "\<Plug>(_incsearch-searchforward)",   (s:U.is_visual(m) ? "\<Plug>(_incsearch-gv)" : '') ], '')
    3              0.000026     call feedkeys(cmd, 'm')
    3              0.000003   endif

FUNCTION  incsearch#autocmd#auto_nohlsearch()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/autocmd.vim:19
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                              " NOTE: see this value inside this function in order to toggle auto
                              " :nohlsearch feature easily with g:incsearch#autocmd#auto_nohlsearch option
    3              0.000018   if !g:incsearch#auto_nohlsearch | return '' | endif
                              return s:auto_nohlsearch(a:nest)

FUNCTION  372()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:78
Called 14 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   14              0.000053 	return len(self.list)

FUNCTION  AutoPairsDelete()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:303
Called 1068 times
Total time:   0.721639
 Self time:   0.623457

count  total (s)   self (s)
 1068              0.006732   if !b:autopairs_enabled
                                return "\<BS>"
 1068              0.002033   end
                            
 1068   0.122386   0.024204   let [before, after, ig] = s:getline()
10680              0.041955   for [open, close, opt] in b:AutoPairsList
 9612              0.153885     let b = matchstr(before, '\V'.open.'\v\s?$')
 9612              0.095011     let a = matchstr(after, '^\v\s*\V'.close)
 9612              0.027219     if b != '' && a != ''
                                  if b[-1:-1] == ' '
                                    if a[0] == ' '
                                      return "\<BS>\<DELETE>"
                                    else
                                      return "\<BS>"
                                    end
                                  end
                                  return s:backspace(b).s:delete(a)
 9612              0.016481     end
10680              0.018453   endfor
                            
 1068              0.005289   return "\<BS>"
                              " delete the pair foo[]| <BS> to foo
                              for [open, close, opt] in b:AutoPairsList
                                let m = s:matchend(before, '\V'.open.'\v\s*'.'\V'.close.'\v$')
                                if len(m) > 0
                                  return s:backspace(m[2])
                                end
                              endfor
                              return "\<BS>"

FUNCTION  vital#_easymotion#Over#Commandline#Modules#ExceptionExit#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionExit.vim:5
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000012     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>227_is_cmdwin()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Buffer.vim:30
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005     return getcmdwintype() !=# ''

FUNCTION  <SNR>132_Dispatch()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:346
Called 1 time
Total time:   0.002006
 Self time:   0.000124

count  total (s)   self (s)
    1   0.000029   0.000014   let custom_cmd = s:GetCustomCmd(&filetype)
                            
    1              0.000006   let exe = custom_cmd isnot v:null ? split(custom_cmd)[0] : 'ctags'
                            
    1              0.000025   if !executable(exe)
                                call vista#error#Need(exe)
                                return
    1              0.000001   endif
                            
    1   0.000082   0.000031   call vista#SetProvider(s:provider)
    1   0.001849   0.000033   return call(function(a:F), a:000)

FUNCTION  <SNR>265_make_vim_cmdline_mapping()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:142
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return deepcopy(s:vim_cmdline_mapping)

FUNCTION  <SNR>129_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:239
Called 24 times
Total time:   0.039184
 Self time:   0.004479

count  total (s)   self (s)
   24              0.000129   let modifications = []
   24              0.000124   let from_line  = a:hunk[0]
   24              0.000108   let from_count = a:hunk[1]
   24              0.000093   let to_line    = a:hunk[2]
   24              0.000090   let to_count   = a:hunk[3]
                            
   24   0.000516   0.000356   if s:is_added(from_count, to_count)
   24   0.031654   0.000511     call s:process_added(modifications, from_count, to_count, to_line)
   24   0.004170   0.000768     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   24              0.000037   endif
   24              0.000090   return modifications

FUNCTION  340()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:302
Called 3 times
Total time:   0.000267
 Self time:   0.000248

count  total (s)   self (s)
    3              0.000021 	if exists("self.variables.old_guicursor")
    3   0.000071   0.000065 		set guicursor&
    3   0.000052   0.000049 		let &guicursor = self.variables.old_guicursor
    3              0.000011 		unlet self.variables.old_guicursor
    3              0.000005 	endif
                            
    3              0.000018 	if exists("self.variables.old_t_ve")
    3   0.000067   0.000057 		let &t_ve = self.variables.old_t_ve
    3              0.000010 		unlet self.variables.old_t_ve
    3              0.000004 	endif

FUNCTION  341()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:316
Called 3 times
Total time:   0.000306
 Self time:   0.000285

count  total (s)   self (s)
    3              0.000019 	if exists("self.variables.old_t_ve")
                            		return
    3              0.000003 	endif
                            
    3              0.000013 	let self.variables.old_guicursor = &guicursor
    3   0.000167   0.000154 	set guicursor=n:block-NONE
    3              0.000019 	let self.variables.old_t_ve = &t_ve
    3   0.000067   0.000059 	set t_ve=

FUNCTION  342()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:328
Called 3 times
Total time:   1.429339
 Self time:   0.000049

count  total (s)   self (s)
    3   1.429328   0.000038 	let exit_code = call(self.__main, a:000, self)
    3              0.000007 	return exit_code

FUNCTION  344()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:338
Called 3 times
Total time:   1.429629
 Self time:   0.000242

count  total (s)   self (s)
    3              0.000096 	let Old_execute = self.execute
    3              0.000013 	let self.execute = self.__empty
    3              0.000004 	try
    3   1.429382   0.000043 		let exit_code = call(self.start, a:000, self)
    3              0.000009 		if exit_code == 0
    3   0.000075   0.000027 			return self.getline()
                            		endif
    3              0.000008 	finally
    3              0.000014 		let self.execute = Old_execute
    3              0.000006 	endtry
                            	return ""

FUNCTION  346()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:358
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000016 	return join(self.variables.input_key_stack, "")

FUNCTION  347()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:363
Called 15 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   15              0.000089 	let self.variables.input_key_stack = a:stack
   15              0.000038 	return self.variables.input_key_stack

FUNCTION  348()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:369
Called 15 times
Total time:   0.000179
 Self time:   0.000136

count  total (s)   self (s)
   15   0.000174   0.000131 	return remove(self.input_key_stack(), 0)

FUNCTION  vista#cursor#FoldOrJump()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:381
Called 1 time
Total time:   0.012722
 Self time:   0.001584

count  total (s)   self (s)
    1              0.000012   if line('.') == 1
                                call vista#source#GotoWin()
                                return
    1              0.000002   endif
                            
                              " Fold or unfold when meets the top level tag line
    1              0.000005   if indent('.') == 0
                                if !empty(getline('.'))
                                  if foldclosed('.') != -1
                                    normal! zo
                                  else
                                    if foldlevel('.') != 0
                                      normal! zc
                                    endif
                                  endif
                                endif
                                return
    1              0.000001   endif
                            
    1   0.000208   0.000023   let tag_under_cursor = s:GetInfoUnderCursor()[0]
    1   0.012461   0.001508   call vista#jump#TagLine(tag_under_cursor)

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:204
Called 24 times
Total time:   0.003905
 Self time:   0.001826

count  total (s)   self (s)
   24              0.000085   let hunks = []
   48              0.000426   for line in split(a:diff, '\n')
   24   0.002544   0.000465     let hunk_info = gitgutter#diff#parse_hunk(line)
   24              0.000098     if len(hunk_info) == 4
   24              0.000186       call add(hunks, hunk_info)
   24              0.000042     endif
   48              0.000083   endfor
   24              0.000073   return hunks

FUNCTION  vital#_incsearch#Over#Commandline#Modules#InsertRegister#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/InsertRegister.vim:7
Called 1 time
Total time:   0.000128
 Self time:   0.000090

count  total (s)   self (s)
    1   0.000127   0.000089 return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>258_' . v:key)")

FUNCTION  <SNR>139_StopCursorTimer()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:32
Called 2 times
Total time:   0.000217
 Self time:   0.000107

count  total (s)   self (s)
    2   0.000213   0.000103   call s:GenericStopTimer('s:cursor_timer')

FUNCTION  201()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:37
Called 8 times
Total time:   0.000445
 Self time:   0.000445

count  total (s)   self (s)
    8              0.000435 	return {		"\<C-f>" : {			"key" : "\<Right>",			"noremap" : 1,			"lock" : 1,		},		"\<C-b>" : {			"key" : "\<Left>",			"noremap" : 1,			"lock" : 1,		},		"\<C-n>" : {			"key" : "\<Down>",			"noremap" : 1,			"lock" : 1,		},		"\<C-p>" : {			"key" : "\<Up>",			"noremap" : 1,			"lock" : 1,		},		"\<C-a>" : {			"key" : "\<Home>",			"noremap" : 1,			"lock" : 1,		},		"\<C-e>" : {			"key" : "\<End>",			"noremap" : 1,			"lock" : 1,		},		"\<C-d>" : {			"key" : "\<Del>",			"noremap" : 1,			"lock" : 1,		},		"\<A-d>" : {			"key" : "\<C-w>",			"noremap" : 1,			"lock" : 1,		},		"\<A-b>" : {			"key" : "\<S-Left>",			"noremap" : 1,			"lock" : 1,		},		"\<A-f>" : {			"key" : "\<S-Right>",			"noremap" : 1,			"lock" : 1,		},	}

FUNCTION  incsearch#go()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:100
Called 3 times
Total time:   0.001913
 Self time:   0.000458

count  total (s)   self (s)
    3   0.001762   0.000338   let config = incsearch#config#make(get(a:, 1, {}))
                              " FIXME?: this condition should not be config.is_expr?
    3              0.000006   if config.is_expr
                                return incsearch#_go(config)
    3              0.000003   else
    3              0.000018     let g:incsearch#_go_config = config
    3   0.000082   0.000051     let esc = s:U.is_visual(g:incsearch#_go_config.mode) ? "\<ESC>" : ''
    3              0.000025     return printf("%s:\<C-u>call incsearch#_go(g:incsearch#_go_config)\<CR>", esc)
                              endif

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:350
Called 50 times
Total time:   0.005977
 Self time:   0.005977

count  total (s)   self (s)
   50              0.000232     let l:command_list = []
   50              0.000222     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
   50              0.000355     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
                                    let l:is_dummy_sign_set = 1
   50              0.000098     endif
                            
                                " Place new items first.
   50              0.000254     for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
                                    endif
   50              0.000087     endfor
                            
                                " Remove signs without new IDs.
   50              0.000363     for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
                                        endif
                                    endfor
   50              0.000077     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
   50              0.000198     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
   50              0.000060     endif
                            
   50              0.000193     return l:command_list

FUNCTION  vista#util#ToCamelCase()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:106
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000017   return substitute(a:s, '\(^\l\+\)\|_\(\l\+\)', '\u\1\2', 'g')

FUNCTION  <SNR>231__execute_search()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:454
Called 21 times
Total time:   0.007342
 Self time:   0.007342

count  total (s)   self (s)
                              " :nohlsearch
                              "   Please do not highlight at the first place if you set back
                              "   info! I'll handle it myself :h function-search-undo
   20              0.006599   execute s:keeppattern 'keepjumps' 'normal!' a:cmd | nohlsearch

FUNCTION  <SNR>157_StartWith()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:117
Called 20 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
   20              0.000134   return a:candidate_scope[:len(a:root_scope)] == a:root_scope

FUNCTION  351()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:410
Called 3 times
Total time:   0.000884
 Self time:   0.000183

count  total (s)   self (s)
    3   0.000415   0.000020 	call self.__init_variables()
    3   0.000336   0.000030 	call self.hl_cursor_off()
    3              0.000015 	if !hlexists(self.highlights.cursor)
                            		if s:_is_valid_highlight("Cursor")
                            			execute "highlight link " . self.highlights.cursor . " Cursor"
                            		else
                            			" Workaround by CUI Vim Cursor Highlight
                            			" issues #92
                            			" https://github.com/osyo-manga/vital-over/issues/92
                            			execute "highlight " . self.highlights.cursor . " term=reverse cterm=reverse gui=reverse"
                            		endif
    3              0.000005 	endif
    3              0.000013 	if !hlexists(self.highlights.cursor_on)
                            		execute "highlight link " . self.highlights.cursor_on . " " . self.highlights.cursor
    3              0.000003 	endif
    3              0.000011 	if !hlexists(self.highlights.cursor_insert)
                            		execute "highlight " . self.highlights.cursor_insert . " cterm=underline term=underline gui=underline"
    3              0.000003 	endif

FUNCTION  354()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:452
Called 15 times
Total time:   0.155835
 Self time:   0.000928

count  total (s)   self (s)
   15              0.000046 	let char = a:char
   15              0.000051 	let self.variables.input_key = char
   15              0.000046 	let self.variables.char = char
   15   0.000393   0.000109 	call self.setchar(self.variables.char)
   15              0.000039 	let self.variables.is_setted = 0
   15   0.064974   0.000148 	call self.callevent("on_char_pre")
   15   0.001055   0.000263 	call self.insert(self.variables.input)
   15   0.089197   0.000192 	call self.callevent("on_char")

FUNCTION  355()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:464
Called 17 times
Total time:   0.163452
 Self time:   0.002062

count  total (s)   self (s)
   17              0.000059 	if a:input == ""
    3              0.000005 		return
   14              0.000019 	endif
                            
   14              0.000057 	let self.variables.input_key = a:input
   14              0.000031 	if a:0 == 0
                            		let keymapping = self.__get_keymapping()
   14              0.000018 	else
   14              0.000040 		let keymapping = a:1
   14              0.000018 	endif
   14   0.000159   0.000116 	if self.is_enable_keymapping()
   14   0.004389   0.000225 		let key = s:Keymapping.unmapping(keymapping, a:input)
                            	else
                            		let key = a:input
   14              0.000019 	endif
   14              0.000033 	if key == ""
                            		return
   14              0.000021 	endif
                            
   14   0.001269   0.000311 	call self.set_input_key_stack(s:String.split_by_keys(key))
   29   0.000723   0.000512 	while !(empty(self.input_key_stack()) || self.is_exit())
   15   0.156204   0.000190 		call self.__input_char(self.input_key_stack_pop())
   29              0.000064 	endwhile

FUNCTION  356()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:497
Called 14 times
Total time:   0.179275
 Self time:   0.002143

count  total (s)   self (s)
   14   0.000233   0.000152 	if !self.is_enable_keymapping()
                            		return self.__input(s:Input.getchar())
   14              0.000024 	endif
                            
   14   0.001556   0.000285 	let input = s:Input.getchar()
   14   0.000392   0.000157 	let old_line = self.getline()
   14   0.000293   0.000144 	let old_pos  = self.getpos()
   14   0.009877   0.000129 	let keymapping = self.__get_keymapping()
   14              0.000023 	try
   14              0.000057 		let t = reltime()
   14   0.001299   0.000327 		while s:is_input_waiting(keymapping, input)		&& str2nr(reltimestr(reltime(t))) * 1000 < &timeoutlen
                            			call self.setline(old_line)
                            			call self.insert(input)
                            			call self.setpos(old_pos)
                            			call self.draw()
                            			let input .= s:Input.getchar(0)
   14              0.000030 		endwhile
   14              0.000026 	finally
   14   0.000808   0.000127 		call self.setline(old_line)
   14   0.000682   0.000117 		call self.setpos(old_pos)
   14              0.000023 	endtry
   14   0.163592   0.000162 	call self.__input(input, keymapping)

FUNCTION  357()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:524
Called 14 times
Total time:   0.981787
 Self time:   0.000812

count  total (s)   self (s)
                            " 	call self.callevent("on_update")
                            " 	if !getchar(1)
                            " 		continue
                            " 	endif
                            "
                            " 	call self.__input(s:getchar(0))
                            " 	call self.draw()
                            
   14   0.025502   0.000140 	call self.callevent("on_update")
   14   0.179546   0.000271 	call self.__inputting()
                            " 	call self.__input(s:Input.getchar())
   14   0.000211   0.000153 	if self.is_exit()
    3              0.000007 		return -1
   11              0.000017 	endif
   11   0.776401   0.000121 	call self.draw()

FUNCTION  358()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:543
Called 3 times
Total time:   1.429290
 Self time:   0.000823

count  total (s)   self (s)
    3              0.000004 	try
    3   0.000904   0.000020 		call self.__init()
    3   0.019274   0.000044 		call self.callevent("on_enter")
                            
    3   0.000056   0.000034 		call self.__input(get(a:, 1, ""))
    3   0.215671   0.000019 		call self.draw()
   14   0.000245   0.000175 		while !self.is_exit()
   14              0.000027 			try
   14   0.981905   0.000118 				if self.__update()
    3              0.000008 					break
   11              0.000017 				endif
                            			catch
                            				call self.callevent("on_exception")
   14              0.000031 			endtry
   14              0.000026 		endwhile
                            	catch
                            		echohl ErrorMsg | echom v:throwpoint . " " . v:exception | echohl None
                            		let self.variables.exit_code = -1
    3              0.000005 	finally
    3   0.000318   0.000027 		call self.__finish()
    3   0.210563   0.000043 		call self.callevent("on_leave")
    3              0.000006 	endtry
    3   0.000048   0.000037 	return self.exit_code()

FUNCTION  359()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:570
Called 3 times
Total time:   0.000291
 Self time:   0.000024

count  total (s)   self (s)
    3   0.000289   0.000022 	call self.hl_cursor_on()

FUNCTION  <SNR>129_process_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:292
Called 24 times
Total time:   0.031143
 Self time:   0.031143

count  total (s)   self (s)
   24              0.000091   let offset = 0
  939              0.003017   while offset < a:to_count
  915              0.005433     let line_number = a:to_line + offset
  915              0.017753     call add(a:modifications, [line_number, 'added'])
  915              0.002495     let offset += 1
  939              0.001664   endwhile

FUNCTION  vital#_incsearch#Coaster#Highlight#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:7
Called 1 time
Total time:   0.000519
 Self time:   0.000337

count  total (s)   self (s)
    1   0.000518   0.000336 return map({'highlight': '', 'clear': '', 'delete': '', 'add': '', 'as_windo': '', '_vital_depends': '', 'get_hl_id': '', 'to_list': '', 'clear_all': '', 'delete_all': '', 'to_list_by': '', 'update': '', 'enable': '', 'delete_by': '', 'hl_list': '', 'make': '', 'enable_list': '', 'update_all': '', 'disable': '', 'disable_all': '', 'is_enabled': '', 'enable_all': '', 'is_added': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>275_' . v:key)")

FUNCTION  <SNR>283_make_uniq_nr()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Window.vim:46
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004 	let s:uniq_counter += 1
    1              0.000003 	return s:uniq_counter

FUNCTION  <SNR>36_ulen()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:119
Called 24 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
   24              0.000343   return len(split(a:s, '\zs'))

FUNCTION  <SNR>244_match_key()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim:42
Called 23 times
Total time:   0.001367
 Self time:   0.001367

count  total (s)   self (s)
   23              0.000252 	let keys = sort(keys(a:keymapping))
   23              0.001093 	return get(filter(keys, 'stridx(a:key, v:val) == 0'), -1, '')

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:238
Called 106 times
Total time:   0.005977
 Self time:   0.003042

count  total (s)   self (s)
  106              0.000810   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
  106   0.004800   0.001865     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
  106              0.000169   endif

FUNCTION  riv#show_menu()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv.vim:111
Called 6 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
    6              0.000052     sil! menu disable Riv.*
    6              0.000067     if &ft != 'rst'
    3              0.000011         sil! menu enable Riv.Project
    3              0.000009         sil! menu enable Riv.Project.*
    3              0.000009         sil! menu enable Riv.Scratch
    3              0.000008         sil! menu enable Riv.Scratch.*
    3              0.000009         sil! menu enable Riv.Helper
    3              0.000011         sil! menu enable Riv.Helper.*
    3              0.000009         sil! menu enable Riv.About
    3              0.000015         sil! menu enable Riv.About.*
    3              0.000004     else
    3              0.000009         sil! menu enable Riv.*
    6              0.000007     endif

FUNCTION  <SNR>241_sort()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/List.vim:99
Called 84 times
Total time:   0.071767
 Self time:   0.038569

count  total (s)   self (s)
   84              0.000943   if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
   84              0.000163   endif
   84              0.000330   let s:expr = a:expr
   84   0.069854   0.036656   return sort(a:list, 's:_compare')

FUNCTION  442()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:83
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000010   return g:incsearch#emacs_like_keymap

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:119
Called 34552 times
Total time:   3.622529
 Self time:   0.704641

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
34552   3.579936   0.662048     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>35_HighlightEOLWhitespace()
    Defined: ~/.vim/plugged/vim-better-whitespace/plugin/better-whitespace.vim:163
Called 434 times
Total time:   0.072262
 Self time:   0.047877

count  total (s)   self (s)
  434   0.019012   0.012933         call <SID>ClearHighlighting()
  434   0.026333   0.008027         if <SID>ShouldHighlight()
  434              0.025040             let s:match_id = matchadd('ExtraWhitespace', s:eol_whitespace_pattern, 10, get(s:, 'match_id', -1))
  434              0.001040         endif

FUNCTION  457()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:81
Called 21 times
Total time:   0.001775
 Self time:   0.000560

count  total (s)   self (s)
   21   0.001594   0.000379 	let window = get(a:, 1, s:Gift.uniq_winnr())
   21              0.000164 	return keys(get(self.variables.id_list, window, {}))

FUNCTION  415()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/insert_register.vim:20
Called 15 times
Total time:   0.002602
 Self time:   0.000750

count  total (s)   self (s)
   15              0.000099   if exists('self.prefix_key') && a:cmdline.get_tap_key() == self.prefix_key
                                call a:cmdline.setline(self.old_line)
                                call a:cmdline.setpos(self.old_pos)
                                let char = a:cmdline.input_key()
                                if char ==# '/'
                                  let register = tr(self.search_register, "\n", "\r")
                                  call a:cmdline.setchar(register)
                                  return
                                endif
   15              0.000021   endif
   15   0.002034   0.000182   return call(s:InsertRegister_orig_on_char_pre, [a:cmdline], self)

FUNCTION  361()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:580
Called 43 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
   43              0.000164 	return self.variables.exit

FUNCTION  362()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:585
Called 14 times
Total time:   0.009748
 Self time:   0.006374

count  total (s)   self (s)
   14              0.000046 	let result = {}
                            " 	for module in values(self.variables.modules)
  336   0.003825   0.000725 	for module in self.variables.modules.slots()
  322              0.001347 		if has_key(module, "keymapping")
   28              0.000069 			if module isnot self
   14   0.000311   0.000237 				call extend(result, module.keymapping(self))
   28              0.000038 			endif
  322              0.000393 		endif
  336              0.000575 	endfor
   14   0.000453   0.000253 	return extend(extend(result, self.variables.keymapping), self.keymapping())

FUNCTION  363()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:35
Called 17 times
Total time:   0.000649
 Self time:   0.000275

count  total (s)   self (s)
   17   0.000638   0.000264 	return type(a:item) == type("") ? self.set_str(a:item)		 : type(a:item) == type(0)  ? self.set_pos(a:item)		 : self

FUNCTION  366()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:50
Called 14 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   14              0.000141 	return self.col > 0 ? join(self.list[ : self.col-1], '') : ""

FUNCTION  367()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:54
Called 14 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   14              0.000103 	return join(self.list[self.col+1 : ], '')

FUNCTION  368()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:58
Called 28 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   28              0.000129 	return get(self.list, self.col, "")

FUNCTION  369()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:62
Called 17 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
   17              0.000247 	let self.list = split(a:str, '\zs')
   17              0.000081 	let self.col  = strchars(a:str)
   17              0.000036 	return self

FUNCTION  418()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 3 times
Total time:   0.000393
 Self time:   0.000064

count  total (s)   self (s)
    3              0.000013 	let s:cmdline = a:cmdline
    3   0.000378   0.000049 	call s:doautocmd_user(self.prefix, self.prefix . 'Leave')

FUNCTION  419()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 15 times
Total time:   0.002074
 Self time:   0.000348

count  total (s)   self (s)
   15              0.000060 	let s:cmdline = a:cmdline
   15   0.002004   0.000278 	call s:doautocmd_user(self.prefix, self.prefix . 'Char')

FUNCTION  incsearch#cli()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:71
Called 3 times
Total time:   0.000186
 Self time:   0.000053

count  total (s)   self (s)
    3   0.000182   0.000049   return incsearch#cli#get()

FUNCTION  <SNR>38_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:74
Called 2179 times
Total time:   0.139540
 Self time:   0.081011

count  total (s)   self (s)
 2179              0.028567   if winnr() != s:active_winnr || !exists('w:airline_active')
    1   0.028025   0.000018     call s:on_window_changed('CursorMoved')
 2179              0.003816   endif
 2179   0.064022   0.033500   call airline#update_tabline()

FUNCTION  riv#ptn#link_all()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:714
Called 1470 times
Total time:   0.112491
 Self time:   0.028894

count  total (s)   self (s)
                                " >>> echo riv#ptn#link_all()
 1470   0.110717   0.027120     return g:_riv_p['link_all'.riv#path#file_link_style()]

FUNCTION  <SNR>105_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:177
Called 17052 times
Total time:   3.706025
 Self time:   2.959467

count  total (s)   self (s)
17052              0.318888   let file = expand("%:p")
17052              0.200611   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
17052              0.026166   endif
                            
17052              0.056809   let needs_update = 1
17052              0.172008   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
51156              0.188051   for vcs in keys(s:vcs_config)
34104              0.293570     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
34104              0.050943     endif
34104              0.208928     if has_key(s:vcs_config[vcs].untracked, file)
16965              0.057121       let needs_update = 0
16965   0.937890   0.444903       call airline#extensions#branch#update_untracked_config(file, vcs)
34104              0.050178     endif
51156              0.089004   endfor
                            
17052              0.044116   if !needs_update
16965              0.031651     return
   87              0.000114   endif
                            
  261              0.002038   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
  174   0.003352   0.001937     if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
  174   0.006077   0.003492     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
   87              0.000170       continue
   87              0.000107     endif
   87              0.000422     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
   87              0.000474     if index(vcs_checks, 'untracked') > -1
   87   0.125439   0.004115       call airline#async#vcs_untracked(config, file, vcs)
   87              0.000324     endif
                                " Check clean state of repo
   87              0.000984     if index(vcs_checks, 'dirty') > -1
   87   0.136944   0.008697       call airline#async#vcs_clean(config.dirty, file, vcs)
   87              0.000680     endif
  174              0.003296   endfor

FUNCTION  EasyMotion#helper#is_folded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:68
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                                " Return false if g:EasyMotion_skipfoldedline == 1
                                " and line is start of folded lines
    3              0.000018     let _foldclosed = foldclosed(a:line)
    3              0.000016     return _foldclosed != -1 && (g:EasyMotion_skipfoldedline == 1 || a:line != _foldclosed)

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:252
Called 17107 times
Total time:   0.264072
 Self time:   0.264072

count  total (s)   self (s)
17107              0.107847   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
17107              0.026798   else
17107              0.048355     return a:path
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:100
Called 35126 times
Total time:   0.877508
 Self time:   0.877508

count  total (s)   self (s)
35126              0.308871     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
35126              0.510108     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 17059 times
Total time:   1.792353
 Self time:   1.654387

count  total (s)   self (s)
17059              0.119239   if !exists('b:fugitive_name')
    1              0.000004     let b:fugitive_name = ''
    1              0.000003     try
    1              0.000026       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    1              0.000037       elseif exists('b:git_dir') && exists('*fugitive#repo')
    1              0.000207         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    1              0.000004         endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    1              0.000002       endif
                                catch
    1              0.000019     endtry
17059              0.025801   endif
                            
17059   0.413359   0.275393   let fmod = s:ModifierFlags()
17059              0.078830   if empty(b:fugitive_name)
17059              0.254161     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  vital#_incsearch#Palette#Highlight#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Highlight.vim:7
Called 1 time
Total time:   0.000188
 Self time:   0.000134

count  total (s)   self (s)
    1   0.000187   0.000133 return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>246_' . v:key)")

FUNCTION  370()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:68
Called 14 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
   14              0.000032 	return self.col

FUNCTION  371()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:72
Called 15 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
   15              0.000257 	call extend(self.list, split(a:str, '\zs'), self.col)
   15              0.000148 	let self.col += len(split(a:str, '\zs'))
   15              0.000036 	return self

FUNCTION  vista#util#MaxLen()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:5
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000008   let l:maxlen = &columns * &cmdheight - 2
    1              0.000006   let l:maxlen = &showcmd ? l:maxlen - 11 : l:maxlen
    1              0.000006   let l:maxlen = &ruler ? l:maxlen - 18 : l:maxlen
    1              0.000003   return l:maxlen

FUNCTION  vista#ShouldIgnore()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:24
Called 11 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
   11              0.000081   return exists('g:vista_ignore_kinds') && index(g:vista_ignore_kinds, a:kind) != -1

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:73
Called 34552 times
Total time:  11.687624
 Self time:   5.691740

count  total (s)   self (s)
34552              0.258812   if !exists(':ALELint')
                                return ''
34552              0.054525   endif
                            
34552              0.277060   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
34552              0.273056   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
34552              0.268948   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
34552              0.265255   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
34552              0.146687   let is_err = a:type ==# 'error'
                            
34552   1.498544   0.639453   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
34552              0.055040   endif
                            
34552              0.169832   let symbol = is_err ? error_symbol : warning_symbol
                            
34552   4.193688   0.571159   let counts = ale#statusline#Count(bufnr(''))
34552              0.285100   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
34552              0.194021     let errors = counts.error + counts.style_error
34552              0.180603     let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
34552              0.053171   endif
                            
34552              0.106833   if show_line_numbers == 1
34552   2.777765   1.263501     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  458()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:87
Called 57 times
Total time:   0.001340
 Self time:   0.000968

count  total (s)   self (s)
   57   0.000879   0.000507 	if !self.is_added(a:name)
    9              0.000020 		return -1
   48              0.000079 	endif
   48              0.000219 	unlet! self.variables.hl_list[a:name]

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:14
Called 24 times
Total time:   0.036205
 Self time:   0.034285

count  total (s)   self (s)
   24   0.002043   0.000376   call gitgutter#debug#log('[async] '.a:cmd)
                            
   24              0.000257   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   24   0.000637   0.000384   let command = s:build_command(a:cmd)
                            
   24              0.000170   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
   24              0.000035   else
   24              0.031972     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
   24              0.000233   endif

FUNCTION  <SNR>145_set_clean_variables()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:67
Called 50 times
Total time:   0.009160
 Self time:   0.009160

count  total (s)   self (s)
   50              0.002901   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
   50              0.003020   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
   50              0.000282     let var[a:vcs].dirty=a:val
   50              0.000105     try
   50              0.002086       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
   50              0.000297       unlet! b:airline_head
                                catch
   50              0.000113     endtry
   50              0.000074   endif

FUNCTION  <SNR>109_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:50
Called 50 times
Total time:   0.015140
 Self time:   0.015140

count  total (s)   self (s)
                              " Checks for git conflict markers
   50              0.000442   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
   50              0.000486   let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
   50              0.013974   return search(pattern, 'nw')

FUNCTION  <SNR>136_UpdateSignatureHelp()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:1011
Called 24467 times
Total time:  13.223997
 Self time:   1.326615

count  total (s)   self (s)
24467   6.940871   0.581092   if !s:ShouldUseSignatureHelp()
                                return
24467              0.049790   endif
                            
24467   6.104937   0.567334   call s:Pyeval( 'ycm_state.UpdateSignatureHelp( vim.eval( "s:signature_help" ) )' )

FUNCTION  vital#_easymotion#Over#Commandline#Modules#BufferComplete#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:5
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:11
Called 34159 times
Total time:   2.050829
 Self time:   1.824525

count  total (s)   self (s)
34159              0.239118   if !a:0 || type(a:1) == type(0) && a:1 < 0
17105              0.088412     if exists('g:fugitive_event')
                                  return g:fugitive_event
17105              0.026409     endif
17105              0.096949     let dir = get(b:, 'git_dir', '')
17105              0.120878     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
17105              0.024504     endif
17105              0.040064     return dir
17054              0.085570   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
17054              0.084764   elseif type(a:1) == type('')
17054   0.584677   0.358373     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  vital#_incsearch#Over#Commandline#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline.vim:7
Called 1 time
Total time:   0.000669
 Self time:   0.000516

count  total (s)   self (s)
    1   0.000668   0.000515 return map({'_vital_depends': '', 'make_standard_search_back': '', 'get_module': '', 'make_standard_search': '', 'make_standard': '', 'make_module': '', 'make_default': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>236_' . v:key)")

FUNCTION  <SNR>190_BuildSignMap()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:281
Called 50 times
Total time:   0.008212
 Self time:   0.006932

count  total (s)   self (s)
   50   0.001979   0.000699     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
   50              0.000146     if l:max_signs is 0
                                    let l:selected_grouped_items = []
   50              0.000356     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
   50              0.000071     else
   50              0.000336         let l:selected_grouped_items = a:grouped_items
   50              0.000067     endif
                            
   50              0.000149     let l:sign_map = {}
   50              0.000211     let l:sign_offset = g:ale_sign_offset
                            
   50              0.000212     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
   50              0.000136     endfor
                            
   50              0.000240     for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
   50              0.000121     endfor
                            
   50              0.000171     return l:sign_map

FUNCTION  incsearch#cli#set()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:31
Called 3 times
Total time:   0.000516
 Self time:   0.000497

count  total (s)   self (s)
    3              0.000038   let a:cli._base_key = a:config.command
    3              0.000101   let a:cli._vcount1 = max([1, a:config.count])
    3              0.000017   let a:cli._has_count = a:config.count > 0
    3              0.000011   let a:cli._is_expr = a:config.is_expr
    3              0.000012   let a:cli._mode = a:config.mode
    3              0.000017   let a:cli._pattern = a:config.pattern
    3              0.000015   let a:cli._prompt = a:config.prompt
    3              0.000015   let a:cli._keymap = a:config.keymap
    3              0.000012   let a:cli._converters = a:config.converters
    3              0.000057   let a:cli._flag = a:config.is_stay         ? 'n'               : a:config.command is# '/' ? ''               : a:config.command is# '?' ? 'b'               : ''
    3              0.000024   let a:cli._direction = (a:cli._base_key is# '/' ? s:DIRECTION.forward : s:DIRECTION.backward)
                              " TODO: provide config? but it may conflict with <expr> mapping
                              " NOTE: _w: default cursor view
    3              0.000027   let a:cli._w = winsaveview()
    3              0.000013   for module in a:config.modules
                                call a:cli.connect(module)
    3              0.000007   endfor
    3   0.000057   0.000038   call a:cli.set_prompt(a:cli._prompt)
    3              0.000009   return a:cli

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:69
Called 3 times
Total time:   0.000644
 Self time:   0.000132

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    3              0.000028     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    3              0.000028     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
    2              0.000016         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
    2              0.000006         if g:ale_lint_on_filetype_changed
    2   0.000536   0.000024             call ale#Queue(300, 'lint_file', a:buffer)
    2              0.000002         endif
    3              0.000004     endif

FUNCTION  vista#statusline#ShouldDisable()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/statusline.vim:7
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000024   return get(g:, 'vista_disable_statusline', s:other_statusline_plugin_loaded)

FUNCTION  382()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:67
Called 84 times
Total time:   1.311435
 Self time:   0.002659

count  total (s)   self (s)
   84   1.311341   0.002565 	return call("s:call", [self.slots(), a:func] + a:000)

FUNCTION  383()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:72
Called 36 times
Total time:   0.002876
 Self time:   0.002876

count  total (s)   self (s)
   36              0.002858 	return filter(copy(self.variables.slots), a:expr)

FUNCTION  384()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:77
Called 36 times
Total time:   0.003282
 Self time:   0.000406

count  total (s)   self (s)
   36   0.003265   0.000389 	return get(self.find_by(a:expr), 0, {})

FUNCTION  385()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:82
Called 84 times
Total time:   0.096498
 Self time:   0.002006

count  total (s)   self (s)
   84   0.096396   0.001904 	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)

FUNCTION  387()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:92
Called 98 times
Total time:   0.022440
 Self time:   0.014794

count  total (s)   self (s)
   98   0.022293   0.014647 	return map(copy(self.variables.slots), "self.get_slot(v:val)")

FUNCTION  <SNR>276_as_windo()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Window.vim:44
Called 2 times
Total time:   0.001483
 Self time:   0.001483

count  total (s)   self (s)
    2              0.000006 	let windo = {}
    2              0.000006 	let windo.obj = a:base
   46              0.000261 	for [key, Value] in items(a:base)
   44              0.000270 		if type(function("tr")) == type(Value)
   42              0.000570 			execute			"function! windo.". key. "(...)\n"			"	return s:windo(self.obj." . key . ", a:000, self.obj)\n"			"endfunction"
   44              0.000073 		endif
   44              0.000174 		unlet Value
   46              0.000060 	endfor
    2              0.000005 	return windo

FUNCTION  <SNR>205__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:21
Called 1 time
Total time:   0.000893
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000889   0.000008 	let s:Message  = s:V.import("Vim.Message")

FUNCTION  <SNR>223__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:21
Called 1 time
Total time:   0.001117
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000020 	let s:V = a:V
    1   0.001097   0.000010 	let s:E  = s:V.import("Over.Exception")

FUNCTION  175()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:118
Called 8 times
Total time:   0.000942
 Self time:   0.000942

count  total (s)   self (s)
    8              0.000892 	execute self.draw_command
                            " 	execute "echohl" a:cmdline.highlights.prompt
                            " 	call s:echon(a:cmdline.get_prompt())
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.backward())
                            " 	if empty(a:cmdline.line.pos_char())
                            " 		execute "echohl" a:cmdline.highlights.cursor
                            " 		call s:echon(' ')
                            " 	else
                            " 		execute "echohl" a:cmdline.highlights.cursor_on
                            " 		call s:echon(a:cmdline.line.pos_char())
                            " 	endif
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.forward())
                            " 	if	a:cmdline.get_suffix() != ""
                            " 		call s:echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            " 	endif

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:145
Called 6379 times
Total time:   6.544707
 Self time:   0.676772

count  total (s)   self (s)
 6379              0.071604   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
 6379              0.047036   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
 6379              0.035647   let curtabcnt = tabpagenr('$')
 6379              0.028204   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
 6379              0.011395   endif
                            
 6379              0.052010   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
 6379              0.009218   endif
 6379              0.017270   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
 6379              0.016490   elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
 6379              0.027488   elseif show_buffers && curtabcnt == 1 || !show_tabs
 6379   6.007847   0.139912     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>194_RestoreValue()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:466
Called 2 times
Total time:   0.001220
 Self time:   0.000278

count  total (s)   self (s)
    2   0.000227   0.000039     call EasyMotion#helper#VarReset('&scrolloff')
    2   0.000167   0.000051     call EasyMotion#helper#VarReset('&modified')
    2   0.000170   0.000042     call EasyMotion#helper#VarReset('&modifiable')
    2   0.000250   0.000039     call EasyMotion#helper#VarReset('&readonly')
    2   0.000128   0.000033     call EasyMotion#helper#VarReset('&spell')
    2   0.000134   0.000031     call EasyMotion#helper#VarReset('&virtualedit')
                                " if &foldmethod !=# 'expr'
    2   0.000134   0.000033         call EasyMotion#helper#VarReset('&foldmethod')
                                " endif

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:24
Called 7 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
    7              0.000054   if getbufvar(a:2.bufnr, '&buftype') == 'terminal'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', spc.'%f')
                                let neoterm_id = getbufvar(a:2.bufnr, 'neoterm_id')
                                if neoterm_id != ''
                                  call a:1.add_section('airline_c', spc.'neoterm_'.neoterm_id.spc)
                                endif
                                return 1
    7              0.000011   endif

FUNCTION  179()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim:24
Called 8 times
Total time:   0.002735
 Self time:   0.000944

count  total (s)   self (s)
    8   0.000238   0.000055 	if a:cmdline.is_input("\<Right>")
                            		call a:cmdline.line.next()
                            		call a:cmdline.setchar('')
    8   0.000243   0.000072 	elseif a:cmdline.is_input("\<Left>")
                            		call a:cmdline.line.prev()
                            		call a:cmdline.setchar('')
    8   0.000476   0.000113 	elseif a:cmdline.is_input("\<C-b>")		|| a:cmdline.is_input("\<Home>")
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
    8   0.000453   0.000107 	elseif a:cmdline.is_input("\<C-e>")		|| a:cmdline.is_input("\<End>")
                            		call a:cmdline.setline(a:cmdline.line.length())
                            		call a:cmdline.setchar('')
    8   0.000505   0.000103 	elseif a:cmdline.is_input("\<C-Left>")		|| a:cmdline.is_input("\<S-Left>")
                            		call a:cmdline.setline(strridx(a:cmdline.backward()[:-2], ' ') + 1)
                            		call a:cmdline.setchar('')
    8   0.000429   0.000103 	elseif a:cmdline.is_input("\<C-Right>")		|| a:cmdline.is_input("\<S-Right>")
                            		let p = stridx(a:cmdline.forward()[1:], ' ')
                            		call a:cmdline.setline(p != -1 ? a:cmdline.line.pos() + p + 2 : a:cmdline.line.length())
                            		call a:cmdline.setchar('')
    8              0.000011 	endif

FUNCTION  <SNR>244__get_key()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim:60
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " 	call extend(l:, a:conf)
    3              0.000009 	let self = a:conf
    3              0.000023 	return get(a:conf, "expr", 0) ? s:_safe_eval(a:conf.key, l:) : a:conf.key

FUNCTION  <SNR>109_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:32
Called 50 times
Total time:   0.031673
 Self time:   0.031673

count  total (s)   self (s)
   50              0.001174   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
   50              0.000890   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
   50              0.000075   else
   50              0.000152     let head_spc = '\v(^ +)'
   50              0.000069   endif
   50              0.009498   let indent_tabs = search('\v(^\t+)', 'nw')
   50              0.018352   let indent_spc  = search(head_spc, 'nw')
   50              0.000278   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
   50              0.000077   else
   50              0.000100     return ''
                              endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 1172 times
Total time:   0.032443
 Self time:   0.032443

count  total (s)   self (s)
 1172              0.005177   let x = a:i - 1
 1400              0.003795   while x >= 0
 1066              0.006156     let group = a:sections[x][0]
 1066              0.004252     if group != '' && group != '|'
  838              0.002184       return group
  228              0.000374     endif
  228              0.000740     let x = x - 1
  562              0.001194   endwhile
  334              0.000653   return ''

FUNCTION  <SNR>130_GetExplicitExecutive()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:92
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000004   let ft = &filetype
                            
    1              0.000007   if exists('g:vista_'.ft.'_executive')
                                execute 'return' 'g:vista_'.ft.'_executive'
    1              0.000001   endif
                            
    1              0.000009   if exists('g:vista_executive_for') && has_key(g:vista_executive_for, ft)
                                return g:vista_executive_for[ft]
    1              0.000002   endif
                            
    1              0.000006   return v:null

FUNCTION  391()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim:111
Called 15 times
Total time:   0.004639
 Self time:   0.002227

count  total (s)   self (s)
   15   0.001259   0.000354 	if a:cmdline.is_input("<Over>(buffer-complete)")		|| a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            		if self.complete(a:cmdline) == -1
                            			call s:_finish()
                            			call a:cmdline.setchar('')
                            			return
                            		endif
                            		if a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            		call a:cmdline.setchar('')
                            		call a:cmdline.tap_keyinput("Completion")
                            " 	elseif a:cmdline.is_input("\<Tab>", "Completion")
   15   0.000920   0.000302 	elseif a:cmdline.is_input("<Over>(buffer-complete)", "Completion")		|| a:cmdline.is_input("\<Right>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count += 1
                            		if s:count >= len(s:complete_list)
                            			let s:count = 0
                            		endif
   15   0.000773   0.000263 	elseif a:cmdline.is_input("<Over>(buffer-complete-prev)", "Completion")		|| a:cmdline.is_input("\<Left>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count -= 1
                            		if s:count < 0
                            			let s:count = len(s:complete_list) - 1
                            		endif
   15              0.000021 	else
   15   0.000270   0.000122 		if a:cmdline.untap_keyinput("Completion")
                            			call a:cmdline.callevent("on_char_pre")
   15              0.000018 		endif
   15   0.000429   0.000198 		call s:_finish()
   15              0.000023 		return
                            	endif
                            	call a:cmdline.setline(s:line)
                            	call a:cmdline.insert(s:complete_list[s:count], s:pos)
                            	if len(s:complete_list) > 1
                            		let &statusline = s:_as_statusline(s:complete_list, s:count)
                            		redrawstatus
                            	endif
                            	if len(s:complete_list) == 1
                            		call a:cmdline.untap_keyinput("Completion")
                            	endif

FUNCTION  392()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim:158
Called 14 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " 	redrawstatus

FUNCTION  394()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Cancel.vim:18
Called 15 times
Total time:   0.001045
 Self time:   0.000363

count  total (s)   self (s)
   15   0.000898   0.000216 	if a:cmdline.is_input("\<Esc>")	|| a:cmdline.is_input("\<C-c>")
                            " 		call a:cmdline.cancel()
                            		call a:cmdline.exit(1)
                            		call a:cmdline.setchar("")
   15              0.000024 	endif

FUNCTION  vital#_easymotion#Over#Commandline#Modules#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:5
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000022     return map({'get': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  396()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim:58
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            	" Delete cache to handle additional digraphs definition
    3              0.000014 	let self.digraphs = {}

FUNCTION  <SNR>205_get()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:99
Called 1 time
Total time:   0.000515
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000029 	if !hlexists(a:name)
                            		return {}
    1              0.000001 	endif
    1   0.000467   0.000032 	let result = s:parse(substitute(s:capture(a:name), "\n", "", "g"))
    1              0.000005 	if has_key(result, "link") && get(a:, 1, 0)
                            		return s:get(result.link, get(a:, 1, 0))
    1              0.000002 	else
    1              0.000002 		return result
                            	endif

FUNCTION  398()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim:90
Called 15 times
Total time:   0.001089
 Self time:   0.000652

count  total (s)   self (s)
   15   0.000603   0.000166 	if a:cmdline.is_input("\<C-k>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
   15              0.000024 	else
   15              0.000069 		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
   15              0.000023 		endif
   15              0.000023 	endif

FUNCTION  airline#extensions#apply_left_override()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:69
Called 2 times
Total time:   0.000809
 Self time:   0.000089

count  total (s)   self (s)
    2              0.000028   let w:airline_section_a = a:section1
    2              0.000009   let w:airline_section_b = a:section2
    2   0.000752   0.000032   let w:airline_section_c = airline#section#create(['readonly'])
    2              0.000008   let w:airline_render_left = 1
    2              0.000007   let w:airline_render_right = 0

FUNCTION  airline#extensions#virtualenv#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/virtualenv.vim:13
Called 9 times
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
    9              0.000068   if &filetype =~# "python"
                                if get(g:, 'virtualenv_loaded', 0)
                                  let statusline = virtualenv#statusline()
                                else
                                  let statusline = fnamemodify($VIRTUAL_ENV, ':t')
                                endif
                                if !empty(statusline)
                                  call airline#extensions#append_to_section('x', s:spc.g:airline_right_alt_sep.s:spc.statusline)
                                endif
    9              0.000013   endif

FUNCTION  <SNR>166_ClosePopup()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/popup.vim:9
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000016   if exists('s:popup_winid')
                                call popup_hide(s:popup_winid)
                                autocmd! VistaPopup
    2              0.000004   endif
    2              0.000016   let t:vista.popup_visible = v:false

FUNCTION  vital#easymotion#new()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:24
Called 13 times
Total time:   0.000487
 Self time:   0.000252

count  total (s)   self (s)
   13   0.000479   0.000244   return s:new(s:plugin_name)

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:8
Called 24 times
Total time:   0.001205
 Self time:   0.000531

count  total (s)   self (s)
   24   0.001164   0.000490   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  380()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:42
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000010 	if empty(a:slot)
    3              0.000005 		return -1
                            	endif
                            	for i in range(len(self.variables.slots))
                            		if self.variables.slots[i].id == a:slot.id
                            			unlet self.variables.slots[i]
                            			return
                            		endif
                            	endfor
                            	return -1

FUNCTION  381()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:56
Called 3 times
Total time:   0.000398
 Self time:   0.000050

count  total (s)   self (s)
    3   0.000395   0.000047 	return self.disconnect(self.find_first_by(a:expr))

FUNCTION  <SNR>136_OnCursorMovedNormalMode()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:755
Called 2179 times
Total time:   0.679665
 Self time:   0.372871

count  total (s)   self (s)
 2179   0.356050   0.049256   if !s:AllowedToCompleteInCurrentBuffer()
  100              0.000207     return
 2079              0.003203   endif
                            
 2079              0.312186   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  ale#handlers#alex#DefineLinter()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/alex.vim:42
Called 2 times
Total time:   0.002028
 Self time:   0.000152

count  total (s)   self (s)
    2   0.000076   0.000029     call ale#Set('alex_executable', 'alex')
    2   0.000064   0.000028     call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
    2   0.001883   0.000090     call ale#linter#Define(a:filetype, {   'name': 'alex',   'executable': function('ale#handlers#alex#GetExecutable'),   'command': ale#handlers#alex#CreateCommandCallback(a:flags),   'output_stream': 'stderr',   'callback': 'ale#handlers#alex#Handle',   'lint_file': 1,})

FUNCTION  <SNR>197__dot_to_sharp()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:235
Called 31 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
   31              0.000297   return substitute(a:name, '\.', '#', 'g')

FUNCTION  <SNR>123_cpath()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:110
Called 53 times
Total time:   0.003592
 Self time:   0.002459

count  total (s)   self (s)
   53              0.000332   if exists('+fileignorecase') && &fileignorecase
                                let path = FugitiveVimPath(tolower(a:path))
   53              0.000105   else
   53   0.002076   0.000943     let path = FugitiveVimPath(a:path)
   53              0.000095   endif
   53              0.000328   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  vista#source#Update()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:102
Called 3 times
Total time:   0.000526
 Self time:   0.000526

count  total (s)   self (s)
    3              0.000034   if !exists('t:_vista_initialized')
                                call s:EnsureExists()
                                let t:_vista_initialized = 1
    3              0.000009   endif
                            
    3              0.000023   let t:vista.source.bufnr = a:bufnr
                            
    3              0.000012   if a:0 == 1
                                let t:vista.source.fname = a:1
    3              0.000011   elseif a:0 == 2
    3              0.000026     let t:vista.source.fname = a:1
    3              0.000016     let t:vista.source.fpath = a:2
    3              0.000005   endif

FUNCTION  <SNR>198__is_valid_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:400
Called 1 time
Total time:   0.000555
 Self time:   0.000040

count  total (s)   self (s)
    1   0.000527   0.000012 	let highlight = s:Highlight.get(a:name)
    1              0.000003 	if empty(highlight)
                            		return 0
    1              0.000001 	endif
                            
    1              0.000010 	if has("gui_running")	&& (has_key(highlight, "guifg") || has_key(highlight, "guibg"))
                            		return 1
    1              0.000006 	elseif (has_key(highlight, "ctermfg") || has_key(highlight, "ctermbg"))
                            		return 1
    1              0.000002 	endif
    1              0.000001 	return 0

FUNCTION  incsearch#execute_search()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:461
Called 21 times
Total time:   0.007837
 Self time:   0.000495

count  total (s)   self (s)
   20   0.007096   0.000459     return call(function('s:_execute_search'), a:000)

FUNCTION  incsearch#highlight#incremental_highlight()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/highlight.vim:248
Called 15 times
Total time:   0.035987
 Self time:   0.002979

count  total (s)   self (s)
   15              0.000152   let should_separate_highlight = get(a:, 1, s:FALSE)
   15              0.000101   let direction = get(a:, 2, s:DIRECTION.forward)
   15              0.000165   let start_pos = get(a:, 3, getpos('.')[1:2])
   15   0.001886   0.000275   let hgm = incsearch#highlight#hgm()
   15              0.000115   let [m, r, o, c] = [hgm.match, hgm.match_reverse, hgm.on_cursor, hgm.cursor]
   15              0.000095   let on_cursor_pattern = '\m\%#\(' . a:pattern . '\m\)'
                            
   15              0.000118   if '' =~# a:pattern
                                " Do not highlight for patterns which match everything
                                call s:hi.delete_all()
   15              0.000114   elseif ! should_separate_highlight
   15   0.001175   0.000228     call s:hi.add(m.group, m.group, a:pattern, m.priority)
   15              0.000060     if ! g:incsearch#no_inc_hlsearch
   15              0.000059       let @/ = a:pattern
   15   0.000186   0.000157       let &hlsearch = &hlsearch
   15              0.000067     endif
                              else
                                let [p1, p2] = (direction == s:DIRECTION.forward)   ? [incsearch#highlight#forward_pattern(a:pattern, start_pos)     ,incsearch#highlight#backward_pattern(a:pattern, start_pos)]   : [incsearch#highlight#backward_pattern(a:pattern, start_pos)     ,incsearch#highlight#forward_pattern(a:pattern, start_pos)]
                                call s:hi.add(m.group , m.group , p1 , m.priority) " right direction
                                call s:hi.add(r.group , r.group , p2 , r.priority) " reversed direction
   15              0.000036   endif
   15   0.001064   0.000203   call s:hi.add(o.group , o.group , on_cursor_pattern , o.priority)
   15   0.001001   0.000175   call s:hi.add(c.group , c.group , '\v%#'            , c.priority)
   15   0.028997   0.000263   call incsearch#highlight#update()

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:46
Called 17052 times
Total time:   3.235331
 Self time:   1.136163

count  total (s)   self (s)
17052              0.188285   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
17052              0.024653   endif
17052   2.476693   0.377525   return {b:source_func}()

FUNCTION  riv#list#get_parent()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/list.vim:185
Called 1 time
Total time:   0.000105
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000104   0.000011     return s:get_parent(a:row)

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:35
Called 6489 times
Total time:   0.276156
 Self time:   0.276156

count  total (s)   self (s)
 6489              0.042607   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
 6489              0.108327   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
 6489              0.051802   if getbufvar(a:bufnr, '&modified') == 1
 6342              0.031529     let _ .= s:buf_modified_symbol
 6489              0.010126   endif
 6489              0.014914   return _

FUNCTION  <SNR>200__compare()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:113
Called 1496 times
Total time:   0.011211
 Self time:   0.011211

count  total (s)   self (s)
 1496              0.010601   return eval(s:expr)

FUNCTION  <SNR>137_get_link_idx()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/link.vim:316
Called 2077 times
Total time:   0.541587
 Self time:   0.158749

count  total (s)   self (s)
 2077   0.141491   0.036071     let idx = riv#ptn#get_tar_idx(a:line, a:col)
 2077   0.131213   0.040160     let idx = idx==-1 ? riv#ptn#get_role_idx(a:line, a:col) : idx
 2077   0.096419   0.039202     let idx = idx==-1 ? riv#ptn#get_phase_idx(a:line, a:col) : idx
 2077   0.164321   0.035173     let idx = idx==-1 ? riv#ptn#get_WORD_idx(a:line, a:col) : idx
 2077              0.004870     return idx

FUNCTION  <SNR>265__auto_cmap()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:101
Called 3 times
Total time:   0.007982
 Self time:   0.001626

count  total (s)   self (s)
    3              0.000008 	let cmaps = {}
    3   0.004561   0.000055 	let cmap_info = s:Keymapping.rhs_key_list("c", 0, 1)
                            	" vital-over currently doesn't support <buffer> mappings
   23              0.000084 	for c in filter(cmap_info, "v:val['buffer'] ==# 0")
   20   0.003186   0.001336 		let cmaps[s:Keymapping.escape_special_key(c['lhs'])] = {   'noremap' : c['noremap'],   'key'  : s:Keymapping.escape_special_key(s:_convert_sid(c['rhs'], c['sid'])),   'expr' : s:Keymapping.escape_special_key(c['expr']), }
   23              0.000054 	endfor
    3              0.000007 	return cmaps

FUNCTION  <SNR>164_GetAliasedFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:403
Called 476 times
Total time:   0.054488
 Self time:   0.054488

count  total (s)   self (s)
  476              0.004088     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
  476              0.005562     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
  476              0.000710     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
 1904              0.009205     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
 1428              0.008863         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
 1428              0.002226         endif
 1904              0.003515     endfor
                            
  476              0.001718     return a:original_filetype

FUNCTION  vista#renderer#LSPProcess()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer.vim:105
Called 1 time
Total time:   0.191984
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000002   if a:reload_only
                                call vista#sidebar#Reload(a:processed_data)
                                return [v:false, a:should_display]
    1              0.000003   elseif a:should_display
    1   0.191967   0.000014     call vista#renderer#RenderAndDisplay(a:processed_data)
    1              0.000004     return [a:reload_only, v:false]
                              else
                                return [a:reload_only, a:should_display]
                              endif

FUNCTION  403()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:82
Called 14 times
Total time:   0.937948
 Self time:   0.001930

count  total (s)   self (s)
   14   0.000212   0.000125 	if empty(a:cmdline.line.pos_char())
   14              0.000086 		let cursor = "echohl " . a:cmdline.highlights.cursor . " | echon ' '"
                            	else
                            		let cursor = "echohl " . a:cmdline.highlights.cursor_on . " | " . s:_as_echon(a:cmdline.line.pos_char())
   14              0.000020 	endif
   14              0.000030 	let suffix = ""
   14   0.000186   0.000132 	if	a:cmdline.get_suffix() != ""
                            		let suffix = s:_as_echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
   14              0.000020 	endif
   14   0.001799   0.000954 	let self.draw_command  = join([		"echohl " . a:cmdline.highlights.prompt,		s:_as_echon(a:cmdline.get_prompt()),		"echohl NONE",		s:_as_echon(a:cmdline.backward()),		cursor,		"echohl NONE",		s:_as_echon(a:cmdline.forward()),		suffix,	], " | ")
                            
   14   0.935242   0.000210 	call s:_redraw(a:cmdline)

FUNCTION  <SNR>151_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 915 times
Total time:   0.007133
 Self time:   0.007133

count  total (s)   self (s)
  915              0.003245   if a:text ==# 'added'
  915              0.002853     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  <SNR>163_HeadingWhitespaces()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/fold.vim:6
Called 6 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    6              0.000048   return strlen(matchstr(a:line,'\v^\s+'))

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:52
Called 2894 times
Total time:   0.532956
 Self time:   0.323125

count  total (s)   self (s)
 2894              0.013285     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
 2894              0.004460     endif
                            
                                " Check for a cached executable() check.
 2894              0.027170     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
 2894              0.012896     if l:result isnot v:null
                                    return l:result
 2894              0.004731     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
 2894              0.104326     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
 2894              0.022713     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
 2894              0.004421     endif
                            
 2894              0.008234     if g:ale_history_enabled
 2894   0.263225   0.053394         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
 2894              0.004883     endif
                            
 2894              0.008114     return l:result

FUNCTION  <SNR>267__verbosefile_pop()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Capture.vim:24
Called 3 times
Total time:   0.000125
 Self time:   0.000121

count  total (s)   self (s)
    3              0.000012 	let filename = &verbosefile
    3   0.000088   0.000084 	let &verbosefile = get(s:verbosefiles, -1)
    3              0.000016 	call remove(s:verbosefiles, -1)
    3              0.000006 	return filename

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:156
Called 9 times
Total time:   0.060808
 Self time:   0.001110

count  total (s)   self (s)
    9   0.000216   0.000150   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    9              0.000012   endif
   16              0.000049   for nr in a:range
    7   0.000151   0.000101     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
    7              0.000010     endif
    7              0.000051     call setwinvar(nr, 'airline_active', 0)
    7              0.000064     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    7              0.000041     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    7              0.000010     endif
    7   0.059734   0.000152     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   16              0.000035   endfor

FUNCTION  <SNR>220_make_emacs()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:93
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	return deepcopy(s:emacs)

FUNCTION  <SNR>258__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/InsertRegister.vim:15
Called 1 time
Total time:   0.000078
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000075   0.000008 	let s:String  = s:V.import("Over.String")

FUNCTION  <SNR>276__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Window.vim:15
Called 1 time
Total time:   0.007885
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.007882   0.000011 	let s:Buffer = a:V.import("Vim.Buffer")

FUNCTION  <SNR>136_OnBufferEnter()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:606
Called 4 times
Total time:   0.016881
 Self time:   0.004960

count  total (s)   self (s)
    4   0.000470   0.000080   if !s:VisitedBufferRequiresReparse()
    3              0.000004     return
    1              0.000001   endif
                            
    1   0.000062   0.000019   call s:SetUpCompleteopt()
    1   0.000045   0.000017   call s:SetCompleteFunc()
    1   0.000037   0.000017   call s:StartMessagePoll()
                            
    1   0.011002   0.004772   exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
    1   0.005246   0.000036   call s:OnFileReadyToParse( 1 )

FUNCTION  vital#_incsearch#Over#Commandline#Modules#DrawCommandline#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:7
Called 1 time
Total time:   0.000046
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000045   0.000031 return map({'suffix': '', 'make': ''}, "vital#_incsearch#function('<SNR>253_' . v:key)")

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:218
Called 324 times
Total time:   0.016162
 Self time:   0.016162

count  total (s)   self (s)
  324              0.001883   let cur = bufnr('%')
  324              0.000901   if cur == a:bufnr
  312              0.002609     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
  150              0.000503       let group = 'airline_tabmod'
  162              0.000253     else
  162              0.000648       let group = 'airline_tabsel'
  312              0.000473     endif
   12              0.000018   else
   12              0.000078     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
   12              0.000052     elseif index(a:tab_bufs, a:bufnr) > -1
    9              0.000024       let group = 'airline_tab'
    3              0.000003     else
    3              0.000009       let group = 'airline_tabhid'
   12              0.000013     endif
  324              0.000464   endif
  324              0.000796   return group

FUNCTION  EasyMotion#reset()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:66
Called 3 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    3              0.000038     let s:flag = { 'within_line' : 0, 'dot_repeat' : 0, 'regexp' : 0, 'bd_t' : 0, 'find_bd' : 0, 'linewise' : 0, 'count_dot_repeat' : 0, }
                                    " regexp: -> regular expression
                                    "   This value is used when multi input find motion. If this values is
                                    "   1, input text is treated as regexp.(Default: escaped)
                                    " bd_t: -> bi-directional 't' motion
                                    "   This value is used to re-define regexp only for bi-directional 't'
                                    "   motion
                                    " find_bd: -> bi-directional find motion
                                    "   This value is used to recheck the motion is inclusive or exclusive
                                    "   because 'f' & 't' forward find motion is inclusive, but 'F' & 'T'
                                    "   backward find motion is exclusive
                                    " count_dot_repeat: -> dot repeat with count
                                    "   https://github.com/easymotion/vim-easymotion/issues/164
    3              0.000034     let s:current = { 'is_operator' : 0, 'is_search' : 0, 'dot_repeat_target_cnt' : 0, 'dot_prompt_user_cnt' : 0, 'changedtick' : 0, }
                                    " \ 'start_position' : [],
                                    " \ 'cursor_position' : [],
                            
                                    " is_operator:
                                    "   Store is_operator value first because mode(1) value will be
                                    "   changed by some operation.
                                    " dot_* :
                                    "   These values are used when '.' repeat for automatically
                                    "   select marker/label characters.(Using count avoid recursive
                                    "   prompt)
                                    " changedtick:
                                    "   :h b:changedtick
                                    "   This value is used to avoid side effect of overwriting buffer text
                                    "   which will change b:changedtick value. To overwrite g:repeat_tick
                                    "   value(defined tpope/vim-repeat), I can avoid this side effect of
                                    "   conflicting with tpope/vim-repeat
                                    " start_position:
                                    "   Original, start cursor position.
                                    " cursor_position:
                                    "   Usually, this values is same with start_position, but in
                                    "   visualmode and 'n' key motion, this value could be different.
    3              0.000007     return ""

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:57
Called 87 times
Total time:   0.121324
 Self time:   0.014409

count  total (s)   self (s)
   87              0.000305   if g:airline#init#vim_async
                                " Vim 8 with async support
   87   0.116478   0.009563     noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
   87              0.000161   endif

FUNCTION  90()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:157
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000013 	let self.variables.prompt = a:prompt

FUNCTION  425()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 3 times
Total time:   0.000512
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000014 	let s:cmdline = a:cmdline
    3   0.000494   0.000053 	call s:doautocmd_user(self.prefix, self.prefix . 'Execute')

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:94
Called 24 times
Total time:   0.001348
 Self time:   0.000397

count  total (s)   self (s)
   24   0.001316   0.000365   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  vital#_incsearch#Vim#Message#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Message.vim:7
Called 1 time
Total time:   0.000128
 Self time:   0.000092

count  total (s)   self (s)
    1   0.000128   0.000092 return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''}, "vital#_incsearch#function('<SNR>247_' . v:key)")

FUNCTION  <SNR>105_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:123
Called 17052 times
Total time:   2.755482
 Self time:   2.465716

count  total (s)   self (s)
17052   0.556996   0.267230   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
17052              0.028128   else
17052              0.100007     let s:vcs_config['mercurial'].branch = ''
17052              0.027128   endif

FUNCTION  vital#_incsearch#Vim#Type#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Type.vim:7
Called 1 time
Total time:   0.000181
 Self time:   0.000145

count  total (s)   self (s)
    1   0.000181   0.000145 return map({'_vital_created': '', 'is_predicate': '', 'is_numeric': '', 'is_special': ''}, "vital#_incsearch#function('<SNR>281_' . v:key)")

FUNCTION  95()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:184
Called 8 times
Total time:   0.000098
 Self time:   0.000048

count  total (s)   self (s)
    8   0.000098   0.000048 	return self.line.forward()

FUNCTION  <SNR>145_on_stdout()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:113
Called 132 times
Total time:   0.001680
 Self time:   0.001680

count  total (s)   self (s)
  132              0.001430     let self.buf .= a:msg

FUNCTION  vista#util#Truncate()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:13
Called 1 time
Total time:   0.000050
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000042   0.000016   let maxlen = vista#util#MaxLen()
    1              0.000008   return len(a:msg) < maxlen ? a:msg : a:msg[:maxlen-3].'...'

FUNCTION  riv#ptn#fix_sfts()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:668
Called 6 times
Total time:   0.000786
 Self time:   0.000673

count  total (s)   self (s)
                                " for current col, find the closest one in f_cols with sft
                                "
    6              0.000018     let b_col = a:col
    6              0.000015     if a:sft >= 0
   17              0.000077         for f_col in sort(a:f_cols)
   16              0.000037             if a:col < f_col
    5              0.000048                 let b_col = f_col
    5              0.000042                 break
   11              0.000032             endif
   17              0.000079         endfor
                                else
                                    for f_col in reverse(sort(a:f_cols))
                                        if a:col > f_col
                                            let b_col = f_col
                                            break
                                        endif
                                    endfor
    6              0.000009     endif
                            
    6   0.000219   0.000106     return riv#ptn#fix_sft(a:col,b_col,a:sft)

FUNCTION  <SNR>210_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:149
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  incsearch#over#modules#bulk_input_char#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bulk_input_char.vim:30
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return deepcopy(s:bulk_input_char)

FUNCTION  <SNR>132_IntoTemp()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:235
Called 1 time
Total time:   0.000518
 Self time:   0.000426

count  total (s)   self (s)
                              " Don't use tempname() if possible since it would cause the changing of the anonymous tag name.
                              "
                              " Ref: https://github.com/liuchengxu/vista.vim/issues/122#issuecomment-511115932
    1              0.000002   try
    1              0.000015     if exists('$TMPDIR')
                                  let tmpdir = s:Tempdir()
                                  let tempname = s:TempnameBasedOnSourceBufname()
                                  let tmp = tmpdir.tempname
    1              0.000002     else
    1              0.000005       if s:is_mac || s:is_linux
    1              0.000004         let tmpdir = '/tmp/vista.vim_ctags_tmp/'
    1              0.000014         if !isdirectory(tmpdir)
                                      call mkdir(tmpdir)
    1              0.000002         endif
    1   0.000114   0.000022         let tempname = s:TempnameBasedOnSourceBufname()
    1              0.000005         let tmp = tmpdir.tempname
    1              0.000002       endif
    1              0.000001     endif
                              catch
    1              0.000002   endtry
                            
    1              0.000005   if !exists('l:tmp')
                                let tmp = s:BuiltinTempname()
    1              0.000002   endif
                            
    1              0.000007   if get(t:vista, 'on_text_changed', 0)
                                let lines = t:vista.source.lines()
                                let t:vista.on_text_changed = 0
    1              0.000002   else
    1              0.000004     if empty(a:1)
                                  let lines = t:vista.source.lines()
    1              0.000002     else
    1              0.000002       try
    1              0.000079         let lines = readfile(a:1)
                                  " Vim cannot read a temporary file, this may happen when you open vim with
                                  " a file which does not exist yet, e.g., 'vim does_exist_yet.txt'
                                  catch /E484/
                                    return
    1              0.000002       endtry
    1              0.000002     endif
    1              0.000002   endif
                            
    1              0.000189   if writefile(lines, tmp) == 0
    1              0.000004     return tmp
                              else
                                return vista#error#('Fail to write into a temp file.')
                              endif

FUNCTION  ale#handlers#writegood#DefineLinter()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/writegood.vim:64
Called 2 times
Total time:   0.001810
 Self time:   0.000069

count  total (s)   self (s)
    2   0.001808   0.000067     call ale#linter#Define(a:filetype, {   'name': 'writegood',   'aliases': ['write-good'],   'executable': function('ale#handlers#writegood#GetExecutable'),   'command': function('ale#handlers#writegood#GetCommand'),   'callback': 'ale#handlers#writegood#Handle',})

FUNCTION  <SNR>36_getline()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:139
Called 2341 times
Total time:   0.212792
 Self time:   0.212792

count  total (s)   self (s)
 2341              0.018672   let line = getline('.')
 2341              0.018386   let pos = col('.') - 1
 2341              0.018012   let before = strpart(line, 0, pos)
 2341              0.012519   let after = strpart(line, pos)
 2341              0.007830   let afterline = after
 2341              0.008274   if g:AutoPairsMultilineClose
 2341              0.010947     let n = line('$')
 2341              0.011976     let i = line('.')+1
 3048              0.010886     while i <= n
  808              0.003878       let line = getline(i)
  808              0.003557       let after = after.' '.line
  808              0.009625       if !(line =~ '\v^\s*$')
  101              0.000267         break
  707              0.001066       end
  707              0.002659       let i = i+1
 3048              0.007508     endwhile
 2341              0.003909   end
 2341              0.012395   return [before, after, afterline]

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:49
Called 106 times
Total time:   0.004985
 Self time:   0.004985

count  total (s)   self (s)
  106              0.000436   let x = a:i + 1
  106              0.000461   let l = len(a:sections)
  212              0.000503   while x < l
  212              0.001210     let group = a:sections[x][0]
  212              0.000734     if group != '' && group != '|'
  106              0.000279       return group
  106              0.000198     endif
  106              0.000318     let x = x + 1
  106              0.000219   endwhile
                              return ''

FUNCTION  <SNR>101_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:132
Called 33371 times
Total time:   1.893203
 Self time:   1.893203

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
33371              0.256314   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
33371              0.048853   endif
33371              0.227555   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
33371              0.047883   endif
                            
68743              0.212241   for val in a:colors
68743              0.309748     if !empty(val) && val !=# 'NONE'
33371              0.087803       return a:colors
35372              0.054433     endif
35372              0.057730   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  riv#ptn#strip()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:577
Called 25 times
Total time:   0.000405
 Self time:   0.000405

count  total (s)   self (s)
   25              0.000394     return matchstr(a:str, '^\s*\zs.\{-}\ze\s*$')

FUNCTION  vital#_easymotion#Over#Signals#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:5
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000029     return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:12
Called 6489 times
Total time:   0.972961
 Self time:   0.696805

count  total (s)   self (s)
 6489              0.059679   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
 6489              0.015802   let _ = ''
                            
 6489              0.040373   let name = bufname(a:bufnr)
 6489              0.026548   if empty(name)
                                let _ .= '[No Name]'
 6489              0.010837   else
 6489              0.019894     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/–£—á—ë–±–∞/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
 6489              0.146365       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
 6489              0.009907     endif
 6489              0.052263     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
 6489              0.010322     endif
 6489              0.009681   endif
                            
 6489   0.456489   0.180333   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  634()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 1 time
Total time:   0.000239
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000097   0.000008     let group = self.get_group(a:i)
    1   0.000088   0.000008     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000006     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
    1              0.000001     endif
                            
    1              0.000005     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
    1              0.000001     else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>214_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:174
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return deepcopy(s:module)

FUNCTION  vista#sidebar#WhichFileType()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:6
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000016   if t:vista.provider ==# 'coc' || (t:vista.provider ==# 'ctags' && g:vista#renderer#ctags ==# 'default')
    2              0.000005     return 'vista'
                              elseif t:vista.provider ==# 'markdown'
                                return 'vista_markdown'
                              else
                                return 'vista_kind'
                              endif

FUNCTION  <SNR>197__runtime()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:251
Called 31 times
Total time:   0.021730
 Self time:   0.009718

count  total (s)   self (s)
   31   0.021705   0.009693   execute 'runtime' fnameescape(a:path)

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:215
Called 24 times
Total time:   0.002079
 Self time:   0.002079

count  total (s)   self (s)
   24              0.000966   let matches = matchlist(a:line, s:hunk_re)
   24              0.000120   if len(matches) > 0
   24              0.000222     let from_line  = str2nr(matches[1])
   24              0.000252     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   24              0.000130     let to_line    = str2nr(matches[3])
   24              0.000169     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   24              0.000135     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>136_OnFileTypeSet()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:585
Called 3 times
Total time:   0.059026
 Self time:   0.010899

count  total (s)   self (s)
                              " The contents of the command-line window are empty when the filetype is set
                              " for the first time. Users should never change its filetype so we only rely
                              " on the CmdwinEnter event for that window.
    3              0.000014   if !empty( getcmdwintype() )
                                return
    3              0.000004   endif
                            
    3   0.000340   0.000050   if !s:AllowedToCompleteInCurrentBuffer()
    1              0.000002     return
    2              0.000002   endif
                            
    2   0.000093   0.000031   call s:SetUpCompleteopt()
    2   0.000044   0.000029   call s:SetCompleteFunc()
    2   0.000058   0.000025   call s:StartMessagePoll()
                            
    2   0.050139   0.010646   exec s:python_command "ycm_state.OnFileTypeSet()"
    2   0.008307   0.000073   call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>278__vital_created()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Guard.vim:28
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " define constant variables
    1              0.000004   if !exists('s:const')
    1              0.000003     let s:const = {}
    1              0.000008     let s:const.is_local_variable_supported = v:version > 703 || (v:version == 703 && has('patch560'))
                                " NOTE:
                                " The third argument is available from 7.4.242 but it had bug and that
                                " bug was fixed from 7.4.513
    1              0.000010     let s:const.is_third_argument_of_getreg_supported = has('patch-7.4.513')
    1              0.000003     lockvar s:const
    1              0.000001   endif
    1              0.000005   call extend(a:module, s:const)

FUNCTION  <SNR>245_get()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules.vim:20
Called 16 times
Total time:   0.021379
 Self time:   0.000570

count  total (s)   self (s)
   16              0.000104 	if exists("s:" . a:name)
                            		return s:{a:name}
   16              0.000026 	endif
   16   0.021119   0.000310 	let s:{a:name} = s:V.import('Over.Commandline.Modules.' . a:name)
   16              0.000062 	return s:{a:name}

FUNCTION  ale#handlers#alex#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/alex.vim:5
Called 50 times
Total time:   0.024276
 Self time:   0.001210

count  total (s)   self (s)
   50   0.024203   0.001137     return ale#node#FindExecutable(a:buffer, 'alex', [   'node_modules/.bin/alex',   'node_modules/alex/cli.js',])

FUNCTION  EasyMotion#highlight#init()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:124
Called 1 time
Total time:   0.001389
 Self time:   0.000173

count  total (s)   self (s)
    1   0.000234   0.000021     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
    1   0.000175   0.000025     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
    1   0.000169   0.000018     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
    1   0.000162   0.000017     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
    1   0.000274   0.000020     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
    1   0.000190   0.000035     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
    1   0.000164   0.000016     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
    1              0.000013     if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
    1              0.000002     endif

FUNCTION  airline#extensions#wordcount#formatters#default#update_fmt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim:6
Called 9 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
    9              0.000095   let s:fmt = get(g:, 'airline#extensions#wordcount#formatter#default#fmt', '%s words')
    9              0.000109   let s:fmt_short = get(g:, 'airline#extensions#wordcount#formatter#default#fmt_short', s:fmt == '%s words' ? '%sW' : s:fmt)

FUNCTION  <SNR>218_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:68
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000006 	let module = deepcopy(s:module)
    1              0.000006 	let module.mode = get(a:, 1, "cmd")
    1              0.000002 	return module

FUNCTION  riv#todo#obj()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/todo.vim:27
Called 1443 times
Total time:   0.267769
 Self time:   0.062535

count  total (s)   self (s)
 1443   0.229364   0.024130     let obj = s:todo_object(a:line)
 1443              0.006158     if !empty(obj)
  195              0.001156         let obj.td_list = obj.groups[1]
  195              0.000813         let obj.td_item = obj.groups[2]
  195              0.000763         let obj.td_prior = obj.groups[3]
  195              0.000900         let obj.td_tm_bgn = obj.groups[4]
  195              0.000733         let obj.td_tm_end = obj.groups[5]
 1443              0.002551     endif
 1443              0.003215     return obj

FUNCTION  <SNR>267_command()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Capture.vim:45
Called 3 times
Total time:   0.001033
 Self time:   0.000765

count  total (s)   self (s)
                            	" Workaround : Vim 7.3.xxx in Travis and Ubuntu
                            	" https://github.com/osyo-manga/vital-palette/issues/5
                            " 	call extend(l:, get(a:, 1, {}))
    3              0.000007 	if a:0 > 0
                            		call s:extend(l:, a:1)
    3              0.000003 	endif
                            
    3   0.000199   0.000056 	call s:_verbosefile_push(tempname())
    3              0.000005 	try
    3              0.000018 		redir =>result
    3              0.000553 		silent execute a:cmd
    3              0.000008 	finally
    3              0.000015 		redir END
    3              0.000004 	endtry
    3   0.000180   0.000055 	call s:_verbosefile_pop()
                            " 	let result = substitute(result, "<SRN>", "\<SNR>", "g")
                            " 	let result = substitute(result, "<SID>", "\<SID>", "g")
    3              0.000007 	return result

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 34106 times
Total time:   0.258249
 Self time:   0.258249

count  total (s)   self (s)
34106              0.234061   return get(s:parts, a:key, {})

FUNCTION  <SNR>265__convert_sid()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:97
Called 20 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
   20              0.000258 	return substitute(a:rhs, '<SID>', '<SNR>' . a:sid . '_', 'g')

FUNCTION  <SNR>190_PriorityCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:153
Called 50 times
Total time:   0.000488
 Self time:   0.000488

count  total (s)   self (s)
   50              0.000155     if s:supports_sign_groups
   50              0.000295         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  188()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:98
Called 8 times
Total time:   0.000948
 Self time:   0.000793

count  total (s)   self (s)
    8   0.000209   0.000054 	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.setchar('"')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
    8              0.000053 	elseif exists("self.prefix_key")		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let char = a:cmdline.input_key()
                            		if char =~ '^[0-9a-zA-z.%#:/"\-*+]$'
                            			let register = tr(getreg(char), "\n", "\r")
                            			call a:cmdline.setchar(register)
                            		elseif char == "="
                            			call a:cmdline.setchar(s:input(a:cmdline))
                            		elseif char == "\<C-w>"
                            			call a:cmdline.setchar(s:get_cmdline_cword(a:cmdline.backward_word(), self.cword))
                            		elseif char == "\<C-a>"
                            			call a:cmdline.setchar(self.cWORD)
                            		elseif char == "\<C-f>"
                            			call a:cmdline.setchar(self.cfile)
                            		elseif char == "\<C-r>"
                            			call a:cmdline.setchar('"')
                            		else
                            			call a:cmdline.setchar("")
                            		endif
                            " 		elseif a:cmdline.is_input('=', self.prefix_key)
                            " 			call a:cmdline.setchar(s:input(a:cmdline))
                            " 		elseif a:cmdline.is_input("\<C-w>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cword)
                            " 		elseif a:cmdline.is_input("\<C-a>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cWORD)
                            " 		elseif a:cmdline.is_input("\<C-f>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cfile)
                            " 		elseif a:cmdline.is_input("\<C-r>", self.prefix_key)
                            " 			call a:cmdline.setchar('"')
                            " 		else
                            " 			call a:cmdline.setchar("")
                            " 		endif
    8              0.000033 	endif

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 17056 times
Total time:   0.103382
 Self time:   0.103382

count  total (s)   self (s)
17056              0.091755   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  420()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 15 times
Total time:   0.002224
 Self time:   0.000324

count  total (s)   self (s)
   15              0.000053 	let s:cmdline = a:cmdline
   15   0.002155   0.000255 	call s:doautocmd_user(self.prefix, self.prefix . 'CharPre')

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:127
Called 9 times
Total time:   0.228009
 Self time:   0.001448

count  total (s)   self (s)
    9   0.000291   0.000216   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    9              0.000017   endif
    9              0.000152   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    9   0.060994   0.000186   call airline#update_statusline_inactive(range)
                            
    9              0.000078   unlet! w:airline_render_left w:airline_render_right
    9              0.000262   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    9              0.000036   let w:airline_active = 1
    9              0.000107   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    9   0.166005   0.000327   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  vital#_easymotion#Over#Commandline#Modules#ExceptionMessage#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:5
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000012     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>123_Dir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:304
Called 53 times
Total time:   0.003610
 Self time:   0.001017

count  total (s)   self (s)
   53   0.003573   0.000980   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:25
Called 51 times
Total time:   0.447978
 Self time:   0.004658

count  total (s)   self (s)
   51   0.002661   0.000942     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
   51              0.000155     if l:should_lint
   51              0.000457         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
   51              0.000099     endif
                            
   51   0.001907   0.000629     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
   51              0.000085     endif
                            
   51   0.001872   0.000883     if l:should_lint && !ale#events#QuitRecently(a:buffer)
   50   0.440016   0.000682         call ale#Queue(0, 'lint_file', a:buffer)
   51              0.000064     endif

FUNCTION  vista#cursor#ShowDetailWithDelay()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:470
Called 2 times
Total time:   0.000488
 Self time:   0.000271

count  total (s)   self (s)
    2   0.000410   0.000193   call s:StopCursorTimer()
                            
    2              0.000041   let s:cursor_timer = timer_start( s:cursor_delay, function('vista#cursor#ShowDetail'), )

FUNCTION  <SNR>250_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/CursorMove.vim:46
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008 	return deepcopy(s:module)

FUNCTION  <SNR>48_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:69
Called 35 times
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
   35              0.000405   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#extensions#tabline#redraw()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:75
Called 2 times
Total time:   0.038629
 Self time:   0.038629

count  total (s)   self (s)
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    2              0.000006   if exists(":redrawtabline") == 2
    2              0.038607     redrawtabline
                              else
                              " Have to set a property equal to itself to get airline to re-eval.
                              " Setting `let &tabline=&tabline` destroys the cursor position so we
                              " need something less invasive.
                                let &ro = &ro
    2              0.000002   endif

FUNCTION  393()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim:163
Called 3 times
Total time:   0.000198
 Self time:   0.000072

count  total (s)   self (s)
    3   0.000186   0.000060 	call s:_finish()
    3              0.000011 	unlet! s:complete

FUNCTION  395()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/CursorMove.vim:18
Called 15 times
Total time:   0.005942
 Self time:   0.002212

count  total (s)   self (s)
   15   0.000701   0.000328 	if a:cmdline.is_input("\<Right>")
                            		call a:cmdline.line.next()
                            		call a:cmdline.setchar('')
   15   0.000519   0.000173 	elseif a:cmdline.is_input("\<Left>")
                            		call a:cmdline.line.prev()
                            		call a:cmdline.setchar('')
   15   0.000864   0.000220 	elseif a:cmdline.is_input("\<C-b>")		|| a:cmdline.is_input("\<Home>")
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
   15   0.000880   0.000190 	elseif a:cmdline.is_input("\<C-e>")		|| a:cmdline.is_input("\<End>")
                            		call a:cmdline.setline(a:cmdline.line.length())
                            		call a:cmdline.setchar('')
   15   0.001019   0.000265 	elseif a:cmdline.is_input("\<C-Left>")		|| a:cmdline.is_input("\<S-Left>")
                            		call a:cmdline.setline(strridx(a:cmdline.backward()[:-2], ' ') + 1)
                            		call a:cmdline.setchar('')
   15   0.001170   0.000247 	elseif a:cmdline.is_input("\<C-Right>")		|| a:cmdline.is_input("\<S-Right>")
                            		let p = stridx(a:cmdline.forward()[1:], ' ')
                            		call a:cmdline.setline(p != -1 ? a:cmdline.line.pos() + p + 2 : a:cmdline.line.length())
                            		call a:cmdline.setchar('')
   15              0.000021 	endif

FUNCTION  incsearch#cli#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:23
Called 3 times
Total time:   0.001297
 Self time:   0.000781

count  total (s)   self (s)
    3              0.000719   let cli = deepcopy(s:cli)
    3   0.000567   0.000051   call incsearch#cli#set(cli, a:config)
    3              0.000006   return cli

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Redraw#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:5
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000011     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>266__keymapping()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:49
Called 20 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
   20              0.000167 	return a:str =~ '^[!nvoicsxl]\s'

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 99 times
Total time:   0.005265
 Self time:   0.005265

count  total (s)   self (s)
   99              0.000429   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   99              0.000572   let bvars = getbufvar(buffer, '')
   99              0.000374   if empty(bvars)
                                let bvars = {}
   99              0.000200   endif
   99              0.000557   let dict = get(bvars, 'gitgutter', {})
   99              0.000448   let needs_setting = empty(dict)
   99              0.000701   let dict[a:varname] = a:val
   99              0.000815   if needs_setting
    3              0.000020     call setbufvar(buffer, 'gitgutter', dict)
   99              0.000142   endif

FUNCTION  <SNR>123_ExpireStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2416
Called 51 times
Total time:   0.011240
 Self time:   0.004281

count  total (s)   self (s)
   51              0.000280   if a:bufnr == -2
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
   51              0.000080   endif
   51   0.004259   0.000770   let dir = s:Dir(a:bufnr)
   51              0.000220   if len(dir)
   51   0.004659   0.001189     let s:last_times[s:cpath(dir)] = reltime()
   51              0.000393     if has_key(s:head_cache, dir)
   51              0.000538       call remove(s:head_cache, dir)
   51              0.000074     endif
   51              0.000074   endif
   51              0.000112   return ''

FUNCTION  ResCur()
    Defined: ~/.vimrc:531
Called 3 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    3              0.000015   if line("'\"") <= line("$")
    2              0.000068     normal! g`"
    2              0.000004     return 1
    1              0.000001   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:104
Called 33371 times
Total time:  17.325792
 Self time:   4.566578

count  total (s)   self (s)
33371              0.128142   if pumvisible()
                                return
33371              0.050900   endif
33371              0.114649   let colors = a:colors
33371              0.091823   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
33371              0.048860   endif
33371   9.376995   0.646084   let old_hi = airline#highlighter#get_highlight(a:group)
33371              0.128504   if len(colors) == 4
16625              0.079756     call add(colors, '')
33371              0.047809   endif
33371              0.101021   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
33371              0.049800   else
33371              0.426563     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
33371              0.051586   endif
33371   2.409055   0.515852   let colors = s:CheckDefined(colors)
33371   1.285299   0.538054   if old_hi != new_hi || !s:hl_group_exists(a:group)
 5898   1.492817   0.104962     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
 5898              0.108834     exe cmd
 5898              0.034735     if has_key(s:hl_groups, a:group)
 5898              0.031647       let s:hl_groups[a:group] = colors
 5898              0.008915     endif
33371              0.046161   endif

FUNCTION  vista#OnExecute()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:41
Called 1 time
Total time:   0.000484
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000064   0.000011   call vista#SetProvider(a:provider)
    1   0.000419   0.000026   call vista#autocmd#Init('Vista'.vista#util#ToCamelCase(a:provider), a:AUF)

FUNCTION  <SNR>254_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionExit.vim:24
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000005 	let result = deepcopy(s:module)
    1              0.000006 	let result.exit_code = get(a:, 1, 0)
    1              0.000002 	return result

FUNCTION  vital#_incsearch#Over#Commandline#Modules#LiteralInsert#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/LiteralInsert.vim:7
Called 1 time
Total time:   0.000027
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000027   0.000021 return map({'make': ''}, "vital#_incsearch#function('<SNR>255_' . v:key)")

FUNCTION  riv#insert#fixed_col()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/insert.vim:66
Called 6 times
Total time:   0.004747
 Self time:   0.001342

count  total (s)   self (s)
                            
                                " s:f_cols: store fixed columns of current line
                                "
                                " return with fix indentation with row col and direction
                                " context is the item with smaller indentation (parent)
                                " find all possible context of current row
                                
                                " using the stored fixing info
    6              0.000039     if s:f_row == a:row && s:f_buf == bufnr('%')
    3   0.000412   0.000036         return riv#ptn#fix_sfts(a:col, s:f_cols, a:sft)
    3              0.000004     endif
                            
    3              0.000022     let pnb_row = prevnonblank(a:row - 1)
    3              0.000019     if pnb_row == 0 | return a:col + a:sft | endif
                            
    3              0.000017     let f_idts = [indent(pnb_row)+1]
                            
                            
    3   0.000339   0.000052     let blk_row = riv#ptn#get(g:_riv_p.literal_block, a:row)
    3              0.000007     if blk_row
    3              0.000033         let f_idts += [indent(blk_row)+1+&sw]
    3              0.000004     endif
                            
    3   0.002685   0.000730     let lst_row = riv#list#get_all_list(a:row)
                            
    3              0.000007     if lst_row 
    1              0.000005         let lst_idt = indent(lst_row)+1
    1   0.000042   0.000014         let lst_cdt = riv#list#get_con_idt(getline(lst_row))
    1              0.000004         let f_idts += [lst_idt,lst_cdt]
    1   0.000116   0.000011         let par_row = riv#list#get_parent(lst_row)
    1              0.000002         if par_row
                                        let par_idt = indent(par_row)+1
                                        let par_cdt = riv#list#get_con_idt(getline(par_row))
                                        let f_idts += [par_idt, par_cdt]
    1              0.000001         endif
    2              0.000004     else
    2   0.000267   0.000047         let exp_row = riv#ptn#get(g:_riv_p.exp_mark, a:row)
    2   0.000061   0.000037         let exp_cdt = riv#ptn#exp_con_idt(getline(exp_row))
                            
                            
    2              0.000010         let f_idts += [exp_cdt]
    3              0.000004     endif
                            
                            
    3              0.000012     let s:f_cols = f_idts
    3              0.000008     let s:f_row = a:row
    3              0.000018     let s:f_buf = bufnr('%')
                            
    3   0.000452   0.000042     return riv#ptn#fix_sfts(a:col, f_idts, a:sft)
                                

FUNCTION  vital#_incsearch#function()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch.vim:7
Called 278 times
Total time:   0.001907
 Self time:   0.001907

count  total (s)   self (s)
  278              0.001785   silent! return function(a:funcname)

FUNCTION  <SNR>103_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:22
Called 17052 times
Total time:   0.239644
 Self time:   0.239644

count  total (s)   self (s)
17052              0.225045   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>262_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionMessage.vim:51
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000009 	let result = deepcopy(s:module)
    1              0.000012 	let result.prefix = get(a:, 1, "vital-over(".s:vname.") Exception")
    1              0.000007 	let result.command = get(a:, 2, "echom")
    1              0.000003 	return result

FUNCTION  <SNR>157_ApplyAppend()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:52
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003   let line = a:line
    1              0.000002   let rows = a:rows
                            
    1              0.000004   call add(rows, a:row)
    1              0.000004   call add(s:vlnum_cache, line)

FUNCTION  630()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 1 time
Total time:   0.000227
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000089   0.000006     let group = self.get_group(a:i)
    1   0.000086   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000005     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
    1              0.000002     endif
                            
    1              0.000006     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
    1              0.000002     else
    1              0.000007       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>136_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:502
Called 27014 times
Total time:   3.814862
 Self time:   0.600028

count  total (s)   self (s)
27014   3.798754   0.583920   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  vital#_incsearch#Coaster#Window#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Window.vim:7
Called 1 time
Total time:   0.000088
 Self time:   0.000062

count  total (s)   self (s)
    1   0.000087   0.000061 return map({'as_windo': '', '_vital_depends': '', 'windo': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>276_' . v:key)")

FUNCTION  <SNR>97_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:177
Called 16 times
Total time:   0.225260
 Self time:   0.001768

count  total (s)   self (s)
   16   0.001102   0.000368   let builder = airline#builder#new(a:context)
   16   0.042832   0.000439   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   16              0.000038   if err == 1
   16   0.180632   0.000267     let a:context.line = builder.build()
   16              0.000130     let s:contexts[a:context.winnr] = a:context
   16              0.000202     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   16              0.000267     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   16              0.000025   endif

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:57
Called 17276 times
Total time:   5.717670
 Self time:   4.488121

count  total (s)   self (s)
17276              0.146776   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
17276              0.199072   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
  224              0.000669     return ''
17052              0.025865   endif
17052              0.216412   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
17052              0.130376   if !exists('b:airline_whitespace_check')
   50              0.000438     let b:airline_whitespace_check = ''
   50              0.000723     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
   50              0.000159     let trailing = 0
   50              0.000150     let check = 'trailing'
   50              0.001132     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   50              0.000097       try
   50              0.000390         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
   50              0.052601         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
   50              0.000108       endtry
   50              0.000078     endif
                            
   50              0.000155     let mixed = 0
   50              0.000137     let check = 'indent'
   50              0.001029     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   50   0.152767   0.001153       let mixed = s:check_mixed_indent()
   50              0.000244     endif
                            
   50              0.000233     let mixed_file = ''
   50              0.000184     let check = 'mixed-indent-file'
   50              0.001303     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   50   0.036622   0.004949       let mixed_file = s:check_mixed_indent_file()
   50              0.000078     endif
                            
   50              0.000127     let long = 0
   50              0.000288     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
   50              0.000070     endif
                            
   50              0.000136     let conflicts = 0
   50              0.000320     if index(checks, 'conflicts') > -1
   50   0.016190   0.001050       let conflicts = s:conflict_marker()
   50              0.000105     endif
                            
   50              0.000433     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
   15              0.000084       let b:airline_whitespace_check = s:symbol
   15              0.000063       if strlen(s:symbol) > 0
   15              0.000065         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
   15              0.000020       endif
                            
   15              0.000061       if s:show_message
   15              0.000032         if trailing != 0
   15              0.000132           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
   15              0.000236           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
   15              0.000027         endif
   15              0.000032         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
   15              0.000023         endif
   15              0.000029         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
   15              0.000021         endif
   15              0.000063         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
   15              0.000017         endif
   15              0.000037         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
   15              0.000020         endif
   15              0.000022       endif
   50              0.000073     endif
17052              0.027073   endif
17052   1.333002   0.301880   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>258_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/InsertRegister.vim:153
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  vital#_incsearch#Over#Commandline#Modules#KeyMapping#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:7
Called 1 time
Total time:   0.000105
 Self time:   0.000072

count  total (s)   self (s)
    1   0.000103   0.000070 return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>265_' . v:key)")

FUNCTION  <SNR>151_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 24 times
Total time:   0.000520
 Self time:   0.000520

count  total (s)   self (s)
   24              0.000249   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
   24              0.000050   endif
                            
   24              0.000072   return a:modified_lines

FUNCTION  <SNR>139_EchoInCmdline()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:137
Called 1 time
Total time:   0.000581
 Self time:   0.000317

count  total (s)   self (s)
    1              0.000006   let [msg, tag] = [a:msg, a:tag]
                            
                              " Case II:\@ $R^2 \geq Q^3$ : Ôäú paragraph:175
    1              0.000002   try
    1              0.000015     let [_, start, end] = matchstrpos(msg, '\C'.tag)
                            
                                " If couldn't find the tag in the msg
    1              0.000003     if start == -1
                                  echohl Function | echo msg | echohl NONE
                                  return
    1              0.000001     endif
                            
                              catch /^Vim\%((\a\+)\)\=:E869/
                            
                                echohl Function | echo msg | echohl NONE
                                return
                            
    1              0.000001   endtry
                            
    1              0.000003   let echoed_scope = v:false
                            
    1              0.000005   if has_key(t:vista, 'vlnum_cache')
                                " should exclude the first two lines and keep in mind that the 1-based and
                                " 0-based.
                                " This is really error prone.
    1              0.000007     let tagline = get(t:vista.vlnum_cache, line('.') - 3, '')
    1              0.000003     if !empty(tagline)
    1              0.000004       if has_key(tagline, 'scope')
    1   0.000279   0.000015         call s:EchoScope(tagline.scope)
                                  else
                                    call s:EchoScope(tagline.kind)
    1              0.000002       endif
    1              0.000006       let echoed_scope = v:true
    1              0.000001     endif
    1              0.000001   endif
                            
                              " Try highlighting the scope of current tag
    1              0.000003   if !echoed_scope
                                let linenr = vista#util#LowerIndentLineNr()
                            
                                " Echo the scope of current tag if found
                                if linenr != 0
                                  let scope = matchstr(getline(linenr), '\a\+$')
                                  if !empty(scope)
                                    call s:EchoScope(scope)
                                  else
                                    " For the kind renderer
                                    let pieces = split(getline(linenr), ' ')
                                    if len(pieces) > 1
                                      let scope = pieces[1]
                                      call s:EchoScope(scope)
                                    endif
                                  endif
                                endif
    1              0.000001   endif
                            
                              " if start is 0, msg[0:-1] will display the redundant whole msg.
    1              0.000003   if start != 0
                                echohl Statement | echon msg[0 : start-1] | echohl NONE
    1              0.000001   endif
                            
    1              0.000092   echohl Search    | echon msg[start : end-1] | echohl NONE
    1              0.000045   echohl Statement | echon msg[end : ]        | echohl NONE

FUNCTION  incsearch#detect_case()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:297
Called 15 times
Total time:   0.001591
 Self time:   0.001591

count  total (s)   self (s)
                              " Ignore \%C, \%U, \%V for smartcase detection
   15              0.000813   let p = substitute(a:pattern, s:non_escaped_backslash . '%[CUV]', '', 'g')
                              " Explicit \c has highest priority
   15              0.000269   if p =~# s:non_escaped_backslash . 'c'
                                return '\c'
   15              0.000025   endif
   15              0.000228   if p =~# s:non_escaped_backslash . 'C' || &ignorecase == s:FALSE
                                return '\C' " noignorecase or explicit \C
   15              0.000024   endif
   15              0.000059   if &smartcase == s:FALSE
   15              0.000034     return '\c' " ignorecase & nosmartcase
                              endif
                              " Find uppercase letter which isn't escaped
                              if p =~# s:escaped_backslash . '[A-Z]'
                                return '\C' " smartcase with [A-Z]
                              else
                                return '\c' " smartcase without [A-Z]
                              endif

FUNCTION  ale#engine#Cleanup()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:707
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
    2              0.000017     if get(v:, 'exiting', v:null) isnot v:null
                                    return
    2              0.000003     endif
                            
    2              0.000011     if exists('*ale#lsp#CloseDocument')
                                    call ale#lsp#CloseDocument(a:buffer)
    2              0.000003     endif
                            
    2              0.000014     if !has_key(g:ale_buffer_info, a:buffer)
    2              0.000003         return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>101_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 16612 times
Total time:  20.098362
 Self time:   1.804582

count  total (s)   self (s)
16612              0.077583   if pumvisible()
                                return
16612              0.024211   endif
16612              0.103520   let group = a:from.'_to_'.a:to.a:suffix
16612   5.668684   0.308006   let l:from = airline#themes#get_highlight(a:from.a:suffix)
16612   4.992742   0.317298   let l:to = airline#themes#get_highlight(a:to.a:suffix)
16612              0.042994   if a:inverse
 7121              0.080256     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
 9491              0.014048   else
 9491              0.104317     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
16612              0.025254   endif
16612              0.109324   let a:dict[group] = colors
16612   8.690008   0.432350   call airline#highlighter#exec(group, colors)

FUNCTION  vital#_easymotion#Over#Commandline#Base#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:5
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000048     return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>232_is_visual()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:69
Called 48 times
Total time:   0.000453
 Self time:   0.000453

count  total (s)   self (s)
   48              0.000417   return a:mode =~# "[vV\<C-v>]"

FUNCTION  <SNR>201_call()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:67
Called 44 times
Total time:   0.974000
 Self time:   0.007248

count  total (s)   self (s)
   44              0.000352 	let args = get(a:, 1, [])
   44              0.000284 	let def = get(a:, 2, 0)
   44   0.973305   0.006553 	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")

FUNCTION  <SNR>145_on_exit_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:87
Called 50 times
Total time:   0.012626
 Self time:   0.003466

count  total (s)   self (s)
   50              0.000389   let buf=self.buf
   50   0.010881   0.001721   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
   50              0.000581   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
   50              0.000453     call remove(s:clean_jobs[self.vcs], self.file)
   50              0.000094   endif

FUNCTION  447()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/pattern_saver.vim:17
Called 3 times
Total time:   0.000111
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000010   if ! g:incsearch#no_inc_hlsearch
    3              0.000010     let self.pattern = @/
    3              0.000009     let self.hlsearch = &hlsearch
    3              0.000015     if exists('v:hlsearch')
    3              0.000013       let self.vhlsearch = v:hlsearch
    3              0.000004     endif
    3   0.000039   0.000033     set hlsearch | nohlsearch
    3              0.000004   endif

FUNCTION  <SNR>267__verbosefile_push()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Capture.vim:17
Called 3 times
Total time:   0.000143
 Self time:   0.000137

count  total (s)   self (s)
    3              0.000018 	call add(s:verbosefiles, &verbosefile)
    3   0.000115   0.000109 	let &verbosefile = a:file
    3              0.000010 	return a:file

FUNCTION  <SNR>240__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:15
Called 1 time
Total time:   0.002549
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.002546   0.000015 	let s:List = s:V.import("Data.List")

FUNCTION  vista#sidebar#Close()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:86
Called 1 time
Total time:   0.041295
 Self time:   0.001613

count  total (s)   self (s)
    1              0.000013   if exists('t:vista.bufnr')
    1   0.000092   0.000019     let winnr = t:vista.winnr()
    1              0.000008     if winnr != -1
    1              0.000654       noautocmd execute winnr.'wincmd c'
    1              0.000009     endif
                            
                                " Jump back to the previous window if we are in the vista sidebar atm.
    1              0.000018     if winnr == winnr()
                                  wincmd p
    1              0.000004     endif
                            
    1   0.039663   0.000744     silent execute  t:vista.bufnr.'bwipe!'
    1              0.000021     unlet t:vista.bufnr
    1              0.000003   endif
                            
    1   0.000648   0.000077   call s:ClearAugroups('VistaCoc', 'VistaCtags')
                            
    1   0.000143   0.000024   call vista#GenericCloseOverlay()

FUNCTION  <SNR>146_StopCurrentJobs()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:547
Called 474 times
Total time:   0.059422
 Self time:   0.030721

count  total (s)   self (s)
  474              0.004760     let l:info = get(g:ale_buffer_info, a:buffer, {})
  474   0.036963   0.010624     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
  474              0.002373     if a:clear_lint_file_jobs
   50   0.003169   0.000807         call ale#command#StopJobs(a:buffer, 'file_linter')
   50              0.000271         let l:info.active_linter_list = []
  424              0.000833     else
                                    " Keep jobs for linting files when we're only linting buffers.
  424              0.005122         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
  474              0.000771     endif

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2477
Called 51 times
Total time:   0.015965
 Self time:   0.004151

count  total (s)   self (s)
   51   0.012281   0.001041   call s:ExpireStatus(a:0 ? a:1 : -1)
   51              0.000165   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
   51              0.000071   else
   51   0.001620   0.001046     call s:ReloadWinStatus()
   51              0.000078   endif
   51              0.000154   return ''

FUNCTION  vital#_incsearch#Over#Commandline#Modules#ExceptionExit#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionExit.vim:7
Called 1 time
Total time:   0.000028
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000027   0.000021 return map({'make': ''}, "vital#_incsearch#function('<SNR>254_' . v:key)")

FUNCTION  <SNR>198_is_input_waiting()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:497
Called 8 times
Total time:   0.000743
 Self time:   0.000743

count  total (s)   self (s)
    8              0.000668 	let num = len(filter(copy(a:keymapping), 'stridx(v:key, a:input) == 0'))
    8              0.000068 	return num > 1 || (num == 1 && !has_key(a:keymapping, a:input))

FUNCTION  <SNR>129_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:405
Called 24 times
Total time:   0.001588
 Self time:   0.000577

count  total (s)   self (s)
   24   0.001546   0.000535   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>122_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 128 times
Total time:   0.014437
 Self time:   0.011114

count  total (s)   self (s)
  128              0.000879   if has_key(s:section_truncate_width, a:key)
   87   0.003983   0.001584     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   21              0.000071       return ''
   66              0.000120     endif
  107              0.000160   endif
  107              0.000518   let spc = g:airline_symbols.space
  107              0.001156   if !exists('g:airline_section_{a:key}')
                                return ''
  107              0.000200   endif
  107   0.003545   0.002621   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  107              0.001647   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  107              0.000767   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>194_CreateCoordKeyDict()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:927
Called 1 time
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
                                " Dict structure:
                                " 1,2 : a
                                " 2,3 : b
    1              0.000002     let sort_list = []
    1              0.000002     let coord_keys = {}
    1              0.000003     let group_key = a:0 == 1 ? a:1 : ''
                            
    3              0.000011     for [key, item] in items(a:groups)
    2              0.000006         let key = group_key . key
                                    "let key = ( ! empty(group_key) ? group_key : key)
                            
    2              0.000007         if type(item) == type([]) " List
                                        " Destination coords
                            
                                        " The key needs to be zero-padded in order to
                                        " sort correctly
    2              0.000015             let dict_key = printf('%05d,%05d', item[0], item[1])
    2              0.000007             let coord_keys[dict_key] = key
                            
                                        " We need a sorting list to loop correctly in
                                        " PromptUser, dicts are unsorted
    2              0.000009             call add(sort_list, dict_key)
                                    else
                                        " Item is a dict (has children)
                                        let coord_key_dict = s:CreateCoordKeyDict(item, key)
                            
                                        " Make sure to extend both the sort list and the
                                        " coord key dict
                                        call extend(sort_list, coord_key_dict[0])
                                        call extend(coord_keys, coord_key_dict[1])
    2              0.000002         endif
                            
    2              0.000003         unlet item
    3              0.000007     endfor
                            
    1              0.000003     return [sort_list, coord_keys]

FUNCTION  vital#_easymotion#Over#Commandline#Modules#NoInsert#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:5
Called 1 time
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000093     return map({'make_special_chars': '', 'make': ''},  'function("s:" . v:key)')

FUNCTION  riv#path#is_rel_to()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:102
Called 51 times
Total time:   0.003738
 Self time:   0.002853

count  total (s)   self (s)
                                " check if path is relatetive to dir
                                "
   51   0.001915   0.001030     let dir = riv#path#is_directory(a:dir) ? a:dir : a:dir.'/'
   51              0.000513     let dir = fnamemodify(dir, ':gs?\?/?') 
   51              0.000470     let path = fnamemodify(a:path, ':gs?\?/?') 
   51              0.000606     if match(path, dir) == -1
   51              0.000098         return 0
                                else
                                    return 1
                                endif

FUNCTION  <SNR>235_import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:53
Called 50 times
Total time:   0.132313
 Self time:   0.002692

count  total (s)   self (s)
   50              0.000185   let target = {}
   50              0.000126   let functions = []
   50              0.000162   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
   50              0.000096   endfor
   50   0.047114   0.025447   let module = self._import(a:name)
   50              0.000167   if empty(functions)
   50              0.000494     call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
   50              0.000067   endif
   50              0.000108   return target

FUNCTION  <SNR>282_uniq_winnr()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift.vim:70
Called 357 times
Total time:   0.018274
 Self time:   0.005699

count  total (s)   self (s)
  357   0.018127   0.005552 	return call(s:Window.uniq_nr, a:000, s:Window)

FUNCTION  <SNR>111_update_wordcount()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:66
Called 9852 times
Total time:   2.981013
 Self time:   0.373839

count  total (s)   self (s)
 9852   2.611347   0.164631   let wordcount = s:get_wordcount(0)
 9852              0.063371   if wordcount != s:wordcount_cache || a:force_update
 1250              0.005775     let s:wordcount_cache = wordcount
 1250   0.190425   0.029967     let b:airline_wordcount =  s:format_wordcount(wordcount)
 9852              0.016217   endif

FUNCTION  <SNR>253__redraw()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:50
Called 14 times
Total time:   0.935032
 Self time:   0.934483

count  total (s)   self (s)
   14   0.000565   0.000283 	let left = a:cmdline.get_prompt() . a:cmdline.getline() . (empty(a:cmdline.line.pos_char()) ? " " : "")
   14              0.000070 	let width = len(left) + 1
                            
   14   0.000151   0.000111 	if a:cmdline.get_suffix() != ""
                            		let width += len(s:suffix(left, a:cmdline.get_suffix())) - 1
   14              0.000021 	endif
                            
   14              0.000085 	if &columns >= width && &columns <= s:old_width && s:old_width >= width
                            		redraw
                            		normal! :
   14              0.000032 	elseif &columns <= width
                            		normal! :
   14              0.000016 	else
   14              0.932563 		redraw
   14              0.000051 	endif
   14              0.000144 	let s:old_width = width
                            
   14   0.000473   0.000294 	call s:cmdheight.save()
   14   0.000347   0.000299 	let height = max([(width - 1) / (&columns) + 1, s:cmdheight.get()])
   14              0.000055 	if height > &cmdheight || &cmdheight > height
                            		let &cmdheight = height
                            		redraw
   14              0.000021 	endif

FUNCTION  <SNR>203__get_key()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:66
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            " 	call extend(l:, a:conf)
    2              0.000005 	let self = a:conf
    2              0.000015 	return get(a:conf, "expr", 0) ? s:_safe_eval(a:conf.key, l:) : a:conf.key

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 17056 times
Total time:   0.904260
 Self time:   0.904260

count  total (s)   self (s)
17056              0.353382   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
17056              0.073169   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
17056              0.023950   endif
17056              0.033000   return ''

FUNCTION  <SNR>132_ApplyRunAsync()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:193
Called 1 time
Total time:   0.000796
 Self time:   0.000772

count  total (s)   self (s)
    1   0.000714   0.000690     let job = job_start(s:WrapCmd(a:cmd), { 'close_cb':function('s:close_cb') })
    1              0.000067     let jobid = matchstr(job, '\d\+') + 0
    1              0.000009     return jobid > 0 ? jobid : 0

FUNCTION  400()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:20
Called 14 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   14              0.000116 	if has_key(self, "value")
   11              0.000022 		return
    3              0.000005 	endif
    3              0.000013 	let self.value = &cmdheight

FUNCTION  401()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:27
Called 6 times
Total time:   0.000136
 Self time:   0.000127

count  total (s)   self (s)
    6              0.000030 	if has_key(self, "value")
    3   0.000061   0.000052 		let &cmdheight = self.value
    3              0.000007 		unlet self.value
    6              0.000011 	endif

FUNCTION  vista#renderer#RenderAndDisplay()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer.vim:87
Called 1 time
Total time:   0.191953
 Self time:   0.000033

count  total (s)   self (s)
    1   0.191952   0.000032   call vista#sidebar#OpenOrUpdate(s:Render(a:data))

FUNCTION  404()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:112
Called 14 times
Total time:   0.001360
 Self time:   0.001360

count  total (s)   self (s)
   14              0.001244 	execute self.draw_command
                            " 	execute "echohl" a:cmdline.highlights.prompt
                            " 	call s:echon(a:cmdline.get_prompt())
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.backward())
                            " 	if empty(a:cmdline.line.pos_char())
                            " 		execute "echohl" a:cmdline.highlights.cursor
                            " 		call s:echon(' ')
                            " 	else
                            " 		execute "echohl" a:cmdline.highlights.cursor_on
                            " 		call s:echon(a:cmdline.line.pos_char())
                            " 	endif
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.forward())
                            " 	if	a:cmdline.get_suffix() != ""
                            " 		call s:echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            " 	endif

FUNCTION  406()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:138
Called 3 times
Total time:   0.000132
 Self time:   0.000034

count  total (s)   self (s)
    3   0.000132   0.000034 	call s:cmdheight.restore()

FUNCTION  408()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/LiteralInsert.vim:19
Called 15 times
Total time:   0.001331
 Self time:   0.000687

count  total (s)   self (s)
   15   0.000853   0.000209 	if a:cmdline.is_input("\<C-v>")	|| a:cmdline.is_input("\<C-q>")
                            		let old_line = a:cmdline.getline()
                            		let old_pos  = a:cmdline.getpos()
                            		call a:cmdline.insert('^')
                            		call a:cmdline.setpos(old_pos)
                            		call a:cmdline.draw()
                            		let char = a:cmdline.getchar()
                            		call a:cmdline.setline(old_line)
                            		call a:cmdline.setpos(old_pos)
                            		call a:cmdline.setchar(char)
   15              0.000022 	endif

FUNCTION  <SNR>147_BufferCacheExists()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:88
Called 34552 times
Total time:   0.615096
 Self time:   0.615096

count  total (s)   self (s)
34552              0.372054     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
  692              0.002470         return 0
33860              0.052693     endif
                            
33860              0.062368     return 1

FUNCTION  189()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:143
Called 8 times
Total time:   0.000659
 Self time:   0.000400

count  total (s)   self (s)
    8   0.000341   0.000082 	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
    8              0.000013 	else
    8              0.000041 		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
    8              0.000028 		endif
    8              0.000013 	endif

FUNCTION  vital#_incsearch#Gift#Window#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Window.vim:7
Called 1 time
Total time:   0.000397
 Self time:   0.000267

count  total (s)   self (s)
    1   0.000397   0.000267 return map({'flatten': '', 'tabpagewinnr_list': '', 'execute': '', 'close': '', 'numbering': '', 'set_prefix': '', '_vital_depends': '', 'exists': '', 'jump': '', 'setvar': '', 'bufnr': '', 'uniq_nr': '', 'make_uniq_nr': '', 'tabpagewinnr': '', 'getvar': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>283_' . v:key)")

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:10
Called 9 times
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
    9              0.000112   if &buftype == 'terminal' || bufname('%')[0] == '!'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.s:section_a.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
    9              0.000014   endif

FUNCTION  <SNR>146_RunLinter()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:656
Called 2894 times
Total time:   1.613187
 Self time:   0.151797

count  total (s)   self (s)
 2894              0.016110     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
 2894              0.004624     else
 2894   0.663175   0.053658         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
 2894   0.909741   0.057868         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:429
Called 476 times
Total time:   0.071645
 Self time:   0.017157

count  total (s)   self (s)
  476   0.065899   0.011411     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
  476              0.003188     if type(l:filetype) isnot v:t_list
  476              0.001719         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>136_OnBufferUnload()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:622
Called 4 times
Total time:   0.008247
 Self time:   0.007666

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    4              0.000037   let buffer_number = str2nr( expand( '<abuf>' ) )
    4   0.000684   0.000103   if !s:AllowedToCompleteInBuffer( buffer_number )
    2              0.000006     return
    2              0.000002   endif
                            
    2              0.007501   exec s:python_command "ycm_state.OnBufferUnload( " . buffer_number . " )"

FUNCTION  airline#extensions#tabline#buflist#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:6
Called 13 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
   13              0.000058   unlet! s:current_buffer_list

FUNCTION  196()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:40
Called 2 times
Total time:   0.000062
 Self time:   0.000037

count  total (s)   self (s)
    2   0.000061   0.000036 	call s:_reset()

FUNCTION  197()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:44
Called 8 times
Total time:   0.001208
 Self time:   0.000404

count  total (s)   self (s)
    8   0.000981   0.000275 	if !a:cmdline.is_input("\<Up>") && !a:cmdline.is_input("\<Down>")	&& !a:cmdline.is_input("\<C-p>") && !a:cmdline.is_input("\<C-n>")
    8   0.000204   0.000106 		call s:_reset()
    8              0.000011 		return
                            	else
                            		if s:count == 0 && empty(s:cmdhist)	|| s:is_match_mode != s:_should_match_cmdline(a:cmdline)
                            			let cmdline = '^' . a:cmdline.getline()
                            			let s:is_match_mode = s:_should_match_cmdline(a:cmdline)
                            			let s:cmdhist = [a:cmdline.getline()] + (s:is_match_mode ?	filter(self.histories(), 'v:val =~ cmdline') : self.histories())
                            		endif
                            	endif
                            	call a:cmdline.setchar("")
                            	if a:cmdline.is_input("\<Down>") || a:cmdline.is_input("\<C-n>")
                            		let s:count = max([s:count - 1, 0])
                            	endif
                            	if a:cmdline.is_input("\<Up>") || a:cmdline.is_input("\<C-p>")
                            		let s:count = min([s:count + 1, len(s:cmdhist)])
                            	endif
                            	call a:cmdline.setline(get(s:cmdhist, s:count, a:cmdline.getline()))

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:234
Called 50 times
Total time:   0.149343
 Self time:   0.012495

count  total (s)   self (s)
   50   0.002224   0.001107     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
   50              0.000140     if g:ale_set_signs
   50   0.045989   0.001382         call ale#sign#SetSigns(a:buffer, a:loclist)
   50              0.000070     endif
                            
   50              0.000204     if g:ale_set_quickfix || g:ale_set_loclist
   50   0.044567   0.001129         call ale#list#SetLists(a:buffer, a:loclist)
   50              0.000056     endif
                            
   50              0.000264     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
   50   0.009756   0.000853         call ale#statusline#Update(a:buffer, a:loclist)
   50              0.000066     endif
                            
   50              0.000148     if g:ale_set_highlights
   50   0.014398   0.001473         call ale#highlight#SetHighlights(a:buffer, a:loclist)
   50              0.000117     endif
                            
   50              0.000149     if l:linting_is_done
   50              0.000119         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
   50   0.021317   0.000923             call ale#cursor#EchoCursorWarning()
   50              0.000058         endif
                            
   50              0.000126         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
   50              0.000064         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
   50              0.000447         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
   50              0.000556         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
   50   0.003438   0.000895         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
   50   0.003969   0.001048         silent doautocmd <nomodeline> User ALELintPost
   50              0.000070     endif

FUNCTION  <SNR>157_RenderDescendants()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:146
Called 1 time
Total time:   0.000701
 Self time:   0.000206

count  total (s)   self (s)
    1              0.000004   let depth = a:depth
    1              0.000002   let rows = a:rows
                            
                              " Clear the previous duplicate parent line that is about to be added.
                              "
                              " This is a little bit stupid actually :(.
    1   0.000117   0.000013   let about_to_append = s:Assemble(a:parent_line, depth)
    1              0.000002   let idx = 0
    1              0.000004   while idx < len(rows)
                                if rows[idx] ==# about_to_append
                                  unlet rows[idx]
                                  unlet s:vlnum_cache[idx]
                                endif
                                let idx += 1
    1              0.000001   endwhile
                            
                              " Append the root actually
    1   0.000028   0.000014   call s:ApplyAppend(a:parent_line, about_to_append, rows)
                            
    1              0.000003   let depth += 1
                            
                              " find all the children
    1              0.000010   let children = filter(copy(a:descendants), 'v:val.scope ==# a:parent_name')
                            
    1              0.000002   let grandchildren = []
    1              0.000003   let grandchildren_line = []
                            
    2              0.000005   for child in children
    1   0.000166   0.000016     let [next_potentioal_root, next_potentioal_root_line] = s:AppendChild(child, rows, depth)
    1              0.000004     if !empty(next_potentioal_root)
    1              0.000005       call add(grandchildren, next_potentioal_root)
    1              0.000005       call add(grandchildren_line, next_potentioal_root_line)
    1              0.000001     endif
    2              0.000003   endfor
                            
    1              0.000002   let idx = 0
    2              0.000007   while idx < len(grandchildren)
    1              0.000005     let child_name = grandchildren[idx]
    1              0.000004     let child_line = grandchildren_line[idx]
                            
    1   0.000243   0.000016     let descendants = s:DescendantsOf(t:vista.with_scope, child_line, child_name)
                            
    1              0.000003     if !empty(descendants)
                                  call s:RenderDescendants(child_name, child_line, descendants, a:rows, depth)
    1              0.000002     endif
                            
    1              0.000003     let idx += 1
    2              0.000004   endwhile

FUNCTION  <SNR>194_handleEmpty()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:742
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                                " if empty, reselect and return 1
    2              0.000008     if empty(a:input)
                                    if ! empty(a:visualmode)
                                        silent exec 'normal! gv'
                                    endif
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                    return 1
    2              0.000002     endif
    2              0.000004     return 0

FUNCTION  <SNR>164_IsCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:71
Called 10 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
   10              0.000083     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  vital#_easymotion#Over#Commandline#Modules#KeyMapping#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:5
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000041     return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  412()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/InsertRegister.vim:92
Called 15 times
Total time:   0.001852
 Self time:   0.001506

count  total (s)   self (s)
   15   0.000470   0.000124 	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.setchar('"')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
   15              0.000158 	elseif exists("self.prefix_key")		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let char = a:cmdline.input_key()
                            		if char =~ '^[0-9a-zA-z.%#:/"\-*+]$'
                            			let register = tr(getreg(char), "\n", "\r")
                            			call a:cmdline.setchar(register)
                            		elseif char == "="
                            			call a:cmdline.setchar(s:input(a:cmdline))
                            		elseif char == "\<C-w>"
                            			call a:cmdline.setchar(s:get_cmdline_cword(a:cmdline.backward_word(), self.cword))
                            		elseif char == "\<C-a>"
                            			call a:cmdline.setchar(self.cWORD)
                            		elseif char == "\<C-f>"
                            			call a:cmdline.setchar(self.cfile)
                            		elseif char == "\<C-r>"
                            			call a:cmdline.setchar('"')
                            		else
                            			call a:cmdline.setchar("")
                            		endif
                            " 		elseif a:cmdline.is_input('=', self.prefix_key)
                            " 			call a:cmdline.setchar(s:input(a:cmdline))
                            " 		elseif a:cmdline.is_input("\<C-w>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cword)
                            " 		elseif a:cmdline.is_input("\<C-a>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cWORD)
                            " 		elseif a:cmdline.is_input("\<C-f>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cfile)
                            " 		elseif a:cmdline.is_input("\<C-r>", self.prefix_key)
                            " 			call a:cmdline.setchar('"')
                            " 		else
                            " 			call a:cmdline.setchar("")
                            " 		endif
   15              0.000020 	endif

FUNCTION  413()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/InsertRegister.vim:137
Called 15 times
Total time:   0.000888
 Self time:   0.000560

count  total (s)   self (s)
   15   0.000438   0.000110 	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
   15              0.000021 	else
   15              0.000061 		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
   15              0.000019 		endif
   15              0.000020 	endif

FUNCTION  414()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/insert_register.vim:16
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    3              0.000013   let self.search_register = @/

FUNCTION  416()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Paste.vim:19
Called 15 times
Total time:   0.000636
 Self time:   0.000302

count  total (s)   self (s)
   15   0.000444   0.000110 	if a:cmdline.is_input("<Over>(paste)")
                            		let register = v:register == "" ? '"' : v:register
                            		call a:cmdline.insert(tr(getreg("*"), "\n", "\r"))
                            		call a:cmdline.setchar('')
   15              0.000020 	endif

FUNCTION  417()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 3 times
Total time:   0.000492
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000017 	let s:cmdline = a:cmdline
    3   0.000469   0.000056 	call s:doautocmd_user(self.prefix, self.prefix . 'Enter')

FUNCTION  <SNR>244_unmapping()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim:67
Called 23 times
Total time:   0.006095
 Self time:   0.001275

count  total (s)   self (s)
   23              0.000140 	let is_locking = get(a:, 1, 0)
   23   0.001688   0.000321 	let key = s:match_key(a:keymapping, a:key)
   23              0.000072 	if key == ""
   17   0.001656   0.000365 		return s:String.length(a:key) <= 1 ? a:key : s:unmapping(a:keymapping, a:key[0], is_locking) . s:unmapping(a:keymapping, a:key[1:], is_locking)
    6              0.000009 	endif
                            
    6   0.000237   0.000111 	let map_conf = s:as_key_config(a:keymapping[key])
                            
    6              0.000068 	let next_input = s:unmapping(a:keymapping, a:key[len(key) : ], is_locking)
    6              0.000019 	if map_conf.lock == 0 && is_locking
    3              0.000007 		return key . next_input
    3              0.000007 	elseif map_conf.lock
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), is_locking) . next_input
    3              0.000003 	else
    3   0.000080   0.000047 		return s:unmapping(a:keymapping, s:_get_key(map_conf), map_conf.noremap) . next_input
                            	endif

FUNCTION  <SNR>136_OnInsertChar()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:713
Called 8722 times
Total time:   1.987971
 Self time:   0.602859

count  total (s)   self (s)
 8722   1.440952   0.199943   if !s:AllowedToCompleteInCurrentBuffer()
                                return
 8722              0.012477   endif
                            
 8722              0.116911   call timer_stop( s:pollers.completion.id )
 8722   0.317519   0.173416   call s:CloseCompletionMenu()
                            
                              " TODO: Do we really need this here?
 8722              0.056441   call timer_stop( s:pollers.signature_help.id )

FUNCTION  <SNR>239__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:15
Called 1 time
Total time:   0.010058
 Self time:   0.000090

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.003711   0.000008 	let s:String  = s:V.import("Over.String")
    1   0.001250   0.000013 	let s:Signals = s:V.import("Over.Signals")
    1   0.000780   0.000013 	let s:Input = s:V.import("Over.Input")
    1   0.001240   0.000011 	let s:Keymapping = s:V.import("Over.Keymapping")
    1   0.000944   0.000012 	let s:Module = s:V.import("Over.Commandline.Modules")
    1   0.000031   0.000012 	let s:base.variables.modules = s:Signals.make()
    1              0.000003 	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
                            
    1   0.002091   0.000010 	let s:Highlight = s:V.import("Palette.Highlight")

FUNCTION  <SNR>266__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:18
Called 1 time
Total time:   0.000837
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000833   0.000008 	let s:Capture  = s:V.import("Palette.Capture")

FUNCTION  <SNR>275__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:15
Called 1 time
Total time:   0.013500
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.008853   0.000010 	let s:Window = a:V.import("Coaster.Window")
    1   0.003859   0.000016 	let s:Gift = a:V.import("Gift")
    1   0.000784   0.000011 	call s:_init()

FUNCTION  vital#easymotion#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:28
Called 1 time
Total time:   0.005504
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000005   if !exists('s:V')
    1   0.000029   0.000010     let s:V = s:new(s:plugin_name)
    1              0.000001   endif
    1   0.005467   0.000017   return call(s:V.import, a:000, s:V)

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:15
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000003     if has('unix')
    1              0.000010         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
    1              0.000012         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>196_getPromptMessage()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:207
Called 2 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    2              0.000006     if a:num_strokes == 1
                                    let prompt = substitute( substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'), '(s)', '', 'g')
    2              0.000005     elseif a:num_strokes == -1
    2              0.000041         let prompt = substitute( substitute(g:EasyMotion_prompt, '{n}\s\{0,1}', '', 'g'), '(s)', 's', 'g')
                                else
                                    let prompt = substitute( substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'), '(s)', 's', 'g')
    2              0.000003     endif
    2              0.000004     return prompt

FUNCTION  <SNR>263_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/History.vim:62
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000006 	let module = deepcopy(s:module)
    1              0.000006 	let module.mode = get(a:, 1, "cmd")
    1              0.000002 	return module

FUNCTION  421()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 14 times
Total time:   0.002185
 Self time:   0.000365

count  total (s)   self (s)
   14              0.000068 	let s:cmdline = a:cmdline
   14   0.002099   0.000279 	call s:doautocmd_user(self.prefix, self.prefix . 'Draw')

FUNCTION  422()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 14 times
Total time:   0.002115
 Self time:   0.000379

count  total (s)   self (s)
   14              0.000077 	let s:cmdline = a:cmdline
   14   0.002009   0.000273 	call s:doautocmd_user(self.prefix, self.prefix . 'DrawPre')

FUNCTION  423()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:83
Called 3 times
Total time:   0.000539
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000077 	let s:cmdline = a:cmdline
    3   0.000461   0.000062 	call s:doautocmd_user(self.prefix, self.prefix . 'ExecutePre')

FUNCTION  vital#_incsearch#Over#Commandline#Base#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:7
Called 1 time
Total time:   0.000104
 Self time:   0.000072

count  total (s)   self (s)
    1   0.000104   0.000072 return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>239_' . v:key)")

FUNCTION  428()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionMessage.vim:29
Called 14 times
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
   14              0.000068 	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
   14              0.000021 	endif

FUNCTION  <SNR>205_parse()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:57
Called 1 time
Total time:   0.000334
 Self time:   0.000307

count  total (s)   self (s)
    1              0.000004 	let highlight = a:highlight
                            	
    1              0.000017 	if highlight !~# '^\w\+\s\+xxx\s'
                            		return {}
    1              0.000002 	endif
                            
    1   0.000024   0.000013 	let name = s:parse_to_name(a:highlight)
    1              0.000004 	let result = { "_name" : name }
                            
    1              0.000011 	if highlight =~# '^\w\+\s\+xxx cleared'
                            		let result.cleared = 1
                            		return result
    1              0.000001 	endif
                            
    1   0.000026   0.000010 	let link = s:links_to(highlight)
    1              0.000002 	if link != ""
                            		let result.link = link
                            		return result
    1              0.000001 	endif
                            
    1              0.000006 	let attrs = [		"term",		"cterm",		"ctermfg",		"ctermbg",		"gui",		"font",		"guifg",		"guibg",		"guisp",	]
   10              0.000018 	for attr in attrs
    9              0.000130 		let item = matchstr(highlight, '\s' . attr . '=\zs#\?\w\+\ze')
    9              0.000017 		if item != ""
    2              0.000007 			let result[attr] = item
    9              0.000010 		endif
   10              0.000012 	endfor
    1              0.000002 	return result

FUNCTION  ale#handlers#writegood#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/writegood.vim:13
Called 474 times
Total time:   0.248327
 Self time:   0.012086

count  total (s)   self (s)
  474   0.247812   0.011571     return ale#node#FindExecutable(a:buffer, 'writegood', [   'node_modules/.bin/write-good',   'node_modules/write-good/bin/write-good.js',])

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:224
Called 17052 times
Total time:  27.665831
 Self time:   1.142815

count  total (s)   self (s)
17052              0.125461   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
17052              0.027488   endif
                            
17052  23.077488   0.267493   call s:update_branch()
17052   4.056858   0.350833   call s:update_untracked()
                            
17052              0.151723   if exists('b:airline_head') && !empty(b:airline_head)
17002              0.058534     return b:airline_head
   50              0.000075   endif
                            
   50              0.000226   let b:airline_head = ''
   50              0.000461   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
   50              0.000121   let heads = []
  150              0.000357   for vcs in vcs_priority
  100              0.000586     if !empty(b:buffer_vcs_config[vcs].branch)
   50              0.000242       let heads += [vcs]
  100              0.000135     endif
  150              0.000241   endfor
                            
  100              0.000245   for vcs in heads
   50              0.000190     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
   50              0.000070     endif
   50              0.000178     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
   50              0.000086     endif
   50   0.009164   0.002168     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
   50              0.000302     let additional = b:buffer_vcs_config[vcs].untracked
   50              0.000528     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
   50              0.000305       let additional = g:airline_symbols['dirty']
   50              0.000069     endif
   50              0.000247     let b:airline_head .= additional
  100              0.000176   endfor
                            
   50              0.000168   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
   50              0.000068   endif
                            
   50              0.000158   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
   50              0.000059   endif
                            
   50              0.000486   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '‚Ä¶' : '.')
                                endif
   50              0.000064   endif
                            
   50              0.000212   return b:airline_head

FUNCTION  riv#file#update()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/file.vim:31
Called 3 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000039     let s:prev = expand('%:p')

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:70
Called 24 times
Total time:   0.069104
 Self time:   0.011773

count  total (s)   self (s)
   24   0.001458   0.000403   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
   24              0.000034   endif
                            
   24   0.001673   0.000359   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
   24              0.000036   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   24              0.000060   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
   24              0.000171   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
   24              0.000163   let s:counter = (s:counter + 1) % 20
   24              0.000154   let buff_file .= '.'.s:counter
                            
   24   0.001793   0.000445   let extension = gitgutter#utility#extension(a:bufnr)
   24              0.000092   if !empty(extension)
   24              0.000145     let buff_file .= '.'.extension
   24              0.000037   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
   24   0.009717   0.001041   call s:write_buffer(a:bufnr, buff_file)
                            
   24              0.000111   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
   24              0.000213     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
   24              0.000225     let from_file .= '.'.s:counter
                            
   24              0.000093     if !empty(extension)
   24              0.000101       let from_file .= '.'.extension
   24              0.000037     endif
                            
                                " Write file from index to temporary file.
   24   0.002941   0.000705     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
   24              0.000297     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
   24              0.000039   endif
                            
                              " Call git-diff.
   24              0.000200   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager '.g:gitgutter_git_args
   24              0.000065   if s:c_flag
   24              0.000242     let cmd .= ' -c "diff.autorefreshindex=0"'
   24              0.000101     let cmd .= ' -c "diff.noprefix=false"'
   24              0.000116     let cmd .= ' -c "core.safecrlf=false"'
   24              0.000027   endif
   24              0.000314   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
   24              0.000161   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   24   0.002026   0.000714     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   24              0.000030   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
   24              0.000120   let cmd .= ' || exit 0'
                            
   24              0.000087   let cmd .= ')'
                            
   24   0.005546   0.000456   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
   24   0.000471   0.000376   if g:gitgutter_async && gitgutter#async#available()
   24   0.038557   0.002352     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   24              0.000309     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>111_get_wordcount()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:8
Called 9914 times
Total time:   2.460937
 Self time:   2.460937

count  total (s)   self (s)
 9914              0.069576     if get(g:, 'actual_curbuf', '') != bufnr('')
    1              0.000002       return
 9913              0.015168     endif
 9913              0.052730     let query = a:visual_mode_active ? 'visual_words' : 'words'
 9913              2.286658     return get(wordcount(), query, 0)

FUNCTION  432()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/History.vim:34
Called 3 times
Total time:   0.000079
 Self time:   0.000046

count  total (s)   self (s)
    3   0.000075   0.000042 	call s:_reset()

FUNCTION  <SNR>136_OnTextChangedNormalMode()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:764
Called 327 times
Total time:   0.504682
 Self time:   0.015981

count  total (s)   self (s)
  327   0.052954   0.008152   if !s:AllowedToCompleteInCurrentBuffer()
                                return
  327              0.000447   endif
                            
  327   0.450118   0.006219   call s:OnFileReadyToParse()

FUNCTION  EasyMotion#undo#save()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/undo.vim:3
Called 1 time
Total time:   0.005328
 Self time:   0.000015

count  total (s)   self (s)
    1   0.005328   0.000015   return s:undo_lock.save()

FUNCTION  430()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionMessage.vim:43
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000013 	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
    3              0.000003 	endif

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 17056 times
Total time:   1.446954
 Self time:   0.368495

count  total (s)   self (s)
17056   1.433111   0.354652   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  433()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/History.vim:38
Called 15 times
Total time:   0.002485
 Self time:   0.000640

count  total (s)   self (s)
   15   0.002070   0.000408 	if !a:cmdline.is_input("\<Up>") && !a:cmdline.is_input("\<Down>")	&& !a:cmdline.is_input("\<C-p>") && !a:cmdline.is_input("\<C-n>")
   15   0.000368   0.000185 		call s:_reset()
   15              0.000027 		return
                            	else
                            		if s:count == 0 && empty(s:cmdhist)	|| s:is_match_mode != s:_should_match_cmdline(a:cmdline)
                            			let cmdline = '^' . a:cmdline.getline()
                            			let s:is_match_mode = s:_should_match_cmdline(a:cmdline)
                            			let s:cmdhist = [a:cmdline.getline()] + (s:is_match_mode ?	filter(self.histories(), 'v:val =~ cmdline') : self.histories())
                            		endif
                            	endif
                            	call a:cmdline.setchar("")
                            	if a:cmdline.is_input("\<Down>") || a:cmdline.is_input("\<C-n>")
                            		let s:count = max([s:count - 1, 0])
                            	endif
                            	if a:cmdline.is_input("\<Up>") || a:cmdline.is_input("\<C-p>")
                            		let s:count = min([s:count + 1, len(s:cmdhist)])
                            	endif
                            	call a:cmdline.setline(get(s:cmdhist, s:count, a:cmdline.getline()))

FUNCTION  435()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/NoInsert.vim:25
Called 15 times
Total time:   0.000650
 Self time:   0.000323

count  total (s)   self (s)
   15   0.000375   0.000207 	if self.is_no_insert(a:cmdline.char())
    3   0.000188   0.000029 		call a:cmdline.setchar("", 0)
   15              0.000025 	endif

FUNCTION  436()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/NoInsert.vim:41
Called 15 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
   15              0.000111 		return char2nr(a:char) == 128 || char2nr(a:char) < 27

FUNCTION  438()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:116
Called 3 times
Total time:   0.008352
 Self time:   0.000370

count  total (s)   self (s)
    3   0.008048   0.000066 	let self._cmaps = s:_auto_cmap()
    3              0.000016 	if exists("*execute")
    3              0.000282 		let self._old_cmap = execute("cmap")
    3              0.000003 	endif

FUNCTION  439()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:124
Called 14 times
Total time:   0.003017
 Self time:   0.003017

count  total (s)   self (s)
   14              0.000110 	if !exists("*execute")
                            		return
   14              0.000023 	endif
                            
   14              0.002534 	let cmap_ = execute("cmap")
   14              0.000138 	if self._old_cmap != cmap_
                            		let self._cmaps = s:_auto_cmap()
                            		let self._old_cmap = cmap_
   14              0.000022 	endif

FUNCTION  <SNR>194_Message()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:434
Called 2 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
    2              0.000008     if g:EasyMotion_verbose
    2              0.000231         echo 'EasyMotion: ' . a:message
                                else
                                    " Make the current message disappear
                                    echo ''
                                    " redraw
    2              0.000002     endif

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:187
Called 524 times
Total time:   0.028207
 Self time:   0.028207

count  total (s)   self (s)
  524              0.004939     let l:info = get(s:buffer_data, a:buffer, {})
                            
  524              0.002229     if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
  524              0.000949     endif

FUNCTION  vista#SetProvider()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:32
Called 2 times
Total time:   0.000104
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000013   if get(t:vista, 'skip_set_provider', v:false)
                                let t:vista.skip_set_provider = v:false
                                return
    2              0.000003   endif
    2              0.000009   let t:vista.provider = a:provider
    2   0.000069   0.000023   call vista#statusline#Render()

FUNCTION  vista#sidebar#OpenOrUpdate()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:53
Called 1 time
Total time:   0.189088
 Self time:   0.000208

count  total (s)   self (s)
                              " (Re)open a window and move to it
    1              0.000005   if !exists('t:vista.bufnr')
    1   0.146363   0.000012     call s:NewWindow()
    1              0.000007     let t:vista = get(t:, 'vista', {})
    1              0.000008     let t:vista.bufnr = bufnr('%')
    1              0.000007     let t:vista.winid = win_getid()
    1              0.000012     let t:vista.pos = [winsaveview(), winnr(), winrestcmd()]
                              else
                                let winnr = t:vista.winnr()
                                if winnr ==  -1
                                  call s:NewWindow()
                                elseif winnr() != winnr
                                  noautocmd execute winnr.'wincmd w'
                                endif
    1              0.000001   endif
                            
    1              0.000010   if exists('#User#VistaWinOpen')
                                doautocmd User VistaWinOpen
    1              0.000001   endif
                            
    1   0.042222   0.000019   call vista#util#SetBufline(t:vista.bufnr, a:rows)
                            
    1              0.000006   if has_key(t:vista, 'lnum')
    1   0.000360   0.000034     call vista#cursor#ShowTagFor(t:vista.lnum)
    1              0.000003     unlet t:vista.lnum
    1              0.000002   endif
                            
    1              0.000004   if !get(g:, 'vista_stay_on_open', 1)
                                wincmd p
    1              0.000001   endif

FUNCTION  <SNR>188_is_in_list_item()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/action.vim:143
Called 6 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
                                " it's the col before last space in list-item
    6              0.000195     return a:col <= matchend(a:line, s:p.all_list)

FUNCTION  <SNR>111_format_wordcount()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:40
Called 1312 times
Total time:   0.167260
 Self time:   0.041919

count  total (s)   self (s)
 1312   0.166345   0.041004   return airline#extensions#wordcount#formatters#{s:formatter}#to_string(a:wordcount)

FUNCTION  <SNR>194_turn_off_hl_error()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:477
Called 2 times
Total time:   0.001304
 Self time:   0.000144

count  total (s)   self (s)
    2   0.000623   0.000042     let s:error_hl = EasyMotion#highlight#capture('Error')
    2   0.000129   0.000031     call EasyMotion#highlight#turn_off(s:error_hl)
    2   0.000434   0.000038     let s:matchparen_hl = EasyMotion#highlight#capture('MatchParen')
    2   0.000115   0.000030     call EasyMotion#highlight#turn_off(s:matchparen_hl)

FUNCTION  riv#table#format_pos()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/table.vim:56
Called 424 times
Total time:   0.038577
 Self time:   0.038577

count  total (s)   self (s)
  424              0.002452     let pos = getpos('.')
  424              0.017753     if getline('.') =~ s:p.table
                                    noa call riv#table#format()
                                    call setpos('.',pos)
                                    " It may get folded after formating.
                                    if foldclosed(pos[1])!=-1
                                        foldopen!
                                    endif
  424              0.000586     endif

FUNCTION  incsearch#over#modules#bracketed_paste#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bracketed_paste.vim:32
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return deepcopy(s:bracketed_paste)

FUNCTION  airline#util#strchars()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:107
Called 532 times
Total time:   0.004635
 Self time:   0.004635

count  total (s)   self (s)
  532              0.001744   if s:has_strchars
  532              0.002355     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  <SNR>157_RealParentOf()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:90
Called 1 time
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    1              0.000003   let candidate = a:candidate
                            
    1              0.000002   let name = candidate.scope
    1              0.000020   let kind = candidate.scopeKind
                            
    1              0.000004   let parent_candidates = []
    2              0.000025   for pc in t:vista.without_scope
    1              0.000007     if pc.name ==# name && pc.kind ==# kind && pc.line <= candidate.line
    1              0.000007       call add(parent_candidates, pc)
    1              0.000002     endif
    2              0.000004   endfor
                            
    1              0.000005   if !empty(parent_candidates)
    1              0.000011     call sort(parent_candidates, function('s:Compare'))
    1              0.000008     return parent_candidates[-1]
                              endif
                            
                              return {}

FUNCTION  <SNR>132_TryAppendExtension()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:202
Called 1 time
Total time:   0.000042
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000028   0.000010   let ext = t:vista.source.extension()
    1              0.000004   if !empty(ext)
    1              0.000009     return join([a:tempname, ext], '.')
                              else
                                return a:tempname
                              endif

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:837
Called 17054 times
Total time:  12.886205
 Self time:   8.527022

count  total (s)   self (s)
17054              0.099449   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
17054              0.193789   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
17054   0.887917   0.638904   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
17054   0.580067   0.344602   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
17054              0.026393   endif
17054              0.091960   let dir = a:0 ? a:1 : s:Dir()
17054              0.058615   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
17054              0.024673   endif
17054   0.444399   0.225492   let rev = s:Slash(a:object)
17054   2.658477   0.228524   let tree = s:Tree(dir)
17054              0.103480   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
17054              0.046533   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
17054              0.136868   elseif rev =~# '^\.git/'
17054              0.182464     let f = substitute(rev, '^\.git', '', '')
17054   1.205255   0.242349     let cdir = fugitive#CommonDir(dir)
17054              0.173897     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
17054              0.124745     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
17054              0.213305     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
17054              0.026049     else
17054              0.112503       let f = simplify(dir . f)
17054              0.027080     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:.-][^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:.-][^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit, '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
17054              0.027434   endif
17054   0.497992   0.235053   return FugitiveVimPath(f)

FUNCTION  440()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:137
Called 14 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
   14              0.000061 	return self._cmaps

FUNCTION  441()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/IgnoreRegexpBackwardWord.vim:36
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000009 	function! a:cmdline.backward_word(...)
                            		return call("s:backward_word", [self.backward()] + a:000)
                            	endfunction

FUNCTION  443()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:86
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    3              0.000011   return g:incsearch#vim_cmdline_keymap

FUNCTION  444()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:89
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000011   return g:incsearch#smart_backward_word

FUNCTION  445()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/module_management.vim:15
Called 3 times
Total time:   0.012081
 Self time:   0.000774

count  total (s)   self (s)
    3              0.000020   if !exists('s:default_backward_word')
    1              0.000008     let s:default_backward_word = a:cmdline.backward_word
    3              0.000003   endif
   12              0.000032   for module in self.modules
    9   0.000175   0.000133     if has_key(module, '_condition') && ! module._condition()
    3   0.000465   0.000026       call a:cmdline.disconnect(module.name)
    3              0.000013       if module.name ==# 'IgnoreRegexpBackwardWord'
                                    function! a:cmdline.backward_word(...) abort
                                      return call(s:default_backward_word, a:000, self)
                                    endfunction
    3              0.000005       endif
    6   0.001075   0.000063     elseif empty(a:cmdline.get_module(module.name))
    6   0.001516   0.000076       call a:cmdline.connect(module)
    6              0.000024       if has_key(module, 'on_enter')
    6   0.008435   0.000061         call module.on_enter(a:cmdline)
    6              0.000010       endif
    9              0.000010     endif
   12              0.000016   endfor

FUNCTION  446()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/module_management.vim:36
Called 84 times
Total time:   0.000527
 Self time:   0.000527

count  total (s)   self (s)
                              " NOTE: to overwrite backward_word() with default function
   84              0.000392   return a:event ==# 'on_enter' ? 5 : 0

FUNCTION  448()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/pattern_saver.vim:28
Called 3 times
Total time:   0.000141
 Self time:   0.000124

count  total (s)   self (s)
    3              0.000010   if ! g:incsearch#no_inc_hlsearch
    3   0.000042   0.000028     let is_cancel = a:cmdline.exit_code()
    3              0.000006     if is_cancel
                                  let @/ = self.pattern
    3              0.000003     endif
    3   0.000030   0.000027     let &hlsearch = self.hlsearch
    3              0.000015     if exists('v:hlsearch')
    3              0.000012       let v:hlsearch = self.vhlsearch
    3              0.000004     endif
    3              0.000004   endif

FUNCTION  449()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bulk_input_char.vim:17
Called 15 times
Total time:   0.001154
 Self time:   0.001147

count  total (s)   self (s)
   15              0.000045   let stack = []
   15              0.000035   let c = 1
   31              0.000062   while c
   16              0.000400     let c = getchar(0)
   16              0.000040     if c != 0
    1              0.000006       let stack += [nr2char(c)]
   15              0.000062     elseif !empty(stack)
    1   0.000016   0.000009       call a:cmdline.set_input_key_stack(stack)
   16              0.000022     endif
   31              0.000053   endwhile

FUNCTION  <SNR>153_StopCursorTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:55
Called 2005 times
Total time:   0.051122
 Self time:   0.051122

count  total (s)   self (s)
 2005              0.007942     if s:cursor_timer != -1
 1877              0.020418         call timer_stop(s:cursor_timer)
 1877              0.015355         let s:cursor_timer = -1
 2005              0.003164     endif

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 9 times
Total time:   0.001336
 Self time:   0.000782

count  total (s)   self (s)
    9              0.000136   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    9              0.000045   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    9              0.000036   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
    2              0.000027     if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
    1              0.000004       let b:airline_changedtick = -1
    1   0.000147   0.000020       call s:update_wordcount(1) " force update: ensures initial worcount exists
    1              0.000006     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    2              0.000003     endif
    9              0.000014   endif
                            
    9              0.000058   if exists('b:airline_wordcount')
    6   0.000583   0.000156     call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    9              0.000013   endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:172
Called 24 times
Total time:   0.097226
 Self time:   0.005738

count  total (s)   self (s)
   24   0.002223   0.000417   call gitgutter#debug#log(a:diff)
                            
   24              0.000141   if !bufexists(a:bufnr)
                                return
   24              0.000034   endif
                            
   24   0.009407   0.000870   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   24   0.042736   0.000890   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
   24              0.000144   let signs_count = len(modified_lines)
   24              0.000092   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
   24              0.000034   else
   24              0.000119     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
   24   0.038725   0.001014       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   24              0.000040     endif
   24              0.000035   endif
                            
   24   0.002361   0.000773   call s:save_last_seen_change(a:bufnr)
   24              0.000308   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
   24              0.000031   endif

FUNCTION  <SNR>38_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:48
Called 3395 times
Total time:   0.568689
 Self time:   0.340618

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
 3395              0.023201   if &buftype is# 'popup'
                                return
 3395              0.005844   endif
                            
 3395              0.020107   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
 3395              0.004867   endif
 3395              0.022490   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
 3395              0.081855   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
 3395              0.136508   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
 3386              0.006732     return
    9              0.000015   endif
    9              0.000058   let g:airline_last_window_changed = l:key
    9   0.000168   0.000106   call s:init()
    9   0.228211   0.000202   call airline#update_statusline()

FUNCTION  452()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:40
Called 48 times
Total time:   0.002770
 Self time:   0.001621

count  total (s)   self (s)
   48   0.001597   0.000448 	call self.delete(a:name)
   48              0.000371 	let priority = get(a:, 1, 10)
   48              0.000751 	let self.variables.hl_list[a:name] = {		"group" : a:group,		"pattern" : a:pattern,		"priority" : priority,		"name" : a:name,	}

FUNCTION  <SNR>197__get_module()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:184
Called 31 times
Total time:   0.028667
 Self time:   0.002280

count  total (s)   self (s)
   31   0.001847   0.000788   let funcname = s:_import_func_name(self.plugin_name(), a:name)
   31   0.024715   0.000708   if s:_exists_autoload_func_with_source(funcname)
   31   0.002077   0.000756     return call(funcname, [])
                              else
                                return s:_get_builtin_module(a:name)
                              endif

FUNCTION  <SNR>136_InsideCommentOrString()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:860
Called 5594 times
Total time:  11.981176
 Self time:  11.981176

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
 5594             11.816541   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
 5594              0.050476   if stridx(syntax_group, 'Comment') > -1
   16              0.000033     return 1
 5578              0.012594   endif
                            
 5578              0.026689   if stridx(syntax_group, 'String') > -1
  288              0.000539     return 2
 5290              0.007625   endif
                            
 5290              0.011474   return 0

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:109
Called 4 times
Total time:   0.002294
 Self time:   0.002071

count  total (s)   self (s)
    4              0.000012   if !g:gitgutter_map_keys
                                return
    4              0.000007   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    4              0.000018   let bufnr = bufnr('')
                            
    4   0.000164   0.000063   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    1              0.000002     return
    3              0.000003   endif
                            
    3              0.000205   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
    3              0.000058     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    3              0.000003   endif
    3              0.000103   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
    3              0.000060     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    3              0.000003   endif
                            
    3              0.000107   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
    3              0.000057     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    3              0.000005   endif
    3              0.000109   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
    3              0.000054     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    3              0.000005   endif
    3              0.000108   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
    3              0.000053     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    3              0.000003   endif
    3              0.000106   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
    3              0.000055     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    3              0.000003   endif
                            
    3              0.000157   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
    3              0.000054     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    3              0.000003   endif
    3              0.000112   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
    3              0.000050     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    3              0.000003   endif
    3              0.000116   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
    3              0.000106     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    3              0.000005   endif
    3              0.000118   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
    3              0.000049     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    3              0.000005   endif
                            
    3   0.000173   0.000051   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>35_ClearHighlighting()
    Defined: ~/.vim/plugged/vim-better-whitespace/plugin/better-whitespace.vim:181
Called 12178 times
Total time:   0.132824
 Self time:   0.132824

count  total (s)   self (s)
12178              0.123913         silent! call matchdelete(get(s:, 'match_id', -1))

FUNCTION  451()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bracketed_paste.vim:25
Called 3 times
Total time:   0.000077
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000012   if !exists('&t_BE')
                                return
    3              0.000005   endif
    3   0.000054   0.000047   let &t_BE = self.t_BE

FUNCTION  riv#ptn#fix_sft()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:659
Called 6 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
                                " 
    6              0.000064     if (a:sft > 0 && a:c_col < a:f_col && a:c_col+a:sft >= a:f_col)|| (a:sft < 0 && a:c_col > a:f_col && a:c_col+a:sft <= a:f_col)
    4              0.000012         return a:f_col
    2              0.000004     else
    2              0.000010         return a:c_col + a:sft
                                endif

FUNCTION  <SNR>48_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:74
Called 24 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   24              0.000238   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>55_register()
    Defined: ~/.vim/plugged/vim-go/plugin/go.vim:276
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000017   if !(&modifiable && expand('<amatch>') ==# 'go')
    3              0.000003     return
                              endif
                            
                              let l:RestoreGopath = function('s:noop')
                              if go#config#AutodetectGopath()
                                let l:RestoreGopath = go#util#SetEnv('GOPATH', go#path#Detect())
                              endif
                              call go#lsp#DidOpen(expand('<afile>:p'))
                              call call(l:RestoreGopath, [])

FUNCTION  EasyMotion#highlight#InitHL()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:99
Called 7 times
Total time:   0.001216
 Self time:   0.001216

count  total (s)   self (s)
    7              0.000031     let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
    7              0.000078     let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
    7              0.000118     let ctermhl = &t_Co == 256 ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2]) : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
    7              0.000304     execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
    7              0.000201     if hlexists(a:group)
    2              0.000092         redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
    2              0.000014         if hlstatus !~ 'cleared'
    2              0.000003             return
                                    endif
    5              0.000007     endif
                            
                                " No colors are defined for this group, link to defaults
    5              0.000281     execute printf('hi default link %s %s', a:group, group_default)

FUNCTION  <SNR>282__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift.vim:15
Called 1 time
Total time:   0.002301
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.002211   0.000010 	let s:Window = s:V.import("Gift.Window")
    1   0.000087   0.000010 	let s:Tabpage = s:V.import("Gift.Tabpage")

FUNCTION  riv#path#rel_to_root()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:114
Called 51 times
Total time:   0.009533
 Self time:   0.001148

count  total (s)   self (s)
   50 1118.550954 1118.542754     return riv#path#rel_to(riv#path#root(), a:path)

FUNCTION  <SNR>231_get_input()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:198
Called 3 times
Total time:   1.429853
 Self time:   0.000189

count  total (s)   self (s)
                              " Handle visual mode highlight
    3   0.000076   0.000041   if s:U.is_visual(a:cli._mode)
                                let visual_hl = incsearch#highlight#get_visual_hlobj()
                                try
                                  call incsearch#highlight#turn_off(visual_hl)
                                  call incsearch#highlight#emulate_visual_highlight(a:cli._mode, visual_hl)
                                  let input = a:cli.get(a:cli._pattern)
                                finally
                                  call incsearch#highlight#turn_on(visual_hl)
                                endtry
    3              0.000005   else
    3   1.429663   0.000034     let input = a:cli.get(a:cli._pattern)
    3              0.000006   endif
    3              0.000009   return input

FUNCTION  <SNR>47_on_bufenter()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:212
Called 4 times
Total time:   0.003650
 Self time:   0.000188

count  total (s)   self (s)
    4   0.002344   0.000050   call gitgutter#setup_maps()
                            
    4              0.000028   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    4              0.000007   else
    4   0.001235   0.000067     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    4              0.000005   endif

FUNCTION  vital#_incsearch#Over#Commandline#Modules#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules.vim:7
Called 1 time
Total time:   0.000065
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000064   0.000046 return map({'get': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>245_' . v:key)")

FUNCTION  <SNR>210__as_echon()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:83
Called 24 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   24              0.000172 	return "echon " . strtrans(string(a:str))

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:190
Called 17283 times
Total time:   0.571654
 Self time:   0.571654

count  total (s)   self (s)
17283              0.270286   if has_key(s:contexts, a:winnr)
17283              0.248733     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  ale#Queue()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:129
Called 476 times
Total time:   2.869299
 Self time:   0.060210

count  total (s)   self (s)
  476              0.001631     if a:0 > 2
                                    throw 'too many arguments!'
  476              0.000924     endif
                            
  476              0.003918     let l:buffer = get(a:000, 1, v:null)
                            
  476              0.002094     if l:buffer is v:null
  424              0.002577         let l:buffer = bufnr('')
  476              0.000744     endif
                            
  476              0.002948     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
  476              0.000735     endif
                            
  476   0.133325   0.007607     if ale#ShouldDoNothing(l:buffer)
                                    return
  476              0.000639     endif
                            
                                " Default linting_flag to ''
  476              0.004244     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
  476              0.001768     if s:lint_timer != -1
    2              0.000048         call timer_stop(s:lint_timer)
    2              0.000008         let s:lint_timer = -1
  476              0.000728     endif
                            
  476              0.001429     if a:delay > 0
    2              0.000024         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
  474              0.001011     else
  474   2.695192   0.011821         call s:Lint(l:buffer, l:should_lint_file, 0)
  476              0.000730     endif

FUNCTION  460()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:100
Called 3 times
Total time:   0.000366
 Self time:   0.000159

count  total (s)   self (s)
   12   0.000081   0.000065 	for name in self.hl_list()
    9   0.000253   0.000062 		call self.delete(name)
   12              0.000018 	endfor

FUNCTION  EasyMotion#helper#strchars()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:150
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000010         return strchars(a:str)

FUNCTION  airline#extensions#wordcount#formatters#default#to_string()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim:26
Called 1312 times
Total time:   0.125341
 Self time:   0.099785

count  total (s)   self (s)
 1312   0.044116   0.018560   if airline#util#winwidth() > 85
 1312              0.003762     if a:wordcount > 999
                                  " Format number according to locale, e.g. German: 1.245 or English: 1,245
  981              0.035004       let wordcount = substitute(a:wordcount, '\d\@<=\(\(\d\{3\}\)\+\)$', s:decimal_group.'&', 'g')
  331              0.000459     else
  331              0.001202       let wordcount = a:wordcount
 1312              0.001999     endif
 1312              0.008654     let str = printf(s:fmt, wordcount)
                              else
                                let str = printf(s:fmt_short, a:wordcount)
 1312              0.001928   endif
 1312              0.010794   return str . g:airline_symbols.space . g:airline_right_alt_sep . g:airline_symbols.space

FUNCTION  464()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:135
Called 18 times
Total time:   0.014110
 Self time:   0.000883

count  total (s)   self (s)
   66   0.000371   0.000272 	for name in self.hl_list()
   48   0.013525   0.000397 		call self.enable(name)
   66              0.000126 	endfor

FUNCTION  465()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:142
Called 48 times
Total time:   0.016401
 Self time:   0.002780

count  total (s)   self (s)
   48   0.007959   0.000434 	if !self.is_enabled(a:name)
                            		return -1
   48              0.000065 	endif
   48              0.000110 	let id = -1
   48   0.004296   0.000711 	silent! let id = matchdelete(self.get_hl_id(a:name))
   48              0.000106 	if id == -1
                            		return -1
   48              0.000061 	endif
   48   0.003267   0.000756 	let winnr = get(a:, 1, s:Gift.uniq_winnr())
   48              0.000252 	unlet! self.variables.id_list[winnr][a:name]

FUNCTION  466()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:156
Called 21 times
Total time:   0.019179
 Self time:   0.001003

count  total (s)   self (s)
   69   0.002097   0.000322 	for name in self.enable_list()
   48   0.016824   0.000423 		call self.disable(name)
   69              0.000130 	endfor

FUNCTION  <SNR>203_unmapping()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:73
Called 12 times
Total time:   0.003042
 Self time:   0.001004

count  total (s)   self (s)
   12              0.000074 	let is_locking = get(a:, 1, 0)
   12   0.001086   0.000257 	let key = s:match_key(a:keymapping, a:key)
   12              0.000042 	if key == ""
   10   0.001005   0.000229 		return s:String.length(a:key) <= 1 ? a:key : s:unmapping(a:keymapping, a:key[0], is_locking) . s:unmapping(a:keymapping, a:key[1:], is_locking)
    2              0.000002 	endif
                            
    2   0.000065   0.000029 	let map_conf = s:as_key_config(a:keymapping[key])
                            
    2              0.000018 	let next_input = s:unmapping(a:keymapping, a:key[len(key) : ], is_locking)
    2              0.000006 	if map_conf.lock == 0 && is_locking
                            		return key . next_input
    2              0.000004 	elseif map_conf.lock
    2   0.000058   0.000036 		return s:unmapping(a:keymapping, s:_get_key(map_conf), is_locking) . next_input
                            	else
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), map_conf.noremap) . next_input
                            	endif

FUNCTION  <SNR>132_PrepareContainer()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:88
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000009   let s:data = {}
    1              0.000010   let t:vista = get(t:, 'vista', {})
    1              0.000005   let t:vista.functions = []
    1              0.000008   let t:vista.raw = []
    1              0.000003   let t:vista.kinds = []
    1              0.000006   let t:vista.raw_by_kind = {}
    1              0.000014   let t:vista.with_scope = []
    1              0.000004   let t:vista.without_scope = []

FUNCTION  <SNR>136_UpdateMatches()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:634
Called 7 times
Total time:   0.001350
 Self time:   0.001350

count  total (s)   self (s)
    7              0.001343   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  <SNR>232_funcmanage()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:179
Called 30 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   30              0.000083   return s:funcmanage

FUNCTION  vista#cursor#ShowTagFor()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:480
Called 1 time
Total time:   0.000326
 Self time:   0.000064

count  total (s)   self (s)
    1   0.000037   0.000016   if !s:HasVlnum()
                                return
    1              0.000002   endif
                            
    1   0.000266   0.000025   let found = vista#util#BinarySearch(t:vista.raw, a:lnum, 'line', '')
    1              0.000003   if empty(found)
                                return
    1              0.000001   endif
    1              0.000006   let s:vlnum = get(found, 'vlnum', v:null)
    1              0.000002   if empty(s:vlnum)
    1              0.000002     return
                              endif
                            
                              let tag = get(found, 'name', v:null)
                              if !empty(tag)
                                call s:ApplyHighlight(s:vlnum, v:true, tag)
                              else
                                call s:ApplyHighlight(s:vlnum, v:true)
                              endif

FUNCTION  ale#Set()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:196
Called 11 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
   11              0.000070     let l:full_name = 'ale_' . a:variable_name
                            
   11              0.000061     if !has_key(g:, l:full_name)
    9              0.000047         let g:[l:full_name] = a:default
   11              0.000020     endif

FUNCTION  incsearch#highlight#hgm()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/highlight.vim:101
Called 18 times
Total time:   0.001845
 Self time:   0.001845

count  total (s)   self (s)
   18              0.000217   let hgm = copy(s:default_highlight)
  108              0.000374   for key in keys(hgm)
   90              0.000765     call extend(hgm[key], get(g:incsearch#highlight, key, {}))
  108              0.000199   endfor
   18              0.000047   return hgm

FUNCTION  <SNR>136_RequestCompletion()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:897
Called 5321 times
Total time:  13.886073
 Self time:   7.316182

count  total (s)   self (s)
 5321              7.077781   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
 5321   6.784990   0.215099   call s:PollCompletion()

FUNCTION  vital#_easymotion#Over#Commandline#Modules#CursorMove#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim:5
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000020     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>147_GetCounts()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:97
Called 34552 times
Total time:   2.917888
 Self time:   1.732419

count  total (s)   self (s)
34552   1.221683   0.606587     if !s:BufferCacheExists(a:buffer)
  692   0.025050   0.014267         return s:CreateCountDict()
33860              0.050343     endif
                            
33860   1.224867   0.665277     call s:UpdateCacheIfNecessary(a:buffer)
                            
33860              0.172545     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>136_DisableOnLargeFile()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:458
Called 26912 times
Total time:   0.305577
 Self time:   0.305577

count  total (s)   self (s)
26912              0.185971   if exists( 'b:ycm_largefile' )
26911              0.091732     return b:ycm_largefile
    1              0.000002   endif
                            
    1              0.000004   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    1              0.000014   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    1              0.000003   if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
    1              0.000002   endif
    1              0.000002   return b:ycm_largefile

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:77
Called 16 times
Total time:   0.005214
 Self time:   0.002517

count  total (s)   self (s)
   16              0.000129   let filetype_overrides = get(s:, 'filetype_overrides', {})
   16              0.000182   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
   16   0.002250   0.000362   if s:is_excluded_window()
                                return -1
   16              0.000023   endif
                            
   16              0.000055   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
   16              0.000020   endif
                            
   16              0.000056   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   16              0.000023   endif
                            
   16              0.000276   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
    2              0.000021     let args = filetype_overrides[&ft]
    2   0.000900   0.000091     call airline#extensions#apply_left_override(args[0], args[1])
   16              0.000025   endif
                            
   16              0.000049   if &buftype == 'help'
    4              0.000016     let w:airline_section_x = ''
    4              0.000015     let w:airline_section_y = ''
    4              0.000028     let w:airline_render_right = 1
   16              0.000025   endif
                            
   16              0.000134   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   16              0.000027   endfor

FUNCTION  <SNR>132_ApplyExecute()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:285
Called 1 time
Total time:   0.001774
 Self time:   0.000102

count  total (s)   self (s)
    1   0.000537   0.000019   let file = s:IntoTemp(a:fpath)
    1              0.000004   if empty(file)
                                return
    1              0.000002   endif
                            
    1              0.000004   let s:fpath = a:fpath
                            
    1   0.000284   0.000019   let cmd = s:BuildCmd(file)
                            
    1              0.000004   if a:bang || !s:can_async
                                call s:ApplyRun(cmd)
    1              0.000002   else
    1   0.000927   0.000038     call s:RunAsyncCommon(cmd)
    1              0.000002   endif

FUNCTION  vista#WinExecute()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:53
Called 1 time
Total time:   0.042162
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000004   if winnr() != a:winnr
                                noautocmd execute a:winnr.'wincmd w'
                                let l:switch_back = 1
    1              0.000001   endif
                            
    1   0.042102   0.000023   call call(a:Run, a:000)
                            
    1              0.000008   if exists('l:switch_back')
                                noautocmd wincmd p
    1              0.000002   endif

FUNCTION  vista#renderer#Decorate()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer.vim:63
Called 2 times
Total time:   0.000057
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000005   if g:vista#renderer#enable_icon
    2   0.000051   0.000028     return vista#renderer#IconFor(a:kind).' '.a:kind
                              else
                                return a:kind
                              endif

FUNCTION  <SNR>138_todo_object()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/todo.vim:23
Called 1443 times
Total time:   0.205234
 Self time:   0.028006

count  total (s)   self (s)
                                " groups: list,b_k,priority,tms,tms_end
 1443   0.203366   0.026138     return riv#ptn#match_object(a:line,s:p.todo_check)

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 495 times
Total time:   0.308163
 Self time:   0.034040

count  total (s)   self (s)
  495              0.002172   if a:group1 == a:group2
                                return 0
  495              0.000756   endif
  495   0.147983   0.010364   let color1 = airline#highlighter#get_highlight(a:group1)
  495   0.147111   0.010607   let color2 = airline#highlighter#get_highlight(a:group2)
  495              0.001480   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
  495              0.000739   else
  495              0.003437     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:62
Called 1569 times
Total time:   0.724158
 Self time:   0.229308

count  total (s)   self (s)
 1569              0.016640     let l:buffer = bufnr('')
                            
 1569              0.008329     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
 1569              0.002756     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
 1569              0.011100     if mode(1) isnot# 'n'
  192              0.000321         return
 1377              0.002745     endif
                            
 1377   0.395785   0.030232     if ale#ShouldDoNothing(l:buffer)
                                    return
 1377              0.002145     endif
                            
 1377   0.161670   0.032373     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
 1377              0.004632     if g:ale_echo_cursor
 1377              0.006101         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
 1377              0.007579         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
 1377              0.004912         endif
 1377              0.002219     endif
                            
 1377              0.004409     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
 1377              0.002571     endif

FUNCTION  riv#id()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv.vim:49
Called 1572 times
Total time:   0.064628
 Self time:   0.064628

count  total (s)   self (s)
                                " loop over the project root list and check if match,
                                "
                                " @return
                                " -1 if not in project, which proj[-1] is the Temp Proj dir.
                                " else the project's id in list g:_riv_c.p
                            
 1572              0.009360     if !exists('b:riv_id')
                                    let b:riv_id = -1
                            
                                    let f = expand('%:p')
                                    for proj in g:_riv_c.p
                                        if  riv#path#is_rel_to( proj._root_path, f)
                                            let b:riv_id = proj.id
                                            break
                                        endif
                                    endfor
 1572              0.002404     endif
                            
 1572              0.004832     return b:riv_id

FUNCTION  youcompleteme#CompleteFunc()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:987
Called 7796 times
Total time:   0.288742
 Self time:   0.288742

count  total (s)   self (s)
 7796              0.041004   if a:findstart
                                " When auto-wrapping is enabled, Vim wraps the current line after the
                                " completion request is sent but before calling this function. The starting
                                " column returned by the server is invalid in that case and must be
                                " recomputed.
 3898              0.025856     if s:completion.line != line( '.' )
                                  " Given
                                  "   scb: column where the completion starts before auto-wrapping
                                  "   cb: cursor column before auto-wrapping
                                  "   sca: column where the completion starts after auto-wrapping
                                  "   ca: cursor column after auto-wrapping
                                  " we have
                                  "   ca - sca = cb - scb
                                  "   sca = scb + ca - cb
                                  let s:completion.completion_start_column += col( '.' ) - s:completion.column
 3898              0.006642     endif
 3898              0.023212     return s:completion.completion_start_column - 1
 3898              0.009304   endif
 3898              0.023368   return s:completion.completions

FUNCTION  ale#linter#PreProcess()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:83
Called 10 times
Total time:   0.008743
 Self time:   0.008366

count  total (s)   self (s)
   10              0.000056     if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
   10              0.000014     endif
                            
   10              0.000101     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                            
   10              0.000051     if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
   10              0.000014     endif
                            
   10              0.000051     let l:needs_address = l:obj.lsp is# 'socket'
   10              0.000050     let l:needs_executable = l:obj.lsp isnot# 'socket'
   10              0.000045     let l:needs_command = l:obj.lsp isnot# 'socket'
   10              0.000064     let l:needs_lsp_details = !empty(l:obj.lsp)
                            
   10              0.000035     if empty(l:obj.lsp)
   10              0.000273         let l:obj.callback = get(a:linter, 'callback')
                            
   10   0.000344   0.000255         if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
   10              0.000013         endif
   10              0.000014     endif
                            
   10              0.000132     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
   10              0.000013     endif
                            
   10              0.000032     if !l:needs_executable
                                    if has_key(a:linter, 'executable')|| has_key(a:linter, 'executable_callback')
                                        throw '`executable` and `executable_callback` cannot be used when lsp == ''socket'''
                                    endif
   10              0.000164     elseif has_key(a:linter, 'executable_callback')
                                    let l:obj.executable_callback = a:linter.executable_callback
                            
                                    if !s:IsCallback(l:obj.executable_callback)
                                        throw '`executable_callback` must be a callback if defined'
                                    endif
   10              0.000059     elseif has_key(a:linter, 'executable')
   10              0.000042         let l:obj.executable = a:linter.executable
                            
   10              0.000075         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
   10              0.000014         endif
                                else
                                    throw 'Either `executable` or `executable_callback` must be defined'
   10              0.000012     endif
                            
   10              0.000028     if !l:needs_command
                                    if has_key(a:linter, 'command')|| has_key(a:linter, 'command_callback')|| has_key(a:linter, 'command_chain')
                                        throw '`command` and `command_callback` and `command_chain` cannot be used when lsp == ''socket'''
                                    endif
   10              0.000043     elseif has_key(a:linter, 'command_chain')
                                    let l:obj.command_chain = a:linter.command_chain
                            
                                    if type(l:obj.command_chain) isnot v:t_list
                                        throw '`command_chain` must be a List'
                                    endif
                            
                                    if empty(l:obj.command_chain)
                                        throw '`command_chain` must contain at least one item'
                                    endif
                            
                                    let l:link_index = 0
                            
                                    for l:link in l:obj.command_chain
                                        let l:err_prefix = 'The `command_chain` item ' . l:link_index . ' '
                            
                                        if !s:IsCallback(get(l:link, 'callback'))
                                            throw l:err_prefix . 'must define a `callback` function'
                                        endif
                            
                                        if has_key(l:link, 'output_stream')
                                            if type(l:link.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:link.output_stream) < 0
                                                throw l:err_prefix . '`output_stream` flag must be '   . "'stdout', 'stderr', or 'both'"
                                            endif
                                        endif
                            
                                        if has_key(l:link, 'read_buffer') && !s:IsBoolean(l:link.read_buffer)
                                            throw l:err_prefix . 'value for `read_buffer` must be `0` or `1`'
                                        endif
                            
                                        let l:link_index += 1
                                    endfor
   10              0.000046     elseif has_key(a:linter, 'command_callback')
                                    let l:obj.command_callback = a:linter.command_callback
                            
                                    if !s:IsCallback(l:obj.command_callback)
                                        throw '`command_callback` must be a callback if defined'
                                    endif
   10              0.000039     elseif has_key(a:linter, 'command')
   10              0.000040         let l:obj.command = a:linter.command
                            
   10              0.000074         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
   10              0.000016         endif
                                else
                                    throw 'Either `command`, `executable_callback`, `command_chain` '   . 'must be defined'
   10              0.000012     endif
                            
   10              0.000137     if (   has_key(a:linter, 'command')   + has_key(a:linter, 'command_chain')   + has_key(a:linter, 'command_callback')) > 1
                                    throw 'Only one of `command`, `command_callback`, or `command_chain` '   . 'should be set'
   10              0.000014     endif
                            
   10              0.000027     if !l:needs_address
   10              0.000066         if has_key(a:linter, 'address') || has_key(a:linter, 'address_callback')
                                        throw '`address` or `address_callback` cannot be used when lsp != ''socket'''
   10              0.000012         endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                                elseif has_key(a:linter, 'address_callback')
                                    let l:obj.address_callback = a:linter.address_callback
                            
                                    if !s:IsCallback(l:obj.address_callback)
                                        throw '`address_callback` must be a callback if defined'
                                    endif
                                else
                                    throw '`address` or `address_callback` must be defined for getting the LSP address'
   10              0.000015     endif
                            
   10              0.000032     if l:needs_lsp_details
                                    if has_key(a:linter, 'language_callback')
                                        if has_key(a:linter, 'language')
                                            throw 'Only one of `language` or `language_callback` '   . 'should be set'
                                        endif
                            
                                        let l:obj.language_callback = get(a:linter, 'language_callback')
                            
                                        if !s:IsCallback(l:obj.language_callback)
                                            throw '`language_callback` must be a callback for LSP linters'
                                        endif
                                    else
                                        " Default to using the filetype as the language.
                                        let l:Language = get(a:linter, 'language', a:filetype)
                            
                                        if type(l:Language) is v:t_string
                                            " Make 'language_callback' return the 'language' value.
                                            let l:obj.language = l:Language
                                            let l:obj.language_callback = function('s:LanguageGetter')
                                        elseif type(l:Language) is v:t_func
                                            let l:obj.language_callback = l:Language
                                        else
                                            throw '`language` must be a String or Funcref'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function if defined'
                                        endif
                                    elseif has_key(a:linter, 'project_root_callback')
                                        let l:obj.project_root_callback = a:linter.project_root_callback
                            
                                        if !s:IsCallback(l:obj.project_root_callback)
                                            throw '`project_root_callback` must be a callback if defined'
                                        endif
                                    else
                                        throw '`project_root` or `project_root_callback` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options_callback')
                                        if has_key(a:linter, 'initialization_options')
                                            throw 'Only one of `initialization_options` or '   . '`initialization_options_callback` should be set'
                                        endif
                            
                                        let l:obj.initialization_options_callback = a:linter.initialization_options_callback
                            
                                        if !s:IsCallback(l:obj.initialization_options_callback)
                                            throw '`initialization_options_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a String or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config_callback')
                                        if has_key(a:linter, 'lsp_config')
                                            throw 'Only one of `lsp_config` or `lsp_config_callback` should be set'
                                        endif
                            
                                        let l:obj.lsp_config_callback = a:linter.lsp_config_callback
                            
                                        if !s:IsCallback(l:obj.lsp_config_callback)
                                            throw '`lsp_config_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
   10              0.000013     endif
                            
   10              0.000072     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
   10              0.000105     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
   10              0.000015     endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
   10              0.000057     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
   10   0.000266   0.000174     if !s:IsBoolean(l:obj.lint_file)
                                    throw '`lint_file` must be `0` or `1`'
   10              0.000017     endif
                            
                                " An option indicating that the buffer should be read.
   10              0.000418     let l:obj.read_buffer = get(a:linter, 'read_buffer', !l:obj.lint_file)
                            
   10   0.000340   0.000144     if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
   10              0.000016     endif
                            
   10              0.000034     if l:obj.lint_file && l:obj.read_buffer
                                    throw 'Only one of `lint_file` or `read_buffer` can be `1`'
   10              0.000011     endif
                            
   10              0.000059     let l:obj.aliases = get(a:linter, 'aliases', [])
                            
   10              0.000220     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
   10              0.000013     endif
                            
   10              0.000380     for l:key in filter(keys(a:linter), 'v:val[-9:] is# ''_callback'' || v:val is# ''command_chain''')
                                    if !get(g:, 'ale_ignore_2_4_warnings')
                                        execute 'echom l:key . '' is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
                                    endif
                            
                                    break
   10              0.000020     endfor
                            
   10              0.000042     return l:obj

FUNCTION  <SNR>205_capture()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:39
Called 1 time
Total time:   0.000101
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000028 	if hlexists(a:name) == 0
                            		return ""
    1              0.000001 	endif
    1   0.000069   0.000012 	return s:Message.capture("highlight " . a:name)

FUNCTION  <SNR>273_on_char()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:189
Called 15 times
Total time:   0.057984
 Self time:   0.003301

count  total (s)   self (s)
   15              0.000046   if a:cmdline._does_exit_from_incsearch
                                return
   15              0.000022   endif
   15   0.002479   0.000201   let [raw_pattern, offset] = a:cmdline._parse_pattern()
                            
   15              0.000036   if raw_pattern ==# ''
                                call s:hi.disable_all()
                                nohlsearch
                                return
   15              0.000041   endif
                            
                              " For InsertRegister
   15   0.000223   0.000152   if a:cmdline.get_tap_key() ==# "\<C-r>"
                                let p = a:cmdline.getpos()
                                " Remove `"`
                                let raw_pattern = raw_pattern[:p-1] . raw_pattern[p+1:]
                                let w = winsaveview()
                                call cursor(line('.'), col('.') + len(a:cmdline.backward_word()))
                                call a:cmdline.get_module('InsertRegister').reset()
                                call winrestview(w)
   15              0.000022   endif
                            
   15   0.000604   0.000126   let pattern = a:cmdline._convert(raw_pattern)
                            
                              " Improved Incremental cursor move!
   15   0.013539   0.000309   call s:move_cursor(a:cmdline, pattern, offset)
                            
                              " Improved Incremental highlighing!
                              " case: because matchadd() doesn't handle 'ignorecase' nor 'smartcase'
   15   0.001923   0.000332   let case = incsearch#detect_case(raw_pattern)
   15              0.000105   let should_separate = g:incsearch#separate_highlight && a:cmdline._flag !=# 'n'
   15              0.000192   let pattern_for_hi = (a:cmdline._flag is# 'b' ? s:unescape_question_for_backward(pattern) : pattern) . case
   15   0.036557   0.000570   call incsearch#highlight#incremental_highlight(   pattern_for_hi,   should_separate,   a:cmdline._direction,   [a:cmdline._w.lnum, a:cmdline._w.col])
                            
                              " functional `normal! zz` after scroll for <expr> mappings
   15   0.001372   0.000324   if ( a:cmdline.is_input('<Over>(incsearch-scroll-f)') || a:cmdline.is_input('<Over>(incsearch-scroll-b)'))
                                call winrestview({'topline': max([1, line('.') - winheight(0) / 2])})
   15              0.000023   endif

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:67
Called 67585 times
Total time:  18.275381
 Self time:   8.961868

count  total (s)   self (s)
67585              2.241612   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
67585              0.514232   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
67585              0.106876   else
67585   5.180322   0.974825     let fg = s:get_syn(a:group, 'fg')
67585   4.989027   0.925050     let bg = s:get_syn(a:group, 'bg')
67585              0.830970     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
67585              0.148538     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
67585              0.108914     else
67585   2.130598   1.086559       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
67585              0.105071     endif
67585              0.094257   endif
67585              0.465361   let s:hl_groups[a:group] = res
67585              0.147179   return res

FUNCTION  ale#history#Add()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:12
Called 2894 times
Total time:   0.209664
 Self time:   0.209664

count  total (s)   self (s)
 2894              0.011414     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
 2894              0.004630     endif
                            
 2894              0.025935     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
 2894              0.017840     if len(l:history) >= g:ale_max_buffer_history_size
 2874              0.030036         let l:history = l:history[1:]
 2894              0.005103     endif
                            
 2894              0.040858     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
 2894              0.040321     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  EasyMotion#helper#VarReset()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:111
Called 28 times
Total time:   0.001670
 Self time:   0.001617

count  total (s)   self (s)
   28              0.000164     if ! exists('s:var_reset')
    1              0.000005         let s:var_reset = {}
   28              0.000042     endif
                            
   28              0.000146     if a:0 == 0 && has_key(s:var_reset, a:var)
                                    " Reset var to original value
                                    " setbufvar( or bufname): '' or '%' can be used for the current buffer
   14   0.000248   0.000218         call setbufvar('%', a:var, s:var_reset[a:var])
   14              0.000030     elseif a:0 == 1
                                    " Save original value and set new var value
                            
   14              0.000045         let new_value = a:0 == 1 ? a:1 : ''
                            
                                    " Store original value
   14              0.000098         let s:var_reset[a:var] = getbufvar("", a:var)
                            
                                    " Set new var value
   14   0.000188   0.000165         call setbufvar('%', a:var, new_value)
   28              0.000045     endif

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:27
Called 51160 times
Total time:   3.101665
 Self time:   2.033623

count  total (s)   self (s)
51160   1.991498   0.923456   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
    4              0.000015     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '‚Ä¶'.matchstr(a:text, '.\{'.a:minwidth.'}$')
    4              0.000005     else
                                  " shorten from beginning of string
    4              0.000067       return matchstr(a:text, '^.\{'.a:minwidth.'}').'‚Ä¶'
                                endif
51156              0.073739   else
51156              0.141916     return a:text
                              endif

FUNCTION  <SNR>203__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:22
Called 1 time
Total time:   0.000081
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000078   0.000008 	let s:String  = s:V.import("Over.String")

FUNCTION  <SNR>221__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Keymapping.vim:24
Called 1 time
Total time:   0.000844
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000841   0.000008 	let s:Capture  = s:V.import("Palette.Capture")

FUNCTION  <SNR>249_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Cancel.vim:28
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	return deepcopy(s:module)

FUNCTION  vital#_incsearch#Over#String#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:7
Called 1 time
Total time:   0.000130
 Self time:   0.000093

count  total (s)   self (s)
    1   0.000130   0.000093 return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>240_' . v:key)")

FUNCTION  <SNR>123_ReloadWinStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2438
Called 51 times
Total time:   0.000574
 Self time:   0.000574

count  total (s)   self (s)
   51              0.000421   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
   51              0.000086     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  631()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 3 times
Total time:   0.000261
 Self time:   0.000129

count  total (s)   self (s)
    3              0.000015     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
    3              0.000003     endif
    3   0.000189   0.000057     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000010     if bufnum == bufnr('%')
    3              0.000017       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000003     endif
    3              0.000006     return group

FUNCTION  <SNR>157_AppendChild()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:69
Called 1 time
Total time:   0.000150
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000003   if has_key(a:line, 'scope')
    1   0.000134   0.000012     call s:Append(a:line, a:rows, a:depth)
    1              0.000003     let parent_name = a:line.scope
    1              0.000006     let next_root_name = parent_name . s:scope_seperator . a:line.name
    1              0.000003     return [next_root_name, a:line]
                              endif
                            
                              return [v:null, v:null]

FUNCTION  <SNR>109_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:178
Called 62 times
Total time:   0.002594
 Self time:   0.002594

count  total (s)   self (s)
   62              0.000889   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   11              0.000032     return
   51              0.000089   endif
   51              0.000340   unlet! b:airline_whitespace_check
   51              0.000315   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
   51              0.000076   endif
   51              0.000332   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:229
Called 541 times
Total time:   0.403741
 Self time:   0.039585

count  total (s)   self (s)
  541              0.004285   if getbufvar(a:bufnr, '&modified')
  459              0.010023     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   82              0.000153   else
   82              0.001949     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
  541              0.000976   endif
                            
  541              0.001965   if !empty(colors)
  541   0.377108   0.012952     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
  541              0.000810   endif

FUNCTION  vital#_easymotion#Prelude#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Prelude.vim:5
Called 1 time
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    1              0.000152     return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''},  'function("s:" . v:key)')

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:293
Called 17052 times
Total time:  30.278775
 Self time:   1.486058

count  total (s)   self (s)
17052  27.980750   0.314919   let head = airline#extensions#branch#head()
17052   0.450969   0.316167   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
17052              0.138311   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
17052   1.267708   0.275624   let head = airline#util#shorten(head, winwidth, minwidth)
17052              0.154044   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
17052              0.250339   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  riv#insert#shiftright()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/insert.vim:155
Called 6 times
Total time:   0.005111
 Self time:   0.000260

count  total (s)   self (s)
    6              0.000058     let sft = &sw
    6   0.004949   0.000098     let fix_sft = riv#insert#fixed_sft(a:row,a:col,sft)
    6              0.000096     return repeat("\<Space>", abs(fix_sft))

FUNCTION  <SNR>36_right()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:127
Called 7 times
Total time:   0.000683
 Self time:   0.000502

count  total (s)   self (s)
    7   0.000675   0.000494   return repeat(s:Right, s:ulen(a:s))

FUNCTION  incsearch#config#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/config.vim:46
Called 3 times
Total time:   0.000978
 Self time:   0.000153

count  total (s)   self (s)
    3   0.000178   0.000067   let default = extend(deepcopy(s:config), s:lazy_config())
    3   0.000760   0.000046   let c = s:U.deepextend(default, a:additional)
    3              0.000006   if c.prompt is# ''
    3              0.000008     let c.prompt = c.command
    3              0.000003   endif
    3              0.000006   return c

FUNCTION  <SNR>266__maparg()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:92
Called 20 times
Total time:   0.000773
 Self time:   0.000773

count  total (s)   self (s)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
   20              0.000059 	if a:name ==# "<^?>"
                            		return maparg("\<C-?>", a:mode, a:abbr, a:dict)
   20              0.000028 	endif
   20              0.000586 	return maparg(a:name, a:mode, a:abbr, a:dict)

FUNCTION  <SNR>194_should_use_migemo()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:646
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000014     if ! g:EasyMotion_use_migemo || match(a:char, '[^!-~]') != -1
    2              0.000003         return 0
                                endif
                            
                                " TODO: use direction to improve
                                if s:flag.within_line == 1
                                    let first_line = line('.')
                                    let end_line = line('.')
                                else
                                    let first_line = line('w0')
                                    let end_line = line('w$')
                                endif
                            
                                " Skip folded line and check if text include multibyte characters
                                for line in range(first_line, end_line)
                                    if EasyMotion#helper#is_folded(line)
                                        continue
                                    endif
                            
                                    if EasyMotion#helper#include_multibyte_char(getline(line)) == 1
                                        return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>146_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:561
Called 474 times
Total time:   0.055630
 Self time:   0.055630

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
  474              0.002631     let l:name_map = {}
                            
 3792              0.012701     for l:linter in a:linters
 3318              0.020261         let l:name_map[l:linter.name] = 1
 3792              0.006714     endfor
                            
  474              0.008942     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  riv#list#get_con_idt()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/list.vim:716
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000027     return matchend(a:line, s:p.all_list)+1  

FUNCTION  450()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/bracketed_paste.vim:17
Called 3 times
Total time:   0.000136
 Self time:   0.000128

count  total (s)   self (s)
    3              0.000031   if !exists('&t_BE')
                                return
    3              0.000006   endif
    3              0.000009   let self.t_BE = &t_BE
    3   0.000079   0.000071   set t_BE=

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:24
Called 17217 times
Total time:   0.526737
 Self time:   0.526737

count  total (s)   self (s)
17217              0.134476   let bvars = getbufvar(a:buffer, '')
17217              0.076041   if !empty(bvars)
17217              0.109498     let dict = get(bvars, 'gitgutter', {})
17217              0.102241     if has_key(dict, a:varname)
17179              0.072799       return dict[a:varname]
   38              0.000086     endif
   38              0.000056   endif
   38              0.000085   if a:0
   38              0.000108     return a:1
                              endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:67
Called 50 times
Total time:   0.002543
 Self time:   0.002543

count  total (s)   self (s)
   50              0.000501     let l:info = get(s:buffer_data, a:buffer, {})
                            
   50              0.000246     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
                                    if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
                                    for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
                                    for l:directory in l:info.directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    call remove(s:buffer_data, a:buffer)
   50              0.000088     endif

FUNCTION  453()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:52
Called 57 times
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
   57              0.000341 	return has_key(self.variables.hl_list, a:name)

FUNCTION  <SNR>197_plugin_name()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:127
Called 31 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   31              0.000079   return self._plugin_name

FUNCTION  <SNR>120_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:185
Called 1066 times
Total time:   0.020640
 Self time:   0.020640

count  total (s)   self (s)
 1066              0.003335   let start=1
                            
                              " do not check for inactive windows or the tabline
 1066              0.003478   if a:self._context.active == 0
   35              0.000062     return 0
 1031              0.005940   elseif get(a:self._context, 'tabline', 0)
  956              0.001938     return 0
   75              0.000103   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   75              0.000481   if get(g:, 'airline_skip_empty_sections', 0) == 0
   75              0.000138     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>67_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim81/plugin/matchparen.vim:39
Called 13762 times
Total time:   4.544641
 Self time:   4.544641

count  total (s)   self (s)
                              " Remove any previous match.
13762              0.141611   if exists('w:paren_hl_on') && w:paren_hl_on
  206              0.001715     silent! call matchdelete(3)
  206              0.000875     let w:paren_hl_on = 0
13762              0.026880   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
13762              0.106605   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
13762              0.022729   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
13762              0.078864   let c_lnum = line('.')
13762              0.065446   let c_col = col('.')
13762              0.037721   let before = 0
                            
13762              0.073380   let text = getline(c_lnum)
13762              0.786500   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
13762              0.061972   if empty(matches)
                                let [c_before, c] = ['', '']
13762              0.023522   else
13762              0.113007     let [c_before, c] = matches[1:2]
13762              0.022436   endif
13762              0.302508   let plist = split(&matchpairs, '.\zs[:,]')
13762              0.082942   let i = index(plist, c)
13762              0.034425   if i < 0
                                " not found, in Insert mode try character before the cursor
13564              0.098416     if c_col > 1 && (mode() == 'i' || mode() == 'R')
10871              0.054806       let before = strlen(c_before)
10871              0.035177       let c = c_before
10871              0.051688       let i = index(plist, c)
13564              0.020943     endif
13564              0.029953     if i < 0
                                  " not found, nothing to do
13551              0.030808       return
   13              0.000018     endif
  211              0.000290   endif
                            
                              " Figure out the arguments for searchpairpos().
  211              0.000516   if i % 2 == 0
    6              0.000016     let s_flags = 'nW'
    6              0.000029     let c2 = plist[i + 1]
  205              0.000280   else
  205              0.000678     let s_flags = 'nbW'
  205              0.000518     let c2 = c
  205              0.000997     let c = plist[i - 1]
  211              0.000323   endif
  211              0.000526   if c == '['
   13              0.000025     let c = '\['
   13              0.000028     let c2 = '\]'
  211              0.000307   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  211              0.000461   if before > 0
   13              0.000105     let has_getcurpos = exists("*getcurpos")
   13              0.000031     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
   13              0.000070       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
   13              0.000019     endif
   13              0.000092     call cursor(c_lnum, c_col - before)
  211              0.000292   endif
                            
  211              0.002622   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
  211              0.000301   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
  211              0.002403     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  211              0.000492     try
  211              0.796955       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
  211              0.000458     endtry
  211              0.000360   endif
                            
                              " Limit the search to lines visible in the window.
  211              0.002387   let stoplinebottom = line('w$')
  211              0.001211   let stoplinetop = line('w0')
  211              0.000861   if i % 2 == 0
    6              0.000019     let stopline = stoplinebottom
  205              0.000400   else
  205              0.000776     let stopline = stoplinetop
  211              0.000303   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  211              0.001397   if mode() == 'i' || mode() == 'R'
  184              0.002223     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   27              0.000041   else
   27              0.000318     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  211              0.000304   endif
  211              0.000348   try
  211              0.983845     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  211              0.000531   endtry
                            
  211              0.000604   if before > 0
   13              0.000029     if has_getcurpos
   13              0.000116       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
   13              0.000019     endif
  211              0.000280   endif
                            
                              " If a match is found setup match highlighting.
  211              0.001116   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  206              0.001270     if exists('*matchaddpos')
  206              0.015052       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
  206              0.000304     endif
  206              0.001019     let w:paren_hl_on = 1
  211              0.000350   endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:56
Called 35 times
Total time:   0.011647
 Self time:   0.002766

count  total (s)   self (s)
   35   0.011575   0.002694   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>50_onChange()
    Defined: ~/.vim/plugged/cscope.vim/plugin/cscope.vim:343
Called 51 times
Total time:   0.010583
 Self time:   0.010583

count  total (s)   self (s)
   51              0.008926   if expand('%:t') =~? g:cscope_interested_files
                                let m_dir = <SID>GetBestPath(expand('%:p:h'))
                                if m_dir != ""
                                  let s:dbs[m_dir]['dirty'] = 1
                                  call <SID>FlushIndex()
                                  call <SID>CheckNewFile(m_dir, expand('%:p'))
                                  redraw
                                  call <SID>echo('Your cscope db will be updated automatically, you can turn off this message by setting g:cscope_silent 1.')
                                endif
   51              0.000073   endif

FUNCTION  <SNR>123_DoAutocmd()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:141
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000010   if v:version >= 704 || (v:version == 703 && has('patch442'))
    2              0.000007     return 'doautocmd <nomodeline>' . a:cmd
                              elseif &modelines > 0
                                return 'try|set modelines=0|doautocmd ' . a:cmd . '|finally|set modelines=' . &modelines . '|endtry'
                              else
                                return 'doautocmd ' . a:cmd
                              endif

FUNCTION  <SNR>204__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:21
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004 	let s:V = a:V

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:62
Called 68216 times
Total time:   1.087152
 Self time:   1.087152

count  total (s)   self (s)
68216              0.340345   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
68216              0.100942   endif
68216              0.455634   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  vital#_incsearch#Palette#Capture#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Capture.vim:7
Called 1 time
Total time:   0.000047
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000047   0.000034 return map({'extend': '', 'command': ''}, "vital#_incsearch#function('<SNR>267_' . v:key)")

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:137
Called 3 times
Total time:   0.001040
 Self time:   0.001040

count  total (s)   self (s)
    3              0.000040   let path = substitute(a:path, '[\/]$', '', '') . '/'
    3              0.000996   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:103
Called 2190 times
Total time:   0.298678
 Self time:   0.194076

count  total (s)   self (s)
 2190              0.014629     let l:buffer = bufnr('')
                            
 2190              0.009611     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
 2190              0.003393     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
 2190              0.010269     if mode(1) isnot# 'n'
  185              0.000412         return
 2005              0.002978     endif
                            
 2005   0.086799   0.035677     call s:StopCursorTimer()
                            
 2005              0.021433     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
 2005              0.008351     if l:pos != s:last_pos
 1878   0.080705   0.027225         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
 1878              0.008319         let s:last_pos = l:pos
 1878              0.020776         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
 2005              0.004044     endif

FUNCTION  <SNR>35_SetupAutoCommands()
    Defined: ~/.vim/plugged/vim-better-whitespace/plugin/better-whitespace.vim:334
Called 9 times
Total time:   0.004970
 Self time:   0.003343

count  total (s)   self (s)
    9              0.000061     augroup better_whitespace
                                    " Reset all auto commands in group
    9              0.002062         autocmd!
                            
    9   0.000432   0.000147         if <SID>ShouldHighlight()
    9              0.000039             if s:better_whitespace_initialized == 0
                                            call <SID>WhitespaceInit()
    9              0.000015             endif
                            
                                        " Highlight extraneous whitespace at the end of lines, but not the current line in insert mode.
    9   0.001219   0.000146             call <SID>HighlightEOLWhitespace()
    9              0.000150             autocmd CursorMovedI,InsertEnter * call <SID>HighlightEOLWhitespaceExceptCurrentLine()
    9              0.000105             autocmd InsertLeave,BufReadPost * call <SID>HighlightEOLWhitespace()
                            
    9              0.000037             if g:current_line_whitespace_disabled_soft == 0
                                            " Using syntax: clear whitespace highlighting when leaving buffer
    9              0.000057                 autocmd BufWinLeave * call <SID>ClearHighlighting()
                            
                                            " Do not highlight whitespace on current line in insert mode
    9              0.000056                 autocmd CursorMovedI * call <SID>HighlightEOLWhitespaceExceptCurrentLine()
                            
                                            " Do not highlight whitespace on current line in normal mode?
    9              0.000033                 if g:current_line_whitespace_disabled_hard == 1
                                                autocmd CursorMoved * call <SID>HighlightEOLWhitespaceExceptCurrentLine()
    9              0.000024                 endif
    9              0.000010             endif
                            
                                    elseif s:better_whitespace_initialized == 1
                                        " Clear highlighting if it disabled, as it might have just been toggled
                                        call <SID>ClearHighlighting()
    9              0.000011         endif
                            
                                    " Strip whitespace on save if enabled.
    9   0.000416   0.000147         if <SID>ShouldStripWhitespaceOnSave()
                                        autocmd BufWritePre * call <SID>StripWhitespaceOnSave(v:cmdbang)
    9              0.000014         endif
                            
    9              0.000018     augroup END

FUNCTION  <SNR>287_get_parent()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/list.vim:93
Called 1 time
Total time:   0.000093
 Self time:   0.000031

count  total (s)   self (s)
                               
    1   0.000075   0.000013     let row = s:get_list(a:row)
    1              0.000002     if row == 0
                                    return 0
    1              0.000001     else
                            
    1              0.000004         let save_pos = getpos('.')
                            
    1              0.000004         let c_idt = indent(row)
    1              0.000002         if c_idt == 0 
    1              0.000002             return 0
                                    endif
                                    let idt_ptn = '^\s\{,'.(c_idt-1).'}\S'
                            
                                    call cursor(row,1)
                                    let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                    let idt = indent(row)
                                    
                                    while getline(row) !~ s:p.b_e_list && row != 0
                                        if idt == 0 
                                            let row = 0
                                            break
                                        endif
                                        let idt_ptn = '^\s\{,'.idt.'}\S'
                                        let [row,col] = searchpos(idt_ptn, 'b',0,100)
                                        let idt = indent(row)
                                    endwhile
                            
                                    call setpos('.',save_pos)
                            
                                    return idt < c_idt ? row : 0
                                endif

FUNCTION  <SNR>136_CloseCompletionMenu()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:706
Called 14730 times
Total time:   0.228287
 Self time:   0.203444

count  total (s)   self (s)
14730              0.069050   if pumvisible()
 2063   0.061982   0.037139     call s:SendKeys( "\<C-e>" )
14730              0.024678   endif

FUNCTION  <SNR>229__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Guard.vim:25
Called 1 time
Total time:   0.001323
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000005   let s:V = a:V
    1   0.000125   0.000014   let s:Prelude = s:V.import('Prelude')
    1   0.000136   0.000015   let s:List = s:V.import('Data.List')
    1   0.001057   0.000010   let s:Dict = s:V.import('Data.Dict')

FUNCTION  <SNR>238__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Maker.vim:31
Called 1 time
Total time:   0.011839
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000002 	let s:V = a:V
    1   0.011764   0.000009 	let s:Cmdline = s:V.import("Over.Commandline.Base")
    1   0.000072   0.000010 	let s:Modules = s:V.import("Over.Commandline.Modules")

FUNCTION  <SNR>190_GroupLoclistItems()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:235
Called 50 times
Total time:   0.002247
 Self time:   0.002247

count  total (s)   self (s)
   50              0.000179     let l:grouped_items = []
   50              0.000163     let l:last_lnum = -1
                            
   50              0.000137     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
   50              0.000130     endfor
                            
   50              0.000157     return l:grouped_items

FUNCTION  <SNR>231_emulate_search_warning()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:394
Called 3 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
                              " NOTE:
                              " - It should use :h echomsg considering emulation of default
                              "   warning messages remain in the :h message-history, but it'll mess
                              "   up the message-history unnecessary, so it use :h echo
                              " - See :h shortmess
                              " if &shortmess !~# 's' && g:incsearch#do_not_save_error_message_history
    3              0.000048   if &shortmess !~# 's' && g:incsearch#do_not_save_error_message_history
                                let from = [a:from.lnum, a:from.col]
                                let to = [a:to.lnum, a:to.col]
                                let old_warningmsg = v:warningmsg
                                let v:warningmsg =   ( a:direction == s:DIRECTION.forward && !s:U.is_pos_less_equal(from, to)   ? 'search hit BOTTOM, continuing at TOP'   : a:direction == s:DIRECTION.backward && s:U.is_pos_less_equal(from, to)   ? 'search hit TOP, continuing at BOTTOM'   : '' )
                                if v:warningmsg !=# ''
                                  call s:Warning(v:warningmsg)
                                else
                                  let v:warningmsg = old_warningmsg
                                endif
    3              0.000005   endif

FUNCTION  <SNR>142_evaluate_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:209
Called 532 times
Total time:   0.077579
 Self time:   0.054236

count  total (s)   self (s)
  532              0.002462   let tabline = a:tabline
  532   0.037541   0.014198   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
  532              0.009807   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
  532              0.005990   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
  532              0.004506   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
  532              0.003676   let tabline = substitute(tabline, '%=', '', 'g')
  532              0.004016   let tabline = substitute(tabline, '%\d*\*', '', 'g')
  532              0.004145   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
  532              0.000815   endif
  532              0.001284   return tabline

FUNCTION  <SNR>157_RenderScopeless()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:205
Called 1 time
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    1              0.000002   let rows = a:rows
    1              0.000003   let scope_less = a:scope_less
                            
    1              0.000003   for kind in keys(scope_less)
                                let kind_line = vista#renderer#Decorate(kind)
                                call add(rows, g:vista_fold_toggle_icons[0].' '.kind_line)
                            
                                let lines = scope_less[kind]
                            
                                if get(t:vista, 'sort', v:false)
                                  let lines = sort(copy(lines), function('s:SortCompare'))
                                endif
                            
                                for line in lines
                                  let row = vista#util#Join( '  '.s:GetVisibility(line), get(line, 'name'), get(line, 'signature', ''), ':'.line.line )
                            
                                  call add(rows, row)
                            
                                  let line.vlnum = len(rows) + 2
                                endfor
                            
                                call add(rows, '')
                                call add(s:vlnum_cache, '')
    1              0.000002   endfor
                            
                              " Remove the last line if it's empty, i.e., ''
    1              0.000006   if !empty(rows) && empty(rows[-1])
    1              0.000004     unlet rows[-1]
    1              0.000001   endif

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:3
Called 24 times
Total time:   0.004632
 Self time:   0.001030

count  total (s)   self (s)
   24   0.001769   0.000510   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   24   0.002811   0.000468   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>126_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:168
Called 28 times
Total time:   0.001327
 Self time:   0.000582

count  total (s)   self (s)
   28   0.001301   0.000556   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  airline#extensions#vista#currenttag()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/vista.vim:7
Called 17054 times
Total time:   0.225918
 Self time:   0.225918

count  total (s)   self (s)
17054              0.099291   if get(w:, 'airline_active', 0)
17052              0.109239     return get(b:, 'vista_nearest_method_or_function', '')
    2              0.000004   endif

FUNCTION  <SNR>199_length()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:158
Called 10 times
Total time:   0.000776
 Self time:   0.000231

count  total (s)   self (s)
   10   0.000768   0.000223 	return len(s:split_by_keys(a:str))

FUNCTION  397()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim:63
Called 15 times
Total time:   0.001329
 Self time:   0.000953

count  total (s)   self (s)
   15   0.000482   0.000106 	if a:cmdline.is_input("\<C-k>")
                            		if empty(self.digraphs)
                            			" Get digraphs when inputting <C-k> instead of on_enter because it cause
                            			" flicker in some environments #107
                            			let self.digraphs = s:digraph()
                            		endif
                            		call a:cmdline.setchar('?')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
   15              0.000100 	elseif exists("self.prefix_key")		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let x = a:cmdline.input_key()
                            		let y = s:Input.getchar()
                            		" For CTRL-K, there is one general digraph: CTRL-K <Space> {char} will
                            		" enter {char} with the highest bit set.  You can use this to enter
                            		" meta-characters.
                            		let char = x ==# "\<Space>" ?	nr2char(char2nr(y) + 128) : get(self.digraphs, x . y, y)
                            		call a:cmdline.setchar(char)
   15              0.000022 	endif

FUNCTION  vista#sidebar#Toggle()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:144
Called 2 times
Total time:   0.044303
 Self time:   0.000113

count  total (s)   self (s)
    2   0.000184   0.000048   if vista#sidebar#IsVisible()
    1   0.041326   0.000031     call vista#sidebar#Close()
    1              0.000002   else
    1   0.002775   0.000016     call vista#sidebar#Open()
    2              0.000002   endif

FUNCTION  airline#extensions#undotree#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/undotree.vim:11
Called 9 times
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
    9              0.000049   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{exists("t:undotree") ? t:undotree.GetStatusLine() : ""}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{exists("t:diffpanel") ? t:diffpanel.GetStatusLine() : ""}')
                                endif
    9              0.000013   endif

FUNCTION  <SNR>229__vital_created()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Guard.vim:34
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
                              " define constant variables
    1              0.000005   if !exists('s:const')
    1              0.000004     let s:const = {}
    1              0.000010     let s:const.is_local_variable_supported = v:version > 703 || (v:version == 703 && has('patch560'))
                                " NOTE:
                                " The third argument is available from 7.4.242 but it had bug and that
                                " bug was fixed from 7.4.513
    1              0.000012     let s:const.is_third_argument_of_getreg_supported = has('patch-7.4.513')
    1              0.000003     lockvar s:const
    1              0.000002   endif
    1              0.000007   call extend(a:module, s:const)

FUNCTION  <SNR>101_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:37
Called 135170 times
Total time:   8.269474
 Self time:   8.269474

count  total (s)   self (s)
135170              0.780133   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
135170              0.197376   endif
135170              0.332910   let color = ''
135170              1.129078   if hlexists(a:group)
131038              1.743809     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
135170              0.209047   endif
135170              0.623279   if empty(color) || color == -1
                                " should always exists
 4132              0.181913     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
 4132              0.020106     if empty(color) || color == -1
                                  let color = 'NONE'
 4132              0.006133     endif
135170              0.184679   endif
135170              0.318475   return color

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:81
Called 16 times
Total time:   0.042393
 Self time:   0.003969

count  total (s)   self (s)
  118              0.000442     for Fn in a:list
  118   0.040990   0.002566       let code = call(Fn, a:000)
  118              0.000283       if code != 0
   16              0.000039         return code
  102              0.000143       endif
  102              0.000173     endfor
                                return 0

FUNCTION  riv#path#rel_to()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:77
Called 51 times
Total time:   0.005901
 Self time:   0.004515

count  total (s)   self (s)
                                " return the relative path to 'dir', 
                                "
                                " >>> echom riv#path#rel_to('/etc/X11/', '/etc/X11/home')
                                " home
                                " >>> echom riv#path#rel_to('/etc/X11/', '/etc/home')
                                " ../home
                                " >>> echom riv#path#rel_to('/etc/X11/', '/tc/home')
                                " Riv: Note a related path
                                
   51   0.001414   0.000791     let dir = riv#path#is_directory(a:dir) ? a:dir : fnamemodify(a:dir,':h') . '/'
   51              0.000488     let dir = fnamemodify(dir, ':gs?\?/?') 
   51              0.000415     let path = fnamemodify(a:path, ':gs?\?/?') 
   51              0.000452     if match(path, dir) == -1
   51   0.001679   0.000916         let p = riv#path#is_directory(path) ? path : fnamemodify(path,':h') . '/'
   51              0.000258         let tail = fnamemodify(path,':t')
   51              0.000526         if match(dir, p) == -1
   50            1118.545540             throw g:_riv_e.NOT_REL_PATH
                                    endif
                                    let f = substitute(dir, p, '','')
                                    let dot = substitute(f,'[^/]\+/','../','g')
                                    return dot.tail
                                endif
                                return substitute(path, dir, '', '')

FUNCTION  <SNR>273_on_searching()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:67
Called 30 times
Total time:   0.071449
 Self time:   0.003149

count  total (s)   self (s)
   30              0.000063   try
   30   0.068860   0.000560     return call(a:func, a:000)
                              catch /E16:/  " E16: Invalid range  (with /\_[a- )
                              catch /E33:/  " E33: No previous substitute regular expression
                              catch /E53:/  " E53: Unmatched %(
                              catch /E54:/
                              catch /E55:/
                              catch /E62:/  " E62: Nested \= (with /a\=\=)
                              catch /E63:/  " E63: invalid use of \_
                              catch /E64:/  " E64: \@ follows nothing
                              catch /E65:/  " E65: Illegal back reference
                              catch /E66:/  " E66: \z( not allowed here
                              catch /E67:/  " E67: \z1 et al. not allowed here
                              catch /E68:/  " E68: Invalid character after \z (with /\za & re=1)
                              catch /E69:/  " E69: Missing ] after \%[
                              catch /E70:/  " E70: Empty \%[]
                              catch /E71:/  " E71: Invalid character after \%
                              catch /E554:/
                              catch /E678:/ " E678: Invalid character after \%[dxouU]
                              catch /E864:/ " E864: \%#= can only be followed by 0, 1, or 2. The
                                            "       automatic engine will be used
                              catch /E865:/ " E865: (NFA) Regexp end encountered prematurely
                              catch /E866:/ " E866: (NFA regexp) Misplaced @
                              catch /E867:/ " E867: (NFA) Unknown operator
                              catch /E869:/ " E869: (NFA) Unknown operator '\@m
                              catch /E870:/ " E870: (NFA regexp) Error reading repetition limits
                              catch /E871:/ " E871: (NFA regexp) Can't have a multi follow a multi !
                              catch /E874:/ " E874: (NFA) Could not pop the stack ! (with \&)
                              catch /E877:/ " E877: (NFA regexp) Invalid character class: 109
                              catch /E888:/ " E888: (NFA regexp) cannot repeat (with /\ze*)
                                call s:hi.disable_all()
                              catch
                                echohl ErrorMsg | echom v:throwpoint . ' ' . v:exception | echohl None
   30              0.000057   endtry

FUNCTION  <SNR>211_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim:50
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007 	return deepcopy(s:module)

FUNCTION  <SNR>240__split_keystring()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:133
Called 31 times
Total time:   0.001044
 Self time:   0.001044

count  total (s)   self (s)
   31              0.001023 	return split(a:str, s:_engine . '\m\%(' . get(a:, 1, '') . s:_regex . '\)')

FUNCTION  399()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Delete.vim:18
Called 15 times
Total time:   0.002979
 Self time:   0.001383

count  total (s)   self (s)
   15   0.000815   0.000188 	if a:cmdline.is_input("\<C-h>")	|| a:cmdline.is_input("\<BS>")
                            		if a:cmdline.line.length() == 0
                            			return a:cmdline.exit(1)
                            		else
                            			call a:cmdline.line.remove_prev()
                            			call a:cmdline.setchar('')
                            		endif
   15   0.000406   0.000102 	elseif a:cmdline.is_input("\<Del>")
                            		call a:cmdline.line.remove_pos()
                            		call a:cmdline.setchar('')
   15   0.000455   0.000112 	elseif a:cmdline.is_input("\<C-w>")
                            		let word = a:cmdline.backward_word()
                            		let backward = a:cmdline.backward()[ : -strlen(word)-1 ]
                            		call a:cmdline.setline(backward . a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(strchars(backward))
                            		call a:cmdline.setchar('')
   15   0.000424   0.000102 	elseif a:cmdline.is_input("\<C-u>")
                            		call a:cmdline.setline(a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
   15              0.000020 	endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:23
Called 35 times
Total time:   0.093614
 Self time:   0.008649

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   35   0.012585   0.000938   if gitgutter#utility#is_active(a:bufnr)
                            
   28              0.000381     if has('patch-7.4.1559')
   28              0.000439       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   28              0.000101     endif
   28   0.003676   0.000789     let how = s:setup_path(a:bufnr, l:Callback)
   28              0.000107     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
   28              0.000048     endif
                            
   28   0.001855   0.000528     if a:force || s:has_fresh_changes(a:bufnr)
                            
   24              0.000057       let diff = ''
   24              0.000048       try
   24   0.070891   0.001787         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
   24              0.000061       endtry
                            
   24              0.000109       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
   24              0.000035       endif
                            
   28              0.000047     endif
   35              0.000062   endif

FUNCTION  riv#debug()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv.vim:37
Called 51 times
Total time:   5.515602
 Self time:   5.515602

count  total (s)   self (s)
   51              5.514442     redraw
   51              0.000340     if g:riv_debug
                                    echohl KeyWord
                                    echom "[RIV]"
                                    echohl Normal
                                    echon a:msg
   51              0.000133     endif

FUNCTION  incsearch#util#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:41
Called 5 times
Total time:   0.001002
 Self time:   0.000886

count  total (s)   self (s)
    5   0.000184   0.000068   let prefix = '<SNR>' . s:SID() . '_'
    5              0.000014   let module = {}
   60              0.000125   for func in s:functions
   55              0.000475     let module[func] = function(prefix . func)
   60              0.000118   endfor
    5              0.000045   return copy(module)

FUNCTION  <SNR>204_get()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:26
Called 15 times
Total time:   0.019612
 Self time:   0.000530

count  total (s)   self (s)
   15              0.000124 	if exists("s:" . a:name)
                            		return s:{a:name}
   15              0.000018 	endif
   15   0.019360   0.000278 	let s:{a:name} = s:V.import('Over.Commandline.Modules.' . a:name)
   15              0.000060 	return s:{a:name}

FUNCTION  <SNR>251__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim:14
Called 1 time
Total time:   0.000071
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000070   0.000007 	let s:Input = a:V.import("Over.Input")

FUNCTION  <SNR>157_DescendantsOfRoot()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:135
Called 1 time
Total time:   0.000399
 Self time:   0.000200

count  total (s)   self (s)
    1   0.000247   0.000175   let candidates = filter(copy(a:candidates), 'has_key(v:val, ''scope'')'. ' && s:StartWith(v:val.scope, a:root_line.name)'. ' && v:val.scopeKind ==# a:root_line.kind'. ' && v:val.line >= a:root_line.line' )
                            
    1   0.000150   0.000023   return filter(candidates, 's:RealParentOf(v:val) ==# a:root_line')

FUNCTION  <SNR>207_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim:34
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004 	return deepcopy(s:module)

FUNCTION  <SNR>136_ClosePreviewWindowIfNeeded()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:833
Called 424 times
Total time:   0.025374
 Self time:   0.025374

count  total (s)   self (s)
  424              0.004280   let current_buffer_name = bufname('')
                            
                              " We don't want to try to close the preview window in special buffers like
                              " "[Command Line]"; if we do, Vim goes bonkers. Special buffers always start
                              " with '['.
  424              0.008901   if current_buffer_name[ 0 ] == '['
                                return
  424              0.000867   endif
                            
                              " This command does the actual closing of the preview window. If no preview
                              " window is shown, nothing happens.
  424              0.000994   pclose

FUNCTION  <SNR>112_update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:57
Called 2 times
Total time:   0.039103
 Self time:   0.000193

count  total (s)   self (s)
    2              0.000017   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
    2              0.000003   endif
    2              0.000020   let match = expand('<afile>')
    2              0.000006   if pumvisible()
                                return
    2              0.000010   elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
    2   0.000164   0.000047   elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(expand("<afile>"))
                                return
    2              0.000002   endif
    2   0.000186   0.000022   call airline#util#doautocmd('BufMRUChange')
    2   0.038677   0.000048   call airline#extensions#tabline#redraw()

FUNCTION  <SNR>154_Lint()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:99
Called 476 times
Total time:   2.707897
 Self time:   0.122463

count  total (s)   self (s)
                                " Use the filetype from the buffer
  476              0.004461     let l:filetype = getbufvar(a:buffer, '&filetype')
  476   0.416007   0.010897     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
  476   0.021303   0.008096     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
  476   0.018322   0.008057     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
  476              0.006539     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
  476              0.002442     let g:ale_want_results_buffer = a:buffer
  476   0.054063   0.041901     silent doautocmd <nomodeline> User ALEWantResults
  476              0.002937     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
  476              0.006439     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
    2              0.000003         return
  474              0.000904     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
  474              0.009993     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
  474   2.157878   0.013188     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  <SNR>22_SetUpForNewFiletype()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim:524
Called 8 times
Total time:   0.001842
 Self time:   0.001085

count  total (s)   self (s)
    8              0.000040     let ft = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    8              0.000063     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let ft = i
                                            break
                                        endif
                                    endfor
    8              0.000011     endif
                            
    8              0.000054     let b:NERDSexyComMarker = ''
                            
    8              0.000048     if has_key(s:delimiterMap, ft)
                                    let b:NERDCommenterDelims = s:delimiterMap[ft]
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
                                        endif
                                    endfor
                                    for i in ['nested', 'nestedAlt']
                                        if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
                                        endif
                                    endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
                                    let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
                                    if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
    8              0.000012     else
    8   0.000926   0.000169         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    8              0.000015     endif
                            

FUNCTION  <SNR>223_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:106
Called 1 time
Total time:   0.000266
 Self time:   0.000266

count  total (s)   self (s)
    1              0.000004 	if has_key(s:cache_command, a:prefix)
                            		unlet! s:cache_command[a:prefix]
    1              0.000001 	endif
    1              0.000011 	execute "augroup " a:prefix . "-vital-over-commandline-doautocmd-dummy"
    1              0.000227 		autocmd!
    1              0.000002 	augroup END
                            
    1              0.000010 	let module = deepcopy(s:module)
    1              0.000004 	let module.prefix = a:prefix
    1              0.000002 	return module

FUNCTION  <SNR>242__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:15
Called 1 time
Total time:   0.000168
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000004 	let s:V = a:V
    1   0.000163   0.000019 	let s:L = s:V.import("Data.List")

FUNCTION  <SNR>100_create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:17
Called 2 times
Total time:   0.000690
 Self time:   0.000600

count  total (s)   self (s)
    2              0.000005   let _ = ''
    4              0.000018   for idx in range(len(a:parts))
    2   0.000041   0.000027     let part = airline#parts#get(a:parts[idx])
    2              0.000005     let val = ''
    2              0.000011     let add_sep = get(l:, 'add_sep', 0)
                            
    2              0.000011     if exists('part.function')
    2              0.000008       let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
    2              0.000004     endif
                            
    2              0.000011     let minwidth = get(part, 'minwidth', 0)
                            
    2              0.000007     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    2              0.000009     elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    2              0.000003     else
    2              0.000020       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    2              0.000005       let add_sep = 0
    2              0.000004     endif
                            
    2              0.000011     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
    2              0.000002     endif
                            
    2   0.000112   0.000036     let val .= s:wrap_accent(part, partval)
    2              0.000009     let _ .= val
    4              0.000010   endfor
    2              0.000004   return _

FUNCTION  <SNR>143_ExcludeOther()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:28
Called 8 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    8              0.000128   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
    8              0.000030     return 1 | endif

FUNCTION  <SNR>219_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:38
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000006 	let module = deepcopy(s:module)
    1              0.000007 	let module.chars = type(a:chars) == type([]) ? a:chars : [a:chars]
    1              0.000002 	return module

FUNCTION  <SNR>136_VisitedBufferRequiresReparse()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:507
Called 4 times
Total time:   0.000390
 Self time:   0.000121

count  total (s)   self (s)
    4              0.000028   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
                                return 0
    4              0.000006   endif
                            
    4   0.000341   0.000072   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  <SNR>265_make_emacs()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:87
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004 	return deepcopy(s:emacs)

FUNCTION  <SNR>231_set_search_related_stuff()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:218
Called 3 times
Total time:   0.067412
 Self time:   0.001832

count  total (s)   self (s)
                              " For stay motion
    3              0.000022   let should_set_jumplist = get(a:, 1, s:TRUE)
    3   0.000039   0.000029   let is_cancel = a:cli.exit_code()
    3              0.000006   if is_cancel
                                " Restore cursor position and return
                                " NOTE: Should I request on_cancel event to vital-over and use it?
                                call winrestview(a:cli._w)
                                call s:cleanup_cmdline()
                                return
    3              0.000005   endif
    3   0.000428   0.000029   let [raw_pattern, offset] = a:cli._parse_pattern()
    3              0.000019   let should_execute = !empty(offset) || empty(raw_pattern)
    3              0.000007   if should_execute
                                " Execute with feedkeys() to work with
                                "  1. :h {offset} for `n` and `N`
                                "  2. empty input (:h last-pattern)
                                "  NOTE: Don't use feedkeys() as much as possible to avoid flickering
                                call winrestview(a:cli._w)
                                call feedkeys(a:cmd, 'n')
                                if g:incsearch#consistent_n_direction
                                  call feedkeys("\<Plug>(_incsearch-searchforward)", 'm')
                                endif
    3              0.000004   else
                                " Add history if necessary
                                " Do not save converted pattern to history
    3   0.000115   0.000027     let pattern = a:cli._convert(raw_pattern)
    3   0.000048   0.000028     let input = a:cli._combine_pattern(raw_pattern, offset)
    3              0.000030     call histadd(a:cli._base_key, input)
    3   0.000068   0.000044     call s:set_search_reg(pattern, a:cli._base_key)
                            
    3              0.000017     let target_view = winsaveview()
    3              0.000240     call winrestview(a:cli._w) " Get back start position temporarily for emulation
                                " Set jump list
    3              0.000007     if should_set_jumplist
    3              0.000416       normal! m`
    3              0.000006     endif
                                " Emulate errors, and handling `n` and `N` preparation
    3   0.064510   0.000071     call s:emulate_search_error(a:cli._direction, a:cli._w)
                            
                                " winrestview() between error and wraning emulation to avoid flickering
    3              0.000240     call winrestview(target_view)
                            
                                " Emulate warning
    3   0.000347   0.000080     call s:emulate_search_warning(a:cli._direction, a:cli._w, target_view)
                            
    3   0.000396   0.000063     call s:silent_after_search()
                            
                                " Open fold
    3              0.000055     if &foldopen =~# '\vsearch|all'
    3              0.000249       normal! zv
    3              0.000004     endif
    3              0.000003   endif

FUNCTION  <SNR>194_GroupingAlgorithmSCTree()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:805
Called 2 times
Total time:   0.002187
 Self time:   0.002187

count  total (s)   self (s)
                                " Prepare variables for working
    2              0.000010     let targets_len = len(a:targets)
    2              0.000007     let keys_len = len(a:keys)
                            
    2              0.000006     let groups = {}
                            
    2              0.000021     let keys = reverse(copy(a:keys))
                            
                                " Semi-recursively count targets {{{
                                    " We need to know exactly how many child nodes (targets) this branch will have
                                    " in order to pass the correct amount of targets to the recursive function.
                            
                                    " Prepare sorted target count list {{{
                                        " This is horrible, I know. But dicts aren't sorted in vim, so we need to
                                        " work around that. That is done by having one sorted list with key counts,
                                        " and a dict which connects the key with the keys_count list.
                            
    2              0.000006             let keys_count = []
    2              0.000005             let keys_count_keys = {}
                            
    2              0.000004             let i = 0
   56              0.000092             for key in keys
   54              0.000170                 call add(keys_count, 0)
                            
   54              0.000178                 let keys_count_keys[key] = i
                            
   54              0.000114                 let i += 1
   56              0.000068             endfor
                                    " }}}
                            
    2              0.000007         let targets_left = targets_len
    2              0.000004         let level = 0
    2              0.000004         let i = 0
                            
    4              0.000009         while targets_left > 0
                                        " Calculate the amount of child nodes based on the current level
    2              0.000009             let childs_len = (level == 0 ? 1 : (keys_len - 1) )
                            
    3              0.000007             for key in keys
                                            " Add child node count to the keys_count array
    3              0.000016                 let keys_count[keys_count_keys[key]] += childs_len
                            
                                            " Subtract the child node count
    3              0.000009                 let targets_left -= childs_len
                            
    3              0.000006                 if targets_left <= 0
                                                " Subtract the targets left if we added too many too
                                                " many child nodes to the key count
    2              0.000009                     let keys_count[keys_count_keys[key]] += targets_left
                            
    2              0.000002                     break
    1              0.000001                 endif
                            
    1              0.000002                 let i += 1
    3              0.000004             endfor
                            
    2              0.000004             let level += 1
    4              0.000007         endwhile
                                " }}}
                                " Create group tree {{{
    2              0.000004         let i = 0
    2              0.000004         let key = 0
                            
    2              0.000008         call reverse(keys_count)
                            
   56              0.000103         for key_count in keys_count
   54              0.000106             if key_count > 1
                                            " We need to create a subgroup
                                            " Recurse one level deeper
                                            let groups[a:keys[key]] = s:GroupingAlgorithmSCTree(a:targets[i : i + key_count - 1], a:keys)
   54              0.000128             elseif key_count == 1
                                            " Assign single target key
    3              0.000018                 let groups[a:keys[key]] = a:targets[i]
   51              0.000101             else
                                            " No target
   51              0.000087                 continue
    3              0.000005             endif
                            
    3              0.000008             let key += 1
    3              0.000007             let i += key_count
    5              0.000009         endfor
                                " }}}
                            
                                " Finally!
    2              0.000004     return groups

FUNCTION  vital#_easymotion#Over#Commandline#Modules#InsertRegister#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:5
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000039     return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:48
Called 119392 times
Total time:   2.628539
 Self time:   2.628539

count  total (s)   self (s)
119392              0.590231   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
119392              0.178523   endif
119392              0.776334   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
119392              0.723637   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  vista#GenericCloseOverlay()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:118
Called 2 times
Total time:   0.001767
 Self time:   0.000778

count  total (s)   self (s)
    2              0.000014   if exists('*nvim_open_win')
                                call vista#floating#Close()
    2              0.000010   elseif exists('*popup_create')
    2   0.001727   0.000738     call vista#popup#Close()
    2              0.000004   endif

FUNCTION  <SNR>36_sortByLength()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:467
Called 54 times
Total time:   0.000361
 Self time:   0.000361

count  total (s)   self (s)
   54              0.000349   return len(a:i2[0])-len(a:i1[0])

FUNCTION  ale#events#QuitRecently()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:19
Called 51 times
Total time:   0.000989
 Self time:   0.000977

count  total (s)   self (s)
   51              0.000380     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
   51   0.000534   0.000522     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>240_length()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:152
Called 17 times
Total time:   0.001291
 Self time:   0.000378

count  total (s)   self (s)
   17   0.001283   0.000370 	return len(s:split_by_keys(a:str))

FUNCTION  <SNR>210__redraw()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:56
Called 8 times
Total time:   0.829191
 Self time:   0.828742

count  total (s)   self (s)
    8   0.000470   0.000228 	let left = a:cmdline.get_prompt() . a:cmdline.getline() . (empty(a:cmdline.line.pos_char()) ? " " : "")
    8              0.000052 	let width = len(left) + 1
                            
    8   0.000072   0.000049 	if a:cmdline.get_suffix() != ""
                            		let width += len(s:suffix(left, a:cmdline.get_suffix())) - 1
    8              0.000012 	endif
                            
    8              0.000044 	if &columns >= width && &columns <= s:old_width && s:old_width >= width
                            		redraw
                            		normal! :
    8              0.000018 	elseif &columns <= width
                            		normal! :
    8              0.000010 	else
    8              0.827470 		redraw
    8              0.000046 	endif
    8              0.000118 	let s:old_width = width
                            
    8   0.000420   0.000267 	call s:cmdheight.save()
    8   0.000228   0.000197 	let height = max([(width - 1) / (&columns) + 1, s:cmdheight.get()])
    8              0.000031 	if height > &cmdheight || &cmdheight > height
                            		let &cmdheight = height
                            		redraw
    8              0.000012 	endif

FUNCTION  <SNR>196_off_screen_search()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:224
Called 8 times
Total time:   0.001273
 Self time:   0.000851

count  total (s)   self (s)
                                " First: search within visible screen range
    8   0.000519   0.000097     call s:adjust_screen()
                                " Error occur when '\zs' without '!'
    8              0.000306     silent! let pos = searchpos(a:re, s:direction . 'n', s:orig_line_end[1])
    8              0.000025     if pos != [0, 0]
                                    " Restore cursor posision
    8              0.000042         keepjumps call setpos('.', s:orig_pos)
                                else
                                    " Second: if there were no much, search off screen
                                    silent! let pos = searchpos(a:re, s:direction)
                                    if pos != [0, 0]
                                        " Match
                                        keepjumps call setpos('.', pos)
                                        " Move cursor
                                        if s:save_direction != 'b'
                                            normal! zzH0
                                        else
                                            normal! zzL0
                                        endif
                                    else
                                        " No much
                                        call s:adjust_screen()
                                        keepjumps call setpos('.', s:orig_pos)
                                    endif
    8              0.000010     endif
                                " redraw

FUNCTION  <SNR>188_is_in_table()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/action.vim:151
Called 6 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
    6              0.000151     return a:line =~ s:p.table

FUNCTION  <SNR>36_left()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:123
Called 17 times
Total time:   0.000530
 Self time:   0.000319

count  total (s)   self (s)
   17   0.000522   0.000311   return repeat(s:Left, s:ulen(a:s))

FUNCTION  463()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:119
Called 48 times
Total time:   0.013128
 Self time:   0.003542

count  total (s)   self (s)
   48              0.000281 	let hl = get(self.variables.hl_list, a:name, {})
   48              0.000181 	if empty(hl)
                            		return -1
   48              0.000062 	endif
   48   0.007629   0.000392 	if self.is_enabled(a:name)
                            		call self.disable(a:name)
   48              0.000066 	endif
   48   0.003175   0.000826 	let winnr = s:Gift.uniq_winnr()
   48              0.000243 	if !has_key(self.variables.id_list, winnr)
    1              0.000004 		let self.variables.id_list[winnr] = {}
   48              0.000064 	endif
   48              0.000762 	let self.variables.id_list[winnr][a:name] = matchadd(hl.group, hl.pattern, hl.priority)

FUNCTION  vital#_incsearch#Over#Commandline#Modules#ExceptionMessage#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/ExceptionMessage.vim:7
Called 1 time
Total time:   0.000039
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000039   0.000029 return map({'make': ''}, "vital#_incsearch#function('<SNR>262_' . v:key)")

FUNCTION  <SNR>136_PollFileParseResponse()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:679
Called 371 times
Total time:   0.133020
 Self time:   0.072085

count  total (s)   self (s)
  371   0.048829   0.006532   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
  371              0.000686   endif
                            
  371              0.046977   exec s:python_command "ycm_state.HandleFileParseRequest()"
  371   0.026748   0.008110   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
  371              0.000719   endif

FUNCTION  <SNR>251_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim:105
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  <SNR>243_getchar()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Input.vim:15
Called 14 times
Total time:   0.001271
 Self time:   0.000098

count  total (s)   self (s)
   14              0.000091 	let mode = get(a:, 1, 0)
   14              0.000028 	while 1
                            		" Workaround for https://github.com/osyo-manga/vital-over/issues/53
   14              0.000021 		try
   14   0.000691   0.000062 			let char = call("getchar", a:000)
                            		catch /^Vim:Interrupt$/
                            			let char = 3 " <C-c>
   14              0.000030 		endtry
                            		" Workaround for the <expr> mappings
   14              0.000114 		if string(char) !=# "\x80\xfd`"
   14              0.000139 			return mode == 1 ? !!char				 : type(char) == type(0) ? nr2char(char) : char
                            		endif
                            	endwhile

FUNCTION  625()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 3 times
Total time:   0.000289
 Self time:   0.000139

count  total (s)   self (s)
    3              0.000017     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
    3              0.000005     endif
    3   0.000209   0.000059     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000014     if bufnum == bufnr('%')
    3              0.000017       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000005     endif
    3              0.000006     return group

FUNCTION  <SNR>202_getchar()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Input.vim:21
Called 8 times
Total time:   0.000712
 Self time:   0.000000

count  total (s)   self (s)
    8              0.000041 	let mode = get(a:, 1, 0)
    8              0.000016 	while 1
                            		" Workaround for https://github.com/osyo-manga/vital-over/issues/53
    8              0.000014 		try
    8   0.000405   0.000000 			let char = call("getchar", a:000)
                            		catch /^Vim:Interrupt$/
                            			let char = 3 " <C-c>
    8              0.000017 		endtry
                            		" Workaround for the <expr> mappings
    8              0.000066 		if string(char) !=# "\x80\xfd`"
    8              0.000081 			return mode == 1 ? !!char				 : type(char) == type(0) ? nr2char(char) : char
                            		endif
                            	endwhile

FUNCTION  <SNR>239_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:43
Called 1 time
Total time:   0.000161
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000048 	let result = deepcopy(s:base)
    1   0.000016   0.000012 	call result.set_prompt(get(a:, 1, ":"))
    1   0.000095   0.000008 	call result.connect(result, "_")
    1              0.000002 	return result

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:31
Called 33224 times
Total time:  10.036122
 Self time:   0.765775

count  total (s)   self (s)
33224  10.018329   0.747982   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:72
Called 50 times
Total time:   0.002957
 Self time:   0.002957

count  total (s)   self (s)
   50              0.000245     if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
   50              0.000074     else
  101              0.000471         for l:match in getmatches()
   51              0.000865             if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
   51              0.000075             endif
  101              0.000172         endfor
   50              0.000082     endif

FUNCTION  <SNR>194_turn_on_hl_error()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:483
Called 2 times
Total time:   0.000443
 Self time:   0.000139

count  total (s)   self (s)
    2              0.000011     if exists('s:error_hl')
    2   0.000208   0.000034         call EasyMotion#highlight#turn_on(s:error_hl)
    2              0.000009         unlet s:error_hl
    2              0.000004     endif
                            
    2              0.000011     if exists('s:matchparen_hl')
    2   0.000178   0.000048         call EasyMotion#highlight#turn_on(s:matchparen_hl)
    2              0.000008         unlet s:matchparen_hl
    2              0.000003     endif

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:133
Called 17054 times
Total time:   2.148212
 Self time:   0.408554

count  total (s)   self (s)
17054   2.139540   0.399882   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  EasyMotion#highlight#add_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:173
Called 14 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
   14              0.000472     call add(s:h.ids[a:group], matchadd(a:group, a:re, s:priorities[a:group]))

FUNCTION  incsearch#over#modules#incsearch#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:287
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000007   return deepcopy(s:inc)

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:110
Called 17052 times
Total time:  16.186882
 Self time:   0.654048

count  total (s)   self (s)
17052   0.923874   0.238899   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
17052              0.058947   if empty(dir)
                                return ''
17052              0.024942   endif
17052  15.107817   0.259958   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  riv#path#root()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:17
Called 51 times
Total time:   0.002484
 Self time:   0.000639

count  total (s)   self (s)
   51   0.002447   0.000602     return s:c.p[a:0 ? a:1 : s:id()]._root_path

FUNCTION  <SNR>255_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/LiteralInsert.vim:34
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009 	return deepcopy(s:module)

FUNCTION  vista#util#Trim()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:19
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000012     return trim(a:str)

FUNCTION  riv#ptn#get_role_idx()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:83
Called 2077 times
Total time:   0.091053
 Self time:   0.091053

count  total (s)   self (s)
                                " return the index of sphinx role :doc: :download: ...
                                " 
                                " >>> let line = "test :doc:`Index <index>` testtest"
                                " >>> ec riv#ptn#get_role_idx(line, 2)
                                " >>> ec riv#ptn#get_role_idx(line, 10)
                                " >>> ec riv#ptn#get_role_idx(line, 12)
                                " >>> ec riv#ptn#get_role_idx(line, 14)
                                " >>> ec riv#ptn#get_role_idx(line, 28)
                                " -1
                                " 5
                                " 5
                                " 5
                                " -1
                                " 
                                " XXX: when col on ':' and '`' , it's not recognized.
 2077              0.029768     let ptn = printf(':[^:`]*:`[^`]*\%%%dc[^`]*\|:[^:`]*\%%%dc[^`:]*:`[^`]*`', a:col,a:col)
 2077              0.044008     return match(a:line, ptn)

FUNCTION  405()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:133
Called 3 times
Total time:   0.000087
 Self time:   0.000049

count  total (s)   self (s)
    3   0.000086   0.000048 	call s:cmdheight.restore()

FUNCTION  <SNR>220__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:21
Called 1 time
Total time:   0.001902
 Self time:   0.000011

count  total (s)   self (s)
    1   0.001902   0.000011 	let s:Keymapping = a:V.import("Palette.Keymapping")

FUNCTION  626()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 1 time
Total time:   0.000258
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000105   0.000009     let group = self.get_group(a:i)
    1   0.000099   0.000010     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000006     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
    1              0.000002     endif
                            
    1              0.000006     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
    1              0.000001     else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>259_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Paste.vim:28
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008 	return deepcopy(s:module)

FUNCTION  vital#_incsearch#Over#Keymapping#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim:7
Called 1 time
Total time:   0.000164
 Self time:   0.000118

count  total (s)   self (s)
    1   0.000163   0.000117 return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>244_' . v:key)")

FUNCTION  <SNR>132_RunAsyncCommon()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:316
Called 1 time
Total time:   0.000889
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000004   if exists('s:id')
                                call vista#util#JobStop(s:id)
    1              0.000001   endif
                            
    1   0.000861   0.000065   let s:id = s:ApplyRunAsync(a:cmd)
                            
    1              0.000004   if !s:id
                                call vista#error#RunCtags(a:cmd)
    1              0.000002   endif

FUNCTION  <SNR>214__finish()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:108
Called 10 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
   10              0.000051 	if exists("s:old_statusline")
                            		let &statusline = s:old_statusline
                            		unlet s:old_statusline
                            		redrawstatus
   10              0.000011 	endif

FUNCTION  <SNR>275__init()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:218
Called 1 time
Total time:   0.000773
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000772   0.000014 	let s:global.windo = s:Window.as_windo(s:global)

FUNCTION  <SNR>9_isAnsible()
    Defined: ~/.vim/plugged/ansible-vim/ftdetect/ansible.vim:1
Called 2 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
    2              0.000020   let filepath = expand("%:p")
    2              0.000008   let filename = expand("%:t")
    2              0.000035   if filepath =~ '\v/(tasks|roles|handlers)/.*\.ya?ml$' | return 1 | en
    2              0.000024   if filepath =~ '\v/(group|host)_vars/' | return 1 | en
    2              0.000032   if filename =~ '\v(playbook|site|main|local)\.ya?ml$' | return 1 | en
                            
    2              0.000007   let shebang = getline(1)
    2              0.000068   if shebang =~# '^#!.*/bin/env\s\+ansible-playbook\>' | return 1 | en
    2              0.000082   if shebang =~# '^#!.*/bin/ansible-playbook\>' | return 1 | en
                            
    2              0.000004   return 0

FUNCTION  <SNR>238_default()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Maker.vim:46
Called 1 time
Total time:   0.000173
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000173   0.000012 	return call(s:Cmdline.make, a:000, s:Cmdline)

FUNCTION  <SNR>122_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 93 times
Total time:   0.019760
 Self time:   0.006386

count  total (s)   self (s)
   93              0.000958     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   93   0.003451   0.001239     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    6              0.000012       return
   87              0.000132     endif
   87              0.000205     if condition
                                  call a:builder.add_raw('%(')
   87              0.000129     endif
   87   0.013335   0.002173     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   87              0.000207     if condition
                                  call a:builder.add_raw('%)')
   87              0.000131     endif

FUNCTION  <SNR>132_Execute()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:340
Called 1 time
Total time:   0.001816
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000005   let s:should_display = a:should_display
    1              0.000012   let s:fpath = expand('%:p')
    1   0.001799   0.000025   call s:ApplyExecute(a:bang, s:fpath)

FUNCTION  <SNR>275_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:199
Called 1 time
Total time:   0.000762
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000013 	let result = deepcopy(s:base)
    1   0.000747   0.000022 	let result.windo = s:Window.as_windo(result)
    1              0.000002 	return result

FUNCTION  <SNR>46_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:264
Called 17106 times
Total time:   0.227000
 Self time:   0.227000

count  total (s)   self (s)
17106              0.083861   if exists('+shellslash')
                                return tr(a:path, '\', '/')
17106              0.025934   else
17106              0.043104     return a:path
                              endif

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:136
Called 50 times
Total time:   0.009811
 Self time:   0.006854

count  total (s)   self (s)
   50              0.000567     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   50   0.003864   0.000907     call ale#highlight#RemoveHighlights()
                            
   50              0.000178     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
   50              0.000141     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   50              0.000129     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
   50              0.000078     endif

FUNCTION  incsearch#cli#get()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:12
Called 3 times
Total time:   0.000133
 Self time:   0.000087

count  total (s)   self (s)
    3              0.000007   try
                                " It returns current cli object
    3   0.000091   0.000045     return s:Doautocmd.get_cmdline()
                              catch /vital-over(_incsearch) Exception/
                                " If there are no current cli object, return default one
                                return incsearch#cli#make(incsearch#config#make({}))
    3              0.000005   endtry

FUNCTION  <SNR>136_SetUpCompleteopt()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:527
Called 3 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    3              0.000032   set completeopt-=menu
    3              0.000018   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    3              0.000014   set completeopt-=longest
                            
    3              0.000010   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
    3              0.000004   endif

FUNCTION  riv#insert#indent()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/insert.vim:24
Called 183 times
Total time:   0.025425
 Self time:   0.025425

count  total (s)   self (s)
                                " @param 
                                " row: the input row
                                " @return
                                " idt: the indent
                                
  183              0.001608     let row = a:row == '.' ? line('.') : a:row == '$' ? line('$') : a:row
                            
  183              0.001554     let pnb_num = prevnonblank(row - 1)
                            
                                " If above lines don't having content , return 0
  183              0.001099     if pnb_num == 0 | return 0 | endif
                            
  183              0.001042     let prev_line = getline(row - 1)
  183              0.000893     let pnb_line = getline(pnb_num)
                                
                                " The prev non blank line's indent
  183              0.000756     let ind = indent(pnb_num)
                                
                                " List-indent match the content's begin.
  183              0.010243     let l_ind = matchend(pnb_line, s:p.all_list)
  183              0.000502     if l_ind != -1 
   49              0.000109         return l_ind
  134              0.000200     endif
                                
                                " Literal-block match the start + &sw
  134              0.001595     let l_ind = matchend(pnb_line, s:p.literal_block)
  134              0.000343     if l_ind != -1 
   13              0.000107         return ind+&sw
  121              0.000214     endif
                            
                                " Exp markup match the start of content.
  121              0.001164     let l_ind = matchend(pnb_line, s:p.exp_mark)
  121              0.000287     if l_ind != -1
    2              0.000004         return l_ind
  119              0.000156     endif
                                
  119              0.000265     return ind

FUNCTION  <SNR>136_OnInsertLeave()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:813
Called 424 times
Total time:   2.650748
 Self time:   0.957867

count  total (s)   self (s)
  424   0.072018   0.009533   if !s:AllowedToCompleteInCurrentBuffer()
                                return
  424              0.000600   endif
                            
  424              0.007277   call timer_stop( s:pollers.completion.id )
  424              0.001714   let s:force_semantic = 0
  424              0.002685   let s:completion = s:default_completion
                            
  424   0.734592   0.008605   call s:OnFileReadyToParse()
  424              0.877634   exec s:python_command "ycm_state.OnInsertLeave()"
  424              0.006145   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
  424   0.050626   0.025252     call s:ClosePreviewWindowIfNeeded()
  424              0.002363   endif
                            
  424   0.891362   0.012327   call s:ClearSignatureHelp()

FUNCTION  <SNR>231_set_search_reg()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:484
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000021   let @/ = a:command is# '?' ? substitute(a:pattern, '\\?', '?', 'g') : a:pattern

FUNCTION  <SNR>205_links_to()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:47
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015 	return matchstr(a:highlight, '^\S\+\s\+xxx links to \zs.*\ze$')

FUNCTION  <SNR>219_make_special_chars()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:45
Called 1 time
Total time:   0.000033
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000026   0.000011 	let module = s:make([])
    1              0.000002 	function! module.is_no_insert(char)
                            		return char2nr(a:char) == 128 || char2nr(a:char) < 27
                            	endfunction
    1              0.000002 	return module

FUNCTION  vital#_incsearch#Over#Commandline#Modules#IgnoreRegexpBackwardWord#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/IgnoreRegexpBackwardWord.vim:7
Called 1 time
Total time:   0.000047
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000047   0.000035 return map({'backward_word': '', 'make': ''}, "vital#_incsearch#function('<SNR>268_' . v:key)")

FUNCTION  <SNR>266__capture()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:31
Called 3 times
Total time:   0.001146
 Self time:   0.000113

count  total (s)   self (s)
    3              0.000009 	let cmd = "map"
    3              0.000007 	if a:mode ==# "!"
                            		let cmd = cmd . "!"
    3              0.000025 	elseif a:mode =~# "[nvoicsxl]"
    3              0.000011 		let cmd = a:mode . cmd
    3              0.000004 	endif
    3   0.001077   0.000044 	return s:Capture.command(cmd)

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Doautocmd#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:5
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000051     return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  vital#_easymotion#Vim#Message#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Message.vim:5
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000036     return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''},  'function("s:" . v:key)')

FUNCTION  EasyMotion#helper#silent_feedkeys()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:92
Called 2 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
                                " Ref:
                                " https://github.com/osyo-manga/vim-over/blob/d51b028c29661d4a5f5b79438ad6d69266753711/autoload/over.vim#L6
    2              0.000016     let mode = get(a:, 1, "m")
    2              0.000011     let name = "easymotion-" . a:name
    2              0.000013     let map = printf("<Plug>(%s)", name)
    2              0.000007     if mode == "n"
    2              0.000007         let command = "nnoremap"
                                else
                                    let command = "nmap"
    2              0.000005     endif
    2              0.000220     execute command "<silent>" map printf("%s:nunmap %s<CR>", a:expr, map)
    2              0.000013     if mode(1) !=# 'ce'
                                    " FIXME: mode(1) !=# 'ce' exists only for the test
                                    "        :h feedkeys() doesn't work while runnning a test script
                                    "        https://github.com/kana/vim-vspec/issues/27
    2              0.000024         call feedkeys(printf("\<Plug>(%s)", name))
    2              0.000003     endif

FUNCTION  <SNR>16_LoadIndent()
    Defined: /usr/share/vim/vim81/indent.vim:13
Called 3 times
Total time:   0.002652
 Self time:   0.002652

count  total (s)   self (s)
    3              0.000030     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    3              0.000006     endif
    3              0.000026     let s = expand("<amatch>")
    3              0.000012     if s != ""
    3              0.000015       if exists("b:did_indent")
                            	unlet b:did_indent
    3              0.000004       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000046       for name in split(s, '\.')
    3              0.002432 	exe 'runtime! indent/' . name . '.vim'
    6              0.000016       endfor
    3              0.000006     endif

FUNCTION  <SNR>136_OnFileReadyToParse()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:657
Called 754 times
Total time:   1.183330
 Self time:   0.889803

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
  754              0.003967   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
  754   0.111256   0.012195   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
                                " We switched buffers or somethuing, so claer.
                                " FIXME: sig hekp should be buffer local?
  469   0.204383   0.009917     call s:ClearSignatureHelp()
  469              0.824169     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
  469              0.013219     call timer_stop( s:pollers.file_parse_response.id )
  469              0.012055     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
  754              0.001619   endif

FUNCTION  vital#_incsearch#Over#Commandline#Modules#Paste#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Paste.vim:7
Called 1 time
Total time:   0.000029
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000029   0.000022 return map({'make': ''}, "vital#_incsearch#function('<SNR>259_' . v:key)")

FUNCTION  riv#action#ins_tab()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/action.vim:157
Called 6 times
Total time:   0.006279
 Self time:   0.000724

count  total (s)   self (s)
                            " tab for insert mode.
                            " to support other command. 
                            " the g:riv_i_tab_pum_next is used to act as '<C-N>' when pumvisible
                            " the g:riv_i_tab_user_cmd is used to execute user defined command or '\<Tab>'
                            " the g:riv_i_stab_user_cmd is used to execute user defined command 
                            
    6              0.000066     let [row,col] = getpos('.')[1:2]
    6              0.000029     let line = getline('.')
                            
    6              0.000025     if pumvisible() && g:riv_i_tab_pum_next
                                    return "\<C-N>"
    6   0.000260   0.000088     elseif s:is_in_table(line)
                                    " Format the table and find the cell.
                                    return "\<C-O>:call cursor(riv#table#nextcell())\<CR>"
    6   0.000297   0.000097     elseif s:is_in_list_item(col, line)
                                    " before the list item, shift the list
                                    return "\<C-O>:call riv#list#shift('+')\<CR>"
    6   0.000157   0.000085     elseif s:is_row_bgns_blank(col, line)
    6   0.005200   0.000089         let cmd = riv#insert#shiftright(row,col)
                                else
                                    let cmd = ''
    6              0.000009     endif
                            
                                " We will execute user cmd only when there were no cmd context.
    6              0.000086     if !empty(cmd)
    6              0.000016         return cmd
                                else
                                    if !empty(g:riv_i_tab_user_cmd) 
                                        return g:riv_i_tab_user_cmd
                                    else
                                        return "\<Tab>"
                                    endif
                                endif

FUNCTION  <SNR>274_init_hl()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/highlight.vim:65
Called 1 time
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
    1              0.000082   hi default link IncSearchMatch Search
    1              0.000054   hi default link IncSearchMatchReverse IncSearch
    1              0.000050   hi default link IncSearchCursor Cursor
    1              0.000065   hi default link IncSearchOnCursor IncSearch
    1              0.000031   hi default IncSearchUnderline term=underline cterm=underline gui=underline

FUNCTION  vista#sidebar#Open()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:115
Called 1 time
Total time:   0.002759
 Self time:   0.000098

count  total (s)   self (s)
    1              0.000020   let [bufnr, winnr, fname, fpath] = [bufnr('%'), winnr(), expand('%'), expand('%:p')]
    1   0.000049   0.000015   call vista#source#Update(bufnr, winnr, fname, fpath)
    1   0.000100   0.000015   let executive = vista#GetExplicitExecutiveOrDefault()
                              " Support the builtin markdown toc extension as an executive
    1   0.000014   0.000010   if vista#SupportToc() && executive ==# 'toc'
                                call vista#extension#{&filetype}#Execute(v:false, v:true)
    1              0.000001   else
    1   0.002562   0.000024     call vista#executive#{executive}#Execute(v:false, v:true, v:false)
    1              0.000002   endif

FUNCTION  461()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:107
Called 144 times
Total time:   0.010953
 Self time:   0.003516

count  total (s)   self (s)
  144   0.009667   0.002230 	let window = get(a:, 1, s:Gift.uniq_winnr())
  144              0.001201 	return get(get(self.variables.id_list, window, {}), a:name, "")

FUNCTION  <SNR>132_BuildCmd()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:69
Called 1 time
Total time:   0.000265
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000028   0.000013   let custom_cmd = s:GetCustomCmd(&filetype)
                            
    1              0.000003   if custom_cmd isnot v:null
                                if stridx(custom_cmd, '--output-format=json') > -1
                                  let s:TagParser = function('vista#parser#ctags#FromJSON')
                                else
                                  let s:TagParser = function('vista#parser#ctags#FromExtendedRaw')
                                endif
                                let cmd = printf('%s %s', custom_cmd, a:file)
    1              0.000002   else
    1   0.000207   0.000012     let cmd = s:GetDefaultCmd(a:file)
    1              0.000002   endif
                            
    1              0.000004   let t:vista.ctags_cmd = cmd
                            
    1              0.000002   return cmd

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:51
Called 5 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    5              0.000053     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
    5              0.000007     endif
                            
                                " When entering a buffer, we are no longer quitting it.
    5              0.000040     call setbufvar(a:buffer, 'ale_quitting', 0)
    5              0.000038     let l:filetype = getbufvar(a:buffer, '&filetype')
    5              0.000044     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    5              0.000039     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
    5              0.000007     endif

FUNCTION  <SNR>139_HasVlnum()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:289
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000021   return exists('t:vista') && has_key(t:vista, 'raw') && !empty(t:vista.raw) && has_key(t:vista.raw[0], 'vlnum')

FUNCTION  13()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:33
Called 106 times
Total time:   0.000513
 Self time:   0.000513

count  total (s)   self (s)
  106              0.000454   return len(self._sections)

FUNCTION  14()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 228 times
Total time:   1.446954
 Self time:   0.255452

count  total (s)   self (s)
  228              0.000900   let side = 1
  228              0.000521   let line = ''
  228              0.000497   let i = 0
  228              0.001195   let length = len(self._sections)
  228              0.000665   let split = 0
  228              0.000615   let is_empty = 0
  228              0.000741   let prev_group = ''
                            
 1294              0.003933   while i < length
 1066              0.005400     let section = self._sections[i]
 1066              0.004470     let group = section[0]
 1066              0.004669     let contents = section[1]
 1066              0.003297     let pgroup = prev_group
 1066   0.057153   0.027568     let prev_group = airline#builder#get_prev_group(self._sections, i)
 1066              0.005432     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
 1066              0.007056     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
 1066              0.006922     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
 1066              0.002004     endif
 1066              0.002628     if is_empty
                                  let prev_group = pgroup
 1066              0.001398     endif
 1066   0.041821   0.021181     let is_empty = s:section_is_empty(self, contents)
                            
 1066              0.002245     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
 1066              0.001718     endif
                            
 1066              0.002972     if group == ''
                                  let line .= contents
 1066              0.002747     elseif group == '|'
  228              0.000525       let side = 0
  228              0.000902       let line .= contents
  228              0.000521       let split = 1
  838              0.001294     else
  838              0.002411       if prev_group == ''
  228              0.001184         let line .= '%#'.group.'#'
  610              0.001239       elseif split
  228              0.000498         if !is_empty
  228   0.320285   0.006158           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
  228              0.000358         endif
  228              0.000561         let split = 0
  382              0.000570       else
  382              0.000891         if !is_empty
  382   0.766575   0.007784           let line .= s:get_seperator(self, prev_group, group, side)
  382              0.000558         endif
  838              0.001537       endif
  838   0.088800   0.020441       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
 1066              0.001632     endif
                            
 1066              0.004583     let i = i + 1
 1294              0.002675   endwhile
                            
  228              0.000632   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    7              0.000602     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
  228              0.000298   endif
  228              0.000626   return line

FUNCTION  15()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:11
Called 3 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    3              0.000096       return bufwinnr('__vista__')

FUNCTION  <SNR>157_Render()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:242
Called 1 time
Total time:   0.001656
 Self time:   0.000283

count  total (s)   self (s)
    1   0.000132   0.000014   let s:scope_seperator = t:vista.source.scope_seperator()
                            
    1              0.000004   let rows = []
                            
                              " s:vlnum_cache is a cache for recording which original tagline
                              " is related to the line in the vista sidebar, for we have to
                              " remove the duplicate parents which leads to reassign the lnum
                              " to the original tagline.
                              "
                              " The item of s:vlnum_cache is some original tagline dict with
                              " `vlnum` field added later.
    1              0.000005   let s:vlnum_cache = []
                            
    1              0.000002   let scope_less = {}
                            
    1              0.000004   let without_scope = t:vista.without_scope
                            
                              " The root of hierarchy structure doesn't have scope field.
    2              0.000020   for potential_root_line in without_scope
                            
    1              0.000004     let root_name = potential_root_line.name
                            
    1   0.000417   0.000018     let descendants = s:DescendantsOfRoot(t:vista.with_scope, potential_root_line)
                            
    1              0.000003     if !empty(descendants)
                            
    1   0.000741   0.000040       call s:RenderDescendants(root_name, potential_root_line, descendants, rows, 0)
                            
    1              0.000003       call add(rows, '')
    1              0.000003       call add(s:vlnum_cache, '')
                            
                                else
                            
                                  if has_key(potential_root_line, 'kind')
                                    call s:Insert(scope_less, potential_root_line.kind, potential_root_line)
                                  endif
                            
    1              0.000001     endif
                            
    2              0.000002   endfor
                            
    1   0.000170   0.000015   call s:RenderScopeless(scope_less, rows)
                            
                              " The original tagline is positioned in which line in the vista sidebar.
    1              0.000002   let idx = 0
    4              0.000015   while idx < len(s:vlnum_cache)
    3              0.000013     if !empty(s:vlnum_cache[idx])
                                  " idx is 0-based, while the line number is 1-based, and we prepend the
                                  " two lines first, so the final offset is 1+2=3
    2              0.000014       let s:vlnum_cache[idx].vlnum = idx + g:vista#renderer#default#vlnum_offset
    3              0.000003     endif
    3              0.000006     let idx += 1
    4              0.000005   endwhile
                            
    1              0.000004   let t:vista.vlnum_cache = s:vlnum_cache
                            
    1              0.000002   return rows

FUNCTION  17()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:22
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000025       return get(t:vista.vlnum_cache, line('.') - g:vista#renderer#default#vlnum_offset, '')

FUNCTION  19()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:35
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006       return bufwinid(self.bufnr)

FUNCTION  vital#_incsearch#Over#Exception#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Exception.vim:7
Called 1 time
Total time:   0.000113
 Self time:   0.000079

count  total (s)   self (s)
    1   0.000112   0.000078 return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''}, "vital#_incsearch#function('<SNR>261_' . v:key)")

FUNCTION  <SNR>236_make_default()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline.vim:41
Called 1 time
Total time:   0.000187
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000187   0.000014 	return call(s:Maker.default, a:000, s:Maker)

FUNCTION  101()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:231
Called 44 times
Total time:   1.017246
 Self time:   0.001387

count  total (s)   self (s)
   44   0.034564   0.000619 	call self.variables.modules.sort_by("has_key(v:val.slot.module, 'priority') ? v:val.slot.module.priority('" . a:event . "') : 0")
   44   0.982657   0.000743 	return self.variables.modules.call(a:event, [self])
                            " 	call map(filter(copy(self.variables.modules), "has_key(v:val, a:event)"), "v:val." . a:event . "(self)")

FUNCTION  103()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:243
Called 5 times
Total time:   0.000177
 Self time:   0.000102

count  total (s)   self (s)
    5   0.000145   0.000070 	let key = s:Keymapping.as_key_config(a:rhs)
    5              0.000012 	let key.noremap = 1
    5              0.000019 	let self.variables.keymapping[a:lhs] = key

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:220
Called 609 times
Total time:   0.755048
 Self time:   0.025262

count  total (s)   self (s)
  609              0.007137   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  609   0.747469   0.017683   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  109()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:277
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000006 	let self.variables.exit = 1
    2              0.000008 	let self.variables.exit_code = get(a:, 1, 0)

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:32
Called 1853 times
Total time:   0.491271
 Self time:   0.380283

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
 1853              0.022701     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
 1853              0.002828     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
 1853              0.015702     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
 1853              0.002915     endif
                            
 1853              0.018830     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
 1853              0.006727     if l:filetype is# ''
                                    return 1
 1853              0.002840     endif
                            
                                " Do nothing for diff buffers.
 1853              0.011813     if getbufvar(a:buffer, '&diff')
                                    return 1
 1853              0.002635     endif
                            
                                " Do nothing for blacklisted files.
 1853              0.020961     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
 1853              0.002892     endif
                            
                                " Do nothing if running from command mode.
 1853              0.016468     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
 1853              0.002725     endif
                            
 1853              0.018698     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
 1853              0.006062     if l:filename is# '.'
                                    return 1
 1853              0.003698     endif
                            
                                " Don't start linting and so on when an operator is pending.
 1853   0.046079   0.029751     if ale#util#Mode(1) is# 'no'
                                    return 1
 1853              0.002804     endif
                            
                                " Do nothing if running in the sandbox.
 1853   0.078828   0.026184     if ale#util#InSandbox()
                                    return 1
 1853              0.002958     endif
                            
                                " Do nothing if the file is too large.
 1853   0.068983   0.026967     if ale#FileTooLarge(a:buffer)
                                    return 1
 1853              0.002892     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
 1853              0.039069     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
 1853              0.003543     endif
                            
 1853              0.005568     return 0

FUNCTION  <SNR>15_LoadFTPlugin()
    Defined: /usr/share/vim/vim81/ftplugin.vim:14
Called 3 times
Total time:   0.012723
 Self time:   0.011720

count  total (s)   self (s)
    3              0.000022     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    3              0.000005     endif
                            
    3              0.000017     let s = expand("<amatch>")
    3              0.000007     if s != ""
    3              0.000054       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    3              0.000005       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    6              0.000038       for name in split(s, '\.')
    3   0.012477   0.011474 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    6              0.000027       endfor
    3              0.000006     endif

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:51
Called 9 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    9              0.000107   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    9              0.000013   endif

FUNCTION  <SNR>142_get_separator_change_with_end()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:76
Called 216 times
Total time:   0.081605
 Self time:   0.012284

count  total (s)   self (s)
  216              0.000981   let sep_change = 0
  216              0.001282   if !empty(a:new_end_group) " Separator between title and the end
  109   0.069696   0.002686     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
  216              0.000318   endif
  216              0.001145   if !empty(a:old_group) " Separator between the title and the one adjacent
    2   0.001128   0.000042     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
    2              0.000009     if !empty(a:old_end_group) " Remove mis-predicted separator
    2   0.001325   0.000100       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
    2              0.000003     endif
  216              0.000367   endif
  216              0.000526   return sep_change

FUNCTION  521()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:23
Called 84 times
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
   84              0.000422   return a:event is# 'on_char' ? 10 : 0

FUNCTION  522()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:27
Called 3 times
Total time:   0.002119
 Self time:   0.000325

count  total (s)   self (s)
    3              0.000006   nohlsearch " disable previous highlight
    3              0.000030   let a:cmdline._w = winsaveview()
    3   0.000278   0.000044   let hgm = incsearch#highlight#hgm()
    3              0.000007   let c = hgm.cursor
    3   0.000176   0.000040   call s:hi.add(c.group, c.group, '\%#', c.priority)
    3   0.001492   0.000098   call incsearch#highlight#update()
                            
                              " XXX: Manipulate search history for magic option
                              " In the first place, I want to omit magic flag when histadd(), but
                              " when returning cmd as expr mapping and feedkeys() cannot handle it, so
                              " remove no user intended magic flag at on_enter.
                              " Maybe I can also handle it with autocmd, should I use autocmd instead?
    3              0.000016   let hist = histget('/', -1)
    3   0.000074   0.000044   if len(hist) > 2 && hist[:1] ==# incsearch#magic()
                                call histdel('/', -1)
                                call histadd('/', hist[2:])
    3              0.000006   endif

FUNCTION  523()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:47
Called 3 times
Total time:   0.203979
 Self time:   0.199756

count  total (s)   self (s)
    3   0.003698   0.000022   call s:hi.disable_all()
    3   0.000388   0.000022   call s:hi.delete_all()
                              " redraw: hide pseud-cursor
    3              0.199433   redraw " need to redraw for handling non-<expr> mappings
    3   0.000129   0.000040   if a:cmdline.getline() ==# ''
                                echo ''
    3              0.000005   else
    3   0.000206   0.000135     echo a:cmdline.get_prompt() . a:cmdline.getline()
    3              0.000007   endif
                              " NOTE:
                              "   push rest of keymappings with feedkeys()
                              "   FIXME: assume 'noremap' but it should take care wheter or not the
                              "   mappings should be remapped or not
    3   0.000054   0.000033   if a:cmdline.input_key_stack_string() !=# ''
                                call feedkeys(a:cmdline.input_key_stack_string(), 'n')
    3              0.000005   endif

FUNCTION  524()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:275
Called 15 times
Total time:   0.012118
 Self time:   0.000347

count  total (s)   self (s)
   15   0.012105   0.000334   call s:on_searching(function('s:on_char_pre'), a:cmdline)

FUNCTION  525()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:279
Called 15 times
Total time:   0.060056
 Self time:   0.000378

count  total (s)   self (s)
   15   0.060049   0.000371   call s:on_searching(function('s:on_char'), a:cmdline)

FUNCTION  528()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:40
Called 18 times
Total time:   0.001336
 Self time:   0.001178

count  total (s)   self (s)
   18              0.000113   let mode = get(a:, 1, self._mode)
   18   0.000435   0.000277   let op = (mode ==# 'no')      ? v:operator      : s:U.is_visual(mode) ? 'gv'      : ''
   18              0.000192   let zv = (&foldopen =~# '\vsearch|all' && mode !=# 'no' ? 'zv' : '')
                              " NOTE:
                              "   Should I consider o_v, o_V, and o_CTRL-V cases and do not
                              "   <Esc>? <Esc> exists for flexible v:count with using s:cli._vcount1,
                              "   but, if you do not move the cursor while incremental searching,
                              "   there are no need to use <Esc>.
   18              0.000060   let esc = self._has_count ? "\<Esc>" : ''
   18              0.000077   let register = esc is# '' ? '' : '"' . v:register
   18              0.000069   let cnt = self._vcount1 is# 1 ? '' : self._vcount1
   18              0.000118   let prefix = esc .  register . (esc is# '' ? '' : op) . cnt
   18              0.000190   return printf("%s%s%s\<CR>%s", prefix, self._base_key, a:pattern, zv)

FUNCTION  529()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:61
Called 3 times
Total time:   0.011182
 Self time:   0.000733

count  total (s)   self (s)
    3              0.000039   let view = get(a:, 1, winsaveview())
    3              0.000007   try
    3              0.000254     call winrestview(self._w)
    3   0.005634   0.000057     call self.callevent('on_execute_pre')
    3              0.000009   finally
    3              0.000288     call winrestview(view)
    3              0.000007   endtry
    3   0.004933   0.000061   call self.callevent('on_execute')

FUNCTION  riv#path#build_path()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:34
Called 51 times
Total time:   0.003258
 Self time:   0.001006

count  total (s)   self (s)
   51   0.003061   0.000809     return s:c.p[a:0 ? a:1 : s:id()]._build_path

FUNCTION  ale#handlers#textlint#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/textlint.vim:8
Called 474 times
Total time:   0.245219
 Self time:   0.012167

count  total (s)   self (s)
  474   0.244792   0.011740     return ale#node#FindExecutable(a:buffer, 'textlint', [   'node_modules/.bin/textlint',   'node_modules/textlint/bin/textlint.js',])

FUNCTION  20()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:39
Called 4 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    4              0.000058       return getbufvar(self.bufnr, '&filetype')

FUNCTION  23()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:52
Called 3 times
Total time:   0.000093
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000031       let bufline = getbufline(self.bufnr, a:lnum)
    3   0.000057   0.000043       return empty(bufline) ? '' : vista#util#Trim(bufline[0])

FUNCTION  24()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:57
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                                  " Try the extension first, and then the filetype, for ctags relys on the extension name.
    1              0.000008       let e = fnamemodify(self.fpath, ':e')
    1              0.000007       return empty(e) ? getbufvar(self.bufnr, '&ft') : e

FUNCTION  25()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:63
Called 1 time
Total time:   0.000118
 Self time:   0.000108

count  total (s)   self (s)
    1   0.000017   0.000007       let filetype = self.filetype()
    1              0.000002       try
    1              0.000020         let type = g:vista#types#uctags#{filetype}#
    1              0.000061       catch /^Vim\%((\a\+)\)\=:E121/
    1              0.000005         let type = {}
    1              0.000002       endtry
                            
                                  " FIXME use a default value maybe inappropriate.
    1              0.000007       return get(type, 'sro', '.')

FUNCTION  26()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:18
Called 106 times
Total time:   0.003957
 Self time:   0.003444

count  total (s)   self (s)
  106              0.000644   let self._first_title = a:first " lowest index
  106              0.000382   let self._last_title = a:last " highest index
  106              0.000364   let self._left_title = a:current " next index to add on the left
  106              0.000473   let self._right_title = a:current + 1 " next index to add on the right
  106   0.001529   0.001016   let self._left_position = self.get_position() " left end of titles
  106              0.000360   let self._right_position = self._left_position " right end of the titles

FUNCTION  27()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:41
Called 108 times
Total time:   0.086161
 Self time:   0.011488

count  total (s)   self (s)
  108   0.030215   0.001188   let title = self.get_title(a:index)
  108   0.047031   0.002587   let title_size = s:tabline_evaluated_length(title) + a:sep_size
  108              0.000429   if a:force || self._remaining_space >= title_size
  108              0.000318     let pos = a:pos
  108              0.000597     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
  108              0.000181     endif
                            
  108   0.002554   0.001352     call self.insert_section(a:group, title, pos)
  108              0.000380     let self._right_position += 1
  108              0.000318     let pos += 1
                            
  108              0.000463     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
  108              0.000158     endif
                            
  108              0.000411     let self._remaining_space -= title_size
  108              0.000226     return 1
                              endif
                              return 0

FUNCTION  28()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:96
Called 106 times
Total time:   1.570500
 Self time:   0.056601

count  total (s)   self (s)
  106              0.000816   if has_key(self, '_left_position') && self._first_title <= self._last_title
  106   0.548755   0.003444     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
  106              0.000847     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
  106   0.013544   0.002183     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
  106   0.013633   0.002324     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
  106   0.005132   0.002274     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
  106   0.007440   0.002455     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
  106              0.001094     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
  106   0.013575   0.002148     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
  106              0.000382     if self._left_title > self._first_title
    1   0.000077   0.000020       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
  106              0.000171     endif
  106              0.000352     if self._left_title < self._last_title
    1   0.000620   0.000025       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
  106              0.000132     endif
                            
                                " Add the current title
  106   0.012716   0.001122     let group = self.get_group(self._left_title)
  106              0.000316     if self._left_title == self._first_title
  105   0.010477   0.002376       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000001     else
    1   0.000631   0.000017       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
  106              0.000150     endif
  106              0.000333     if self._left_title == self._last_title
  105   0.077685   0.002367       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     else
    1   0.000517   0.000016       let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
  106              0.000179     endif
  106              0.000450     let left_group = group
  106              0.000460     let right_group = group
  106   0.086650   0.001793     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
  106              0.000797     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
  106              0.000137     endif
                            
  106              0.000539     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
    1   0.000084   0.000006       let group = self.get_group(self._right_title)
    1              0.000003       if self._right_title == self._last_title
    1   0.001815   0.000022         let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
    1              0.000001       endif
    1              0.000003       let right_group = group
    1   0.000715   0.000012       let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
  106              0.000136     endif
                            
  107              0.000323     while self._remaining_space > 0
  107              0.000264       let done = 0
  107              0.000309       if self._left_title >= self._first_title
                                    " Insert next title to the left
    1   0.000084   0.000006         let group = self.get_group(self._left_title)
    1              0.000003         if self._left_title == self._first_title
    1   0.001361   0.000023           let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
    1              0.000002         endif
    1              0.000003         let left_group = group
    1   0.000611   0.000010         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
    1              0.000003         let self._left_title -= done
  107              0.000166       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
  107              0.000488       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
  107              0.000241       endif
  107              0.000232       if !done
  106              0.000272         break
    1              0.000002       endif
  107              0.000307     endwhile
                            
  106              0.000368     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
  106              0.000138     endif
                            
  106              0.000349     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
  106              0.000135     endif
  106              0.000134   endif
                            
  106   0.741683   0.001263   return self._build()

FUNCTION  <SNR>22_CreateDelimMapFromCms()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim:565
Called 8 times
Total time:   0.000757
 Self time:   0.000757

count  total (s)   self (s)
    8              0.000232     if &ft == '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
    8              0.000012     endif
    8              0.000339     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  112()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:293
Called 16 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
   16              0.000043 	return self.variables.enable_keymapping

FUNCTION  113()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:303
Called 8 times
Total time:   0.003023
 Self time:   0.003023

count  total (s)   self (s)
    8              0.003015 	return self.variables.exit_code

FUNCTION  115()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:322
Called 2 times
Total time:   0.000171
 Self time:   0.000161

count  total (s)   self (s)
    2              0.000012 	if exists("self.variables.old_t_ve")
                            		return
    2              0.000002 	endif
                            
    2              0.000023 	let self.variables.old_guicursor = &guicursor
    2   0.000073   0.000069 	set guicursor=n:block-NONE
    2              0.000012 	let self.variables.old_t_ve = &t_ve
    2   0.000041   0.000035 	set t_ve=

FUNCTION  116()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:334
Called 2 times
Total time:   1.034781
 Self time:   0.000079

count  total (s)   self (s)
    2   1.034748   0.000046 	let exit_code = call(self.__main, a:000, self)
    2              0.000030 	return exit_code

FUNCTION  118()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:344
Called 2 times
Total time:   1.034961
 Self time:   0.000142

count  total (s)   self (s)
    2              0.000009 	let Old_execute = self.execute
    2              0.000006 	let self.execute = self.__empty
    2              0.000004 	try
    2   1.034845   0.000064 		let exit_code = call(self.start, a:000, self)
    2              0.000007 		if exit_code == 0
    2   0.000060   0.000022 			return self.getline()
                            		endif
    2              0.000005 	finally
    2              0.000011 		let self.execute = Old_execute
    2              0.000004 	endtry
                            	return ""

FUNCTION  119()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:359
Called 24 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   24              0.000063 	return self.variables.input_key_stack

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:18
Called 196029 times
Total time:   3.881811
 Self time:   3.881811

count  total (s)   self (s)
196029              1.067230   let nr = get(a:000, 0, 0)
196029              1.079375   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
196029              0.306318   else
196029              0.765689     return winwidth(nr)
                              endif

FUNCTION  <SNR>203_as_key_config()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:35
Called 7 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    7              0.000035 	let base = {		"noremap" : 0,		"lock"    : 0,		"expr"    : 0,	}
    7              0.000068 	return type(a:config) == type({}) ? extend(base, a:config)		 : extend(base, {		 	"key" : a:config,		 })

FUNCTION  <SNR>266_parse_lhs()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:70
Called 20 times
Total time:   0.000952
 Self time:   0.000952

count  total (s)   self (s)
   20              0.000162 	let mode = get(a:, 1, '[!nvoicsxl]')
                            	" NOTE: :map! Surpport : https://github.com/osyo-manga/vital-palette/issues/4
   20              0.000173 	if get(a:, 1, "") =~# '[!ci]'
   20              0.000054 		let mode = '[!ci]'
   20              0.000029 	endif
   20              0.000484 	return matchstr(a:text, mode . '\{1,3\}\s*\zs\S\{-}\ze\s\+')

FUNCTION  532()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:88
Called 36 times
Total time:   0.001121
 Self time:   0.000775

count  total (s)   self (s)
   36              0.000107   if a:pattern is# ''
    3              0.000007     return a:pattern
   33              0.000120   elseif empty(self._converters)
   33   0.000760   0.000414     return incsearch#magic() . a:pattern
                              elseif has_key(self._converter_cache, a:pattern)
                                return self._converter_cache[a:pattern]
                              else
                                let ps = [incsearch#magic() . a:pattern]
                                for l:Converter in self._converters
                                  let l:Convert = type(l:Converter) is type(function('function')) ? l:Converter : l:Converter.convert
                                  let ps += [l:Convert(a:pattern)]
                                  unlet l:Converter
                                endfor
                                " Converters may return upper case even if a:pattern doesn't contain upper
                                " case letter, so prepend case flag explicitly
                                " let case = incsearch#detect_case(a:pattern)
                                let case = incsearch#detect_case(a:pattern)
                                let self._converter_cache[a:pattern] =  case . s:U.regexp_join(ps)
                                return self._converter_cache[a:pattern]
                              endif

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Delete#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim:5
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000013     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>124_InitializeVars()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/sign.vim:343
Called 15 times
Total time:   0.008811
 Self time:   0.004380

count  total (s)   self (s)
                              " Description: Initialize variables
                              " Arguments:   Specify an argument to re-init
                            
   15              0.000163   if !exists('b:sig_marks')
                                " b:sig_marks = { lnum => signs_str }
    3              0.000012     let b:sig_marks = {}
   12              0.000036   else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
   12              0.000107     let l:line_tot = line('$')
   12              0.000143     call filter( b:sig_marks, 'v:key <= l:line_tot' )
   15              0.000035   endif
                            
   15              0.000167   if !exists('b:sig_markers')
                                " b:sig_markers = { lnum => marker }
    3              0.000012     let b:sig_markers = {}
   12              0.000026   else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
   12              0.000076     let l:line_tot = line('$')
   12              0.000106     call filter( b:sig_markers, 'v:key <= l:line_tot' )
   15              0.000030   endif
                            
   15   0.001193   0.000523   call signature#utils#Set('b:sig_DummyExists'         , 0                          , a:0 && a:1)
   15   0.000902   0.000350   call signature#utils#Set('b:sig_enabled'             , g:SignatureEnabledAtStartup, a:0 && a:1)
   15   0.000948   0.000408   call signature#utils#Set('b:SignatureIncludeMarks'   , g:SignatureIncludeMarks    , a:0 && a:1)
   15   0.000851   0.000341   call signature#utils#Set('b:SignatureIncludeMarkers' , g:SignatureIncludeMarkers  , a:0 && a:1)
   15   0.000970   0.000372   call signature#utils#Set('b:SignatureMarkOrder'      , g:SignatureMarkOrder       , a:0 && a:1)
   15   0.000899   0.000329   call signature#utils#Set('b:SignaturePrioritizeMarks', g:SignaturePrioritizeMarks , a:0 && a:1)
   15   0.000899   0.000431   call signature#utils#Set('b:SignatureDeferPlacement' , g:SignatureDeferPlacement  , a:0 && a:1)
   15   0.000844   0.000321   call signature#utils#Set('b:SignatureWrapJumps'      , g:SignatureWrapJumps       , a:0 && a:1)

FUNCTION  307()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:94
Called 642 times
Total time:   0.002044
 Self time:   0.002044

count  total (s)   self (s)
  642              0.001774 	return self.variables.char

FUNCTION  35()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:122
Called 4 times
Total time:   0.000424
 Self time:   0.000330

count  total (s)   self (s)
    4              0.000037     let self.ticks -= 1
    4              0.000031     let active = self == s:blink && self.ticks > 0
                            
    4   0.000139   0.000045     if !self.clear() && active && &hlsearch
    2              0.000145       let w:vista_blink_id = matchaddpos('IncSearch', [s:hi_pos])
    4              0.000009     endif
    4              0.000010     if active
    3              0.000023       call timer_start(self.delay, self.tick)
    4              0.000006     endif

FUNCTION  36()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:134
Called 7 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    7              0.000053     if exists('w:vista_blink_id')
    2              0.000012       call matchdelete(w:vista_blink_id)
    2              0.000007       unlet w:vista_blink_id
    2              0.000004       return 1
    5              0.000009     endif

FUNCTION  122()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:375
Called 8 times
Total time:   0.000113
 Self time:   0.000088

count  total (s)   self (s)
    8   0.000110   0.000085 	return remove(self.input_key_stack(), 0)

FUNCTION  124()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:388
Called 2 times
Total time:   0.000413
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000008 	let self.variables.tap_key = ""
    2              0.000006 	let self.variables.char = ""
    2              0.000004 	let self.variables.input = ""
    2              0.000005 	let self.variables.exit = 0
    2              0.000006 	let self.variables.exit_code = 1
    2              0.000006 	let self.variables.enable_keymapping = 1
    2              0.000007 	let self.variables.input_key_stack = []
    2   0.000367   0.000067 	let self.line = deepcopy(s:String.make())

FUNCTION  125()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:416
Called 2 times
Total time:   0.001554
 Self time:   0.000415

count  total (s)   self (s)
    2   0.000429   0.000016 	call self.__init_variables()
    2   0.000191   0.000020 	call self.hl_cursor_off()
    2              0.000047 	if !hlexists(self.highlights.cursor)
    1   0.000571   0.000016 		if s:_is_valid_highlight("Cursor")
                            			execute "highlight link " . self.highlights.cursor . " Cursor"
    1              0.000001 		else
                            			" Workaround by CUI Vim Cursor Highlight
                            			" issues #92
                            			" https://github.com/osyo-manga/vital-over/issues/92
    1              0.000039 			execute "highlight " . self.highlights.cursor . " term=reverse cterm=reverse gui=reverse"
    1              0.000002 		endif
    2              0.000003 	endif
    2              0.000036 	if !hlexists(self.highlights.cursor_on)
    1              0.000099 		execute "highlight link " . self.highlights.cursor_on . " " . self.highlights.cursor
    2              0.000004 	endif
    2              0.000041 	if !hlexists(self.highlights.cursor_insert)
    1              0.000048 		execute "highlight " . self.highlights.cursor_insert . " cterm=underline term=underline gui=underline"
    2              0.000003 	endif

FUNCTION  128()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:458
Called 8 times
Total time:   0.036839
 Self time:   0.000590

count  total (s)   self (s)
    8              0.000029 	let char = a:char
    8              0.000143 	let self.variables.input_key = char
    8              0.000026 	let self.variables.char = char
    8   0.000228   0.000063 	call self.setchar(self.variables.char)
    8              0.000022 	let self.variables.is_setted = 0
    8   0.021991   0.000076 	call self.callevent("on_char_pre")
    8   0.000480   0.000150 	call self.insert(self.variables.input)
    8   0.013907   0.000068 	call self.callevent("on_char")

FUNCTION  129()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:470
Called 10 times
Total time:   0.041953
 Self time:   0.001494

count  total (s)   self (s)
   10              0.000108 	if a:input == ""
    2              0.000005 		return
    8              0.000010 	endif
                            
    8              0.000088 	let self.variables.input_key = a:input
    8              0.000019 	if a:0 == 0
                            		let keymapping = self.__get_keymapping()
    8              0.000013 	else
    8              0.000023 		let keymapping = a:1
    8              0.000011 	endif
    8   0.000118   0.000093 	if self.is_enable_keymapping()
    8   0.002648   0.000230 		let key = s:Keymapping.unmapping(keymapping, a:input)
                            	else
                            		let key = a:input
    8              0.000011 	endif
    8              0.000018 	if key == ""
                            		return
    8              0.000012 	endif
                            
    8   0.001211   0.000229 	call self.set_input_key_stack(s:String.split_by_keys(key))
   16   0.000330   0.000248 	while !(empty(self.input_key_stack()) || self.is_exit())
    8   0.037123   0.000171 		call self.__input_char(self.input_key_stack_pop())
   16              0.000031 	endwhile

FUNCTION  <SNR>191_RestoreViewIfNeeded()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:161
Called 50 times
Total time:   0.008063
 Self time:   0.006958

count  total (s)   self (s)
   50              0.000385     let l:saved_view = getbufvar(a:buffer, 'ale_winview', {})
                            
                                " Saved view is empty, can't do anything
   50              0.000236     if empty(l:saved_view)
                                    return
   50              0.000065     endif
                            
                                " Check wether the cursor has moved since linting was actually requested. If
                                " the user has indeed moved lines, do nothing
   50              0.000352     let l:current_view = winsaveview()
                            
   50              0.000333     if l:current_view['lnum'] != l:saved_view['lnum']
                                    return
   50              0.000078     endif
                            
                                " Anchor view by topline if the list is set to open horizontally
   50   0.001616   0.000511     if ale#Var(a:buffer, 'list_vertical') == 0
   50              0.004272         call winrestview({'topline': l:saved_view['topline']})
   50              0.000082     endif

FUNCTION  vista#cursor#FindNearestMethodOrFunction()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:406
Called 2179 times
Total time:   0.228977
 Self time:   0.127612

count  total (s)   self (s)
 2179              0.033602   if !exists('t:vista') || !has_key(t:vista, 'functions') || bufnr('') != t:vista.source.bufnr
  102              0.000277     return
 2077              0.003522   endif
                            
 2077   0.135112   0.033747   call s:StopFindTimer()
                            
 2077              0.010192   if empty(t:vista.functions)
 2077              0.026860     call setbufvar(t:vista.source.bufnr, 'vista_nearest_method_or_function', '')
 2077              0.004077     return
                              endif
                            
                              let s:find_timer = timer_start( s:find_delay, function('s:FindNearestMethodOrFunction'), )

FUNCTION  <SNR>264_make_special_chars()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/NoInsert.vim:39
Called 1 time
Total time:   0.000045
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000038   0.000020 	let module = s:make([])
    1              0.000003 	function! module.is_no_insert(char)
                            		return char2nr(a:char) == 128 || char2nr(a:char) < 27
                            	endfunction
    1              0.000002 	return module

FUNCTION  incsearch#over#modules#module_management#make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/module_management.vim:41
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000008   let m = deepcopy(s:module_management)
    1              0.000003   let m.modules = a:modules
    1              0.000002   return m

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:9
Called 24 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   24              0.000075   return s:available

FUNCTION  AutoPairsMap()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:445
Called 36 times
Total time:   0.001603
 Self time:   0.001603

count  total (s)   self (s)
                              " | is special key which separate map command from text
   36              0.000095   let key = a:key
   36              0.000072   if key == '|'
                                let key = '<BAR>'
   36              0.000041   end
   36              0.000256   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   36              0.001009   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:35
Called 6595 times
Total time:   0.090340
 Self time:   0.089606

count  total (s)   self (s)
 6595              0.054869   if exists('s:current_buffer_list')
 6589              0.023700     return s:current_buffer_list
    6              0.000006   endif
                            
    6              0.000042   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    6              0.000036   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    6              0.000037   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    6              0.000073   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    6              0.000016   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
   20              0.000047   for nr in list
   14              0.000053     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
    8              0.000036       if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
    8              0.000052       elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
    8   0.000702   0.000132       elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
    8   0.000286   0.000122       elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
    8              0.000009       endif
                            
    8              0.000044       call add(buffers, nr)
   14              0.000019     endif
   20              0.000041   endfor
                            
    6              0.000033   let s:current_buffer_list = buffers
    6              0.000015   return buffers

FUNCTION  <SNR>246__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Highlight.vim:15
Called 1 time
Total time:   0.000987
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000984   0.000009 	let s:Message  = s:V.import("Vim.Message")

FUNCTION  130()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:503
Called 8 times
Total time:   0.050222
 Self time:   0.001134

count  total (s)   self (s)
    8   0.000082   0.000057 	if !self.is_enable_keymapping()
                            		return self.__input(s:Input.getchar())
    8              0.000014 	endif
                            
    8   0.000822   0.000110 	let input = s:Input.getchar()
    8   0.000180   0.000076 	let old_line = self.getline()
    8   0.000125   0.000054 	let old_pos  = self.getpos()
    8   0.004843   0.000066 	let keymapping = self.__get_keymapping()
    8              0.000015 	try
    8              0.000035 		let t = reltime()
    8   0.000916   0.000173 		while s:is_input_waiting(keymapping, input)		&& str2nr(reltimestr(reltime(t))) * 1000 < &timeoutlen
                            			call self.setline(old_line)
                            			call self.insert(input)
                            			call self.setpos(old_pos)
                            			call self.draw()
                            			let input .= s:Input.getchar(0)
    8              0.000016 		endwhile
    8              0.000015 	finally
    8   0.000424   0.000068 		call self.setline(old_line)
    8   0.000424   0.000060 		call self.setpos(old_pos)
    8              0.000032 	endtry
    8   0.042087   0.000151 	call self.__input(input, keymapping)

FUNCTION  131()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:530
Called 8 times
Total time:   0.689475
 Self time:   0.000465

count  total (s)   self (s)
                            " 	call self.callevent("on_update")
                            " 	if !getchar(1)
                            " 		continue
                            " 	endif
                            "
                            " 	call self.__input(s:getchar(0))
                            " 	call self.draw()
                            
    8   0.009474   0.000118 	call self.callevent("on_update")
    8   0.050364   0.000142 	call self.__inputting()
                            " 	call self.__input(s:Input.getchar())
    8   0.000111   0.000086 	if self.is_exit()
    2              0.000004 		return -1
    6              0.000009 	endif
    6   0.629462   0.000055 	call self.draw()

FUNCTION  132()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:549
Called 2 times
Total time:   1.034702
 Self time:   0.000498

count  total (s)   self (s)
    2              0.000005 	try
    2   0.001570   0.000016 		call self.__init()
    2   0.004745   0.000028 		call self.callevent("on_enter")
                            
    2   0.000059   0.000042 		call self.__input(get(a:, 1, ""))
    2   0.223630   0.000021 		call self.draw()
    8   0.000107   0.000078 		while !self.is_exit()
    8              0.000011 			try
    8   0.689544   0.000069 				if self.__update()
    2              0.000004 					break
    6              0.000009 				endif
                            			catch
                            				call self.callevent("on_exception")
    8              0.000020 			endtry
    8              0.000015 		endwhile
                            	catch
                            		echohl ErrorMsg | echom v:throwpoint . " " . v:exception | echohl None
                            		let self.variables.exit_code = -1
    2              0.000004 	finally
    2   0.000170   0.000014 		call self.__finish()
    2   0.114671   0.000034 		call self.callevent("on_leave")
    2              0.000006 	endtry
    2   0.000036   0.000026 	return self.exit_code()

FUNCTION  133()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:576
Called 2 times
Total time:   0.000156
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000156   0.000012 	call self.hl_cursor_on()

FUNCTION  135()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:586
Called 24 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   24              0.000066 	return self.variables.exit

FUNCTION  136()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:591
Called 8 times
Total time:   0.004777
 Self time:   0.002863

count  total (s)   self (s)
    8              0.000024 	let result = {}
                            " 	for module in values(self.variables.modules)
  144   0.001778   0.000385 	for module in self.variables.modules.slots()
  136              0.000523 		if has_key(module, "keymapping")
   16              0.000036 			if module isnot self
    8   0.000596   0.000151 				call extend(result, module.keymapping(self))
   16              0.000025 			endif
  136              0.000163 		endif
  144              0.000227 	endfor
    8   0.000278   0.000202 	return extend(extend(result, self.variables.keymapping), self.keymapping())

FUNCTION  137()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:41
Called 10 times
Total time:   0.000441
 Self time:   0.000164

count  total (s)   self (s)
   10   0.000432   0.000155 	return type(a:item) == type("") ? self.set_str(a:item)		 : type(a:item) == type(0)  ? self.set_pos(a:item)		 : self

FUNCTION  138()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:47
Called 26 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   26              0.000193 	return join(self.list, "")

FUNCTION  139()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:51
Called 8 times
Total time:   0.000288
 Self time:   0.000193

count  total (s)   self (s)
    8   0.000268   0.000173 	let self.col = s:_clamp(a:pos, 0, self.length())
    8              0.000016 	return self

FUNCTION  <SNR>136_PollSignatureHelp()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:948
Called 25254969 times
Total time: 5662.826055
 Self time: 1402.916628

count  total (s)   self (s)
25254969 3851.913300 442.854239   if !s:ShouldUseSignatureHelp()
                                return
25254969             42.761175   endif
                            
25254969 1246.495222 395.644856   if !s:Pyeval( 'ycm_state.SignatureHelpRequestReady()' )
25254969            364.854910     let s:pollers.signature_help.id = timer_start( s:pollers.signature_help.wait_milliseconds, function( 's:PollSignatureHelp' ) )
25254969             47.008515     return
                              endif
                            
                              let s:signature_help = s:Pyeval( 'ycm_state.GetSignatureHelpResponse()' )
                              call s:UpdateSignatureHelp()

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:194
Called 6489 times
Total time:   1.475797
 Self time:   0.416028

count  total (s)   self (s)
 6489   0.246393   0.159585   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
 6489              0.054826   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
 6489   1.166544   0.193583   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>127_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:40
Called 24 times
Total time:   0.000253
 Self time:   0.000253

count  total (s)   self (s)
   24              0.000123   if has('unix')
   24              0.000096     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  vista#ShouldSkip()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:15
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000007   let blacklist = ['vista', 'vista_kind', 'nerdtree', 'startify', 'tagbar', 'fzf', 'gitcommit']
                            
    1              0.000007   return !empty(&buftype) || empty(&filetype) || index(blacklist, &filetype) > -1

FUNCTION  ale#linter#Define()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:360
Called 10 times
Total time:   0.009384
 Self time:   0.000638

count  total (s)   self (s)
                                " This command will throw from the sandbox.
   10   0.000080   0.000077     let &l:equalprg=&l:equalprg
                            
   10   0.008929   0.000186     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
   10              0.000057     if !has_key(s:linters, a:filetype)
    2              0.000011         let s:linters[a:filetype] = []
   10              0.000015     endif
                            
                                " Remove previously defined linters with the same name.
   10              0.000165     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
   10              0.000063     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  EasyMotion#attach_active_autocmd()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:762
Called 2 times
Total time:   0.000576
 Self time:   0.000576

count  total (s)   self (s)
                                " Reference: https://github.com/justinmk/vim-sneak
    2              0.000017     augroup plugin-easymotion-active
    2              0.000482         autocmd!
    2              0.000046         autocmd InsertEnter,WinLeave,BufLeave <buffer> let s:EasyMotion_is_active = 0  | autocmd! plugin-easymotion-active * <buffer>
    2              0.000019         autocmd CursorMoved <buffer> autocmd plugin-easymotion-active CursorMoved <buffer> let s:EasyMotion_is_active = 0  | autocmd! plugin-easymotion-active * <buffer>
    2              0.000003     augroup END

FUNCTION  11()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:25
Called 108 times
Total time:   0.001202
 Self time:   0.001202

count  total (s)   self (s)
  108              0.001121   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:14
Called 2 times
Total time:   0.000062
 Self time:   0.000044

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    2   0.000058   0.000040     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  141()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:60
Called 8 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    8              0.000047 	return join(self.list[self.col+1 : ], '')

FUNCTION  142()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:64
Called 16 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   16              0.000070 	return get(self.list, self.col, "")

FUNCTION  143()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:68
Called 10 times
Total time:   0.000277
 Self time:   0.000277

count  total (s)   self (s)
   10              0.000195 	let self.list = split(a:str, '\zs')
   10              0.000053 	let self.col  = strchars(a:str)
   10              0.000020 	return self

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:416
Called 50 times
Total time:   0.042860
 Self time:   0.008000

count  total (s)   self (s)
   50              0.000501     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
   50              0.000067     endif
                            
                                " Find the current markers
   50   0.016303   0.001115     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
   50   0.004491   0.001255     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
   50   0.003147   0.000900     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
   50   0.009353   0.001141     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
   50   0.006958   0.000981     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
   50              0.000213     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
   50              0.000082     endif
                            
   50              0.000172     for l:command in l:command_list
                                    silent! execute l:command
   50              0.000075     endfor
                            
                                " Reset the sign column color when there are no more errors.
   50              0.000188     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
   50              0.000115     endif

FUNCTION  145()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:78
Called 8 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    8              0.000108 	call extend(self.list, split(a:str, '\zs'), self.col)
    8              0.000073 	let self.col += len(split(a:str, '\zs'))
    8              0.000018 	return self

FUNCTION  <SNR>135_OnBufEnter()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/autocmd.vim:17
Called 1 time
Total time:   0.000051
 Self time:   0.000024

count  total (s)   self (s)
                              " If we just enter the buffer that is being displayed, skip the update.
    1              0.000007   if !exists('t:vista') || a:bufnr == t:vista.source.bufnr
                                return
    1              0.000001   endif
                            
    1   0.000040   0.000013   call s:GenericAutoUpdate(a:bufnr, a:fpath)

FUNCTION  <SNR>136_PollCompletion()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:920
Called 9330 times
Total time:  11.065446
 Self time:   0.682395

count  total (s)   self (s)
 9330   6.658951   0.210780   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
 5262              0.162707     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
 5262              0.017492     return
 4068              0.007923   endif
                            
 4068   1.931496   0.111331   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
 4068   2.211711   0.096996   call s:Complete()

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:230
Called 24 times
Total time:   0.040641
 Self time:   0.001457

count  total (s)   self (s)
   24              0.000237   let modified_lines = []
   48              0.000140   for hunk in a:hunks
   24   0.039941   0.000757     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   48              0.000085   endfor
   24              0.000062   return modified_lines

FUNCTION  <SNR>136_InsideCommentOrStringAndShouldStop()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:878
Called 5594 times
Total time:  12.243446
 Self time:   0.262270

count  total (s)   self (s)
 5594  12.103104   0.121928   let retval = s:InsideCommentOrString()
 5594              0.025232   let inside_comment = retval == 1
 5594              0.020350   let inside_string = retval == 2
                            
 5594              0.036172   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
  288              0.000567     return 0
 5306              0.009068   endif
                            
 5306              0.022132   return retval

FUNCTION  <SNR>126_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:158
Called 28 times
Total time:   0.002887
 Self time:   0.001119

count  total (s)   self (s)
   28   0.002559   0.000791   let p = gitgutter#utility#repo_path(a:bufnr, 0)
                            
   28              0.000218   if type(p) == s:t_string && !empty(p)  " if path is known
   28              0.000066     return
                              endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  incsearch#highlight#update()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/highlight.vim:44
Called 18 times
Total time:   0.030128
 Self time:   0.000515

count  total (s)   self (s)
                              " it's intuiive to call incsearch#highlight#on() & off() but there are no
                              " need to execute `:nohlsearch` when updating.
   18   0.015759   0.000256   call s:hi.disable_all()
   18   0.014280   0.000170   call s:hi.enable_all()

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:81
Called 474 times
Total time:   0.013635
 Self time:   0.013635

count  total (s)   self (s)
  474              0.003429     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
    1              0.000015         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
    1              0.000003         return 1
  473              0.000927     endif
                            
  473              0.001097     return 0

FUNCTION  <SNR>105_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:158
Called 17052 times
Total time:  22.809995
 Self time:   2.013744

count  total (s)   self (s)
51156              0.224481   for vcs in keys(s:vcs_config)
34104  21.552223   0.755972     call {s:vcs_config[vcs].update_branch}()
34104              0.279909     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
34104              0.052326     endif
51156              0.095824   endfor

FUNCTION  <SNR>103_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:27
Called 17052 times
Total time:   2.099168
 Self time:   0.655883

count  total (s)   self (s)
17052   0.577967   0.338323   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
   50              0.000099     return ''
17002              0.025621   endif
17002   1.441273   0.237632   return GitGutterGetHunkSummary()

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:200
Called 106 times
Total time:   0.018575
 Self time:   0.009963

count  total (s)   self (s)
  106              0.002666   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
  106              0.000752   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
  106              0.000155   else
  106              0.000836     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
  106              0.000817     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
  106              0.000145   endif
                            
  106   0.011373   0.002761   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  <SNR>191_CloseWindowIfNeeded()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:201
Called 50 times
Total time:   0.018538
 Self time:   0.006392

count  total (s)   self (s)
   50   0.004492   0.001039     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
                                    return
   50              0.000064     endif
                            
   50              0.000212     let l:did_close_any_list = 0
                            
   50              0.000084     try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
   50              0.000163         if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
   50              0.000084         else
   50   0.001418   0.000788             let l:win_ids = s:WinFindBuf(a:buffer)
                            
  100              0.000330             for l:win_id in l:win_ids
   50              0.000361                 if g:ale_set_loclist && empty(getloclist(l:win_id))
   50              0.000119                     lclose
   50              0.000176                     let l:did_close_any_list = 1
   50              0.000069                 endif
  100              0.000153             endfor
   50              0.000067         endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
   50              0.000086     endtry
                            
   50              0.000144     if l:did_close_any_list
   50   0.009042   0.000979         call s:RestoreViewIfNeeded(a:buffer)
   50              0.000064     endif

FUNCTION  <SNR>194_should_use_smartsign()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:673
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
                                " Smartsign Dictionary exists?
                                " \A: non-alphabetic character
                                " Do not use smartsign for n-key find search motions
    2              0.000031     if (exists('g:EasyMotion_use_smartsign_us')  ||   exists('g:EasyMotion_use_smartsign_jp')) &&  match(a:char, '\A') != -1 && exists('s:current.is_search') && s:current.is_search == 0
                                    return 1
    2              0.000003     else
    2              0.000003         return 0
                                endif

FUNCTION  vital#_incsearch#Over#Commandline#Modules#Delete#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Delete.vim:7
Called 1 time
Total time:   0.000029
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000028   0.000022 return map({'make': ''}, "vital#_incsearch#function('<SNR>252_' . v:key)")

FUNCTION  airline#section#create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:74
Called 2 times
Total time:   0.000720
 Self time:   0.000030

count  total (s)   self (s)
    2   0.000718   0.000028   return s:create(a:parts, 0)

FUNCTION  153()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:40
Called 17 times
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
   17              0.000071 	let self.variables.counter += 1
   17              0.000102 	let slot = { "id" : self.variables.counter, "slot" : a:slot }
   17              0.000079 	call add(self.variables.slots, slot)
   17              0.000037 	return slot

FUNCTION  157()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:78
Called 17 times
Total time:   0.000663
 Self time:   0.000663

count  total (s)   self (s)
   17              0.000656 	return filter(copy(self.variables.slots), a:expr)

FUNCTION  158()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:83
Called 17 times
Total time:   0.000878
 Self time:   0.000215

count  total (s)   self (s)
   17   0.000870   0.000207 	return get(self.find_by(a:expr), 0, {})

FUNCTION  159()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:88
Called 44 times
Total time:   0.033945
 Self time:   0.000776

count  total (s)   self (s)
   44   0.033919   0.000750 	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)

FUNCTION  <SNR>235_new()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:37
Called 21 times
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
   21              0.000219   let base = deepcopy(s:Vital)
   21              0.000086   let base._plugin_name = a:plugin_name
   21              0.000045   return base

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 16 times
Total time:   0.029054
 Self time:   0.002515

count  total (s)   self (s)
   16              0.000069   let winnr = a:context.winnr
   16              0.000059   let active = a:context.active
                            
   16   0.000454   0.000324   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    9   0.006836   0.000214     call s:build_sections(a:builder, a:context, s:layout[0])
    7              0.000009   else
    7   0.000594   0.000093     let text = s:get_section(winnr, 'c')
    7              0.000019     if empty(text)
                                  let text = ' %f%m '
    7              0.000011     endif
    7   0.000192   0.000106     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   16              0.000024   endif
                            
   16   0.002165   0.000415   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   16   0.000376   0.000242   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   16   0.017882   0.000566     call s:build_sections(a:builder, a:context, s:layout[1])
   16              0.000025   endif
                            
   16              0.000034   return 1

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:24
Called 1853 times
Total time:   0.042016
 Self time:   0.042016

count  total (s)   self (s)
 1853              0.025782     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
 1853              0.013002     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>233_lazy_config()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/config.vim:35
Called 3 times
Total time:   0.000111
 Self time:   0.000073

count  total (s)   self (s)
    3              0.000016   let m = mode(1)
    3   0.000092   0.000054   return {   'count': v:count,   'mode': m,   'is_expr': (m is# 'no'),   'keymap': s:keymap() }

FUNCTION  ale#handlers#alex#CreateCommandCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/alex.vim:12
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000023     return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))            . ' %s '            . a:flags}

FUNCTION  <SNR>242_call()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:61
Called 84 times
Total time:   1.289436
 Self time:   0.017213

count  total (s)   self (s)
   84              0.000689 	let args = get(a:, 1, [])
   84              0.000387 	let def = get(a:, 2, 0)
   84   1.288270   0.016047 	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")

FUNCTION  <SNR>191_ShouldOpen()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:34
Called 100 times
Total time:   0.004768
 Self time:   0.002517

count  total (s)   self (s)
  100   0.003385   0.001134     let l:val = ale#Var(a:buffer, 'open_list')
  100              0.000799     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
  100              0.000468     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>265__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/KeyMapping.vim:15
Called 1 time
Total time:   0.002719
 Self time:   0.000016

count  total (s)   self (s)
    1   0.002719   0.000016 	let s:Keymapping = a:V.import("Palette.Keymapping")

FUNCTION  vista#jump#TagLine()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/jump.vim:6
Called 1 time
Total time:   0.003610
 Self time:   0.000278

count  total (s)   self (s)
    1              0.000024   let cur_line = split(getline('.'), ':')
                            
                              " Skip if the current line or the target line is empty
    1              0.000005   if empty(cur_line)
                                return
    1              0.000002   endif
                            
    1              0.000008   let lnum = cur_line[-1]
    1              0.000010   let line = getbufline(t:vista.source.bufnr, lnum)
                            
    1              0.000004   if empty(line)
                                return
    1              0.000002   endif
                            
    1              0.000002   try
    1              0.000019     let [_, start, _] = matchstrpos(line[0], a:tag)
                              catch /^Vim\%((\a\+)\)\=:E869/
                                let start  = -1
    1              0.000002   endtry
                            
    1   0.000154   0.000022   call vista#source#GotoWin()
                              " Move cursor to the column of tag located, otherwise the first column
    1              0.000010   call cursor(lnum, start > -1 ? start+1 : 1)
    1              0.000085   normal! zz
                            
    1   0.001581   0.000029   call call('vista#util#Blink', get(g:, 'vista_top_level_blink', [2, 100]))
                            
    1   0.001667   0.000019   call vista#GenericCloseOverlay()
                            
    1              0.000007   if get(g:, 'vista_close_on_jump', 0)
                                call vista#sidebar#Close()
    1              0.000002   endif

FUNCTION  vital#_easymotion#Vim#Buffer#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Buffer.vim:5
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000064     return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>201__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:21
Called 1 time
Total time:   0.000144
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000005 	let s:V = a:V
    1   0.000138   0.000017 	let s:L = s:V.import("Data.List")

FUNCTION  vista#util#SetBufline()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:97
Called 1 time
Total time:   0.042203
 Self time:   0.000026

count  total (s)   self (s)
    1   0.042202   0.000025   call vista#WinExecute(t:vista.winnr(), function('s:SafeSetBufline'), a:bufnr, a:lines)

FUNCTION  161()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:98
Called 52 times
Total time:   0.008205
 Self time:   0.005555

count  total (s)   self (s)
   52   0.008179   0.005529 	return map(copy(self.variables.slots), "self.get_slot(v:val)")

FUNCTION  162()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:29
Called 884 times
Total time:   0.002650
 Self time:   0.002650

count  total (s)   self (s)
  884              0.002310 		return a:val.slot.module

FUNCTION  163()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim:26
Called 8 times
Total time:   0.000417
 Self time:   0.000154

count  total (s)   self (s)
    8   0.000287   0.000072 	if a:cmdline.is_input("<Over>(exit)")
    2   0.000046   0.000012 		call a:cmdline.setchar("")
    2   0.000029   0.000015 		call a:cmdline.exit(self.exit_code)
    8              0.000012 	endif

FUNCTION  164()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim:24
Called 8 times
Total time:   0.000506
 Self time:   0.000176

count  total (s)   self (s)
    8   0.000437   0.000107 	if a:cmdline.is_input("\<Esc>")	|| a:cmdline.is_input("\<C-c>")
                            " 		call a:cmdline.cancel()
                            		call a:cmdline.exit(1)
                            		call a:cmdline.setchar("")
    8              0.000009 	endif

FUNCTION  166()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:29
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009 	let self.is_execute = 0

FUNCTION  169()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:41
Called 2 times
Total time:   0.111505
 Self time:   0.000061

count  total (s)   self (s)
    2   0.003031   0.000035 	if self.is_execute == 0 && a:cmdline.exit_code() != -1
    2   0.108470   0.000022 		call self.redraw(a:cmdline)
    2              0.000002 	endif

FUNCTION  EasyMotion#init()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:20
Called 1 time
Total time:   0.002652
 Self time:   0.000300

count  total (s)   self (s)
    1              0.000004     if s:loaded
                                    return
    1              0.000002     endif
    1              0.000004     let s:loaded = s:TRUE
    1   0.002533   0.000216     call EasyMotion#highlight#load()
                                " Store previous motion info
    1              0.000004     let s:previous = {}
                                " Store previous operator-pending motion info for '.' repeat
    1              0.000003     let s:dot_repeat = {}
                                " Prepare 1-key Migemo Dictionary
    1              0.000003     let s:migemo_dicts = {}
    1              0.000004     let s:EasyMotion_is_active = 0
    1   0.000045   0.000010     call EasyMotion#reset()
                                " Anywhere regular expression: {{{
    1              0.000007     let re = '\v' .    '(<.|^$)' . '|' .    '(.>|^$)' . '|' .    '(\l)\zs(\u)' . '|' .    '(_\zs.)' . '|' .    '(#\zs.)'
                                " 1. word
                                " 2. end of word
                                " 3. CamelCase
                                " 4. after '_' hoge_foo
                                " 5. after '#' hoge#foo
    1              0.000007     let g:EasyMotion_re_anywhere = get(g:, 'EasyMotion_re_anywhere', re)
                            
                                " Anywhere regular expression within line:
    1              0.000007     let re = '\v' .    '(<.|^$)' . '|' .    '(.>|^$)' . '|' .    '(\l)\zs(\u)' . '|' .    '(_\zs.)' . '|' .    '(#\zs.)'
    1              0.000007     let g:EasyMotion_re_line_anywhere = get(g:, 'EasyMotion_re_line_anywhere', re)
                                "}}}
                                " For other plugin
    1              0.000004     let s:EasyMotion_is_cancelled = 0
                                " 0 -> Success
                                " 1 -> Cancel
    1              0.000004     let g:EasyMotion_ignore_exception = 0
    1              0.000001     return ""

FUNCTION  <SNR>197__import_func_name()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:204
Called 31 times
Total time:   0.000966
 Self time:   0.000651

count  total (s)   self (s)
   31   0.000946   0.000631   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  <SNR>146_AddProblemsFromOtherBuffers()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:577
Called 1 time
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    1              0.000053     let l:filename = expand('#' . a:buffer . ':p')
    1              0.000003     let l:loclist = []
    1              0.000004     let l:name_map = {}
                            
                                " Build a map of the active linters.
    8              0.000019     for l:linter in a:linters
    7              0.000029         let l:name_map[l:linter.name] = 1
    8              0.000011     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
    2              0.000008     for l:info in values(g:ale_buffer_info)
    1              0.000003         for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
    1              0.000001         endfor
    2              0.000003     endfor
                            
    1              0.000003     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
    1              0.000001     endif

FUNCTION  108()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:271
Called 8 times
Total time:   0.853016
 Self time:   0.000234

count  total (s)   self (s)
    8   0.841247   0.000090 	call self.callevent("on_draw_pre")
    8   0.011761   0.000136 	call self.callevent("on_draw")

FUNCTION  vital#_incsearch#Over#Signals#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:7
Called 1 time
Total time:   0.000146
 Self time:   0.000107

count  total (s)   self (s)
    1   0.000145   0.000106 return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>242_' . v:key)")

FUNCTION  80()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:95
Called 8 times
Total time:   0.000356
 Self time:   0.000068

count  total (s)   self (s)
    8   0.000352   0.000064 	return self.line.set(a:line)

FUNCTION  81()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:100
Called 256 times
Total time:   0.000797
 Self time:   0.000797

count  total (s)   self (s)
  256              0.000711 	return self.variables.char

FUNCTION  83()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:116
Called 8 times
Total time:   0.000071
 Self time:   0.000052

count  total (s)   self (s)
    8   0.000070   0.000051 	return self.line.pos()

FUNCTION  84()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:121
Called 8 times
Total time:   0.000364
 Self time:   0.000076

count  total (s)   self (s)
    8   0.000360   0.000072 	return self.line.set_pos(a:pos)

FUNCTION  86()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:131
Called 8 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    8              0.000027 	if self.variables.tap_key == a:key
                            		let self.variables.tap_key = ""
                            		return 1
    8              0.000010 	endif

FUNCTION  87()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:139
Called 280 times
Total time:   0.000830
 Self time:   0.000830

count  total (s)   self (s)
  280              0.000697 	return self.variables.tap_key

FUNCTION  88()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:144
Called 280 times
Total time:   0.006277
 Self time:   0.004673

count  total (s)   self (s)
  280              0.001382 	let prekey = get(a:, 1, "")
  280   0.004766   0.003162 	return self.get_tap_key() ==# prekey		&& self.char() ==# a:key
                            " \		&& self.char() == (prekey . a:key)

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:41
Called 154379 times
Total time:   2.912728
 Self time:   2.276583

count  total (s)   self (s)
154379   1.831354   1.195209   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
154379              0.240928   endif
154379              0.387712   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:80
Called 48 times
Total time:   0.003473
 Self time:   0.003473

count  total (s)   self (s)
   48              0.000177   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   48              0.000186   endif

FUNCTION  <SNR>199_split_by_keys()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:143
Called 18 times
Total time:   0.001430
 Self time:   0.000495

count  total (s)   self (s)
   18   0.001422   0.000487 	return s:_split_keystring(a:str, "\\%(\<Plug>\\|<Over>\\)(.\\{-})\\zs\\|")

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:10
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000028     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  170()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:53
Called 2 times
Total time:   0.108448
 Self time:   0.108448

count  total (s)   self (s)
    2              0.108239 	redraw
                            	" Workaround for the :set cedit=<C-c>
                            	" https://github.com/osyo-manga/vital-over/issues/52
                            	" https://github.com/Lokaltog/vim-easymotion/issues/177#issuecomment-53663431
    2              0.000052 	if &cedit != "<C-c>"	||(v:version > 704 || v:version == 704 && has("patch441"))
    2              0.000139 		normal! :
                            	else
                            		execute "normal! :\<Esc>"
    2              0.000003 	endif

FUNCTION  171()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:26
Called 8 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    8              0.000064 	if has_key(self, "value")
    6              0.000014 		return
    2              0.000003 	endif
    2              0.000012 	let self.value = &cmdheight

FUNCTION  172()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:33
Called 2 times
Total time:   0.000048
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000008 	if has_key(self, "value")
    2   0.000029   0.000024 		let &cmdheight = self.value
    2              0.000006 		unlet self.value
    2              0.000002 	endif

FUNCTION  173()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:41
Called 8 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    8              0.000025 	return self.value

FUNCTION  174()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:88
Called 8 times
Total time:   0.830616
 Self time:   0.000942

count  total (s)   self (s)
    8   0.000108   0.000069 	if empty(a:cmdline.line.pos_char())
    8              0.000044 		let cursor = "echohl " . a:cmdline.highlights.cursor . " | echon ' '"
                            	else
                            		let cursor = "echohl " . a:cmdline.highlights.cursor_on . " | " . s:_as_echon(a:cmdline.line.pos_char())
    8              0.000010 	endif
    8              0.000017 	let suffix = ""
    8   0.000081   0.000057 	if	a:cmdline.get_suffix() != ""
                            		let suffix = s:_as_echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
    8              0.000010 	endif
    8   0.000844   0.000424 	let self.draw_command  = join([		"echohl " . a:cmdline.highlights.prompt,		s:_as_echon(a:cmdline.get_prompt()),		"echohl NONE",		s:_as_echon(a:cmdline.backward()),		cursor,		"echohl NONE",		s:_as_echon(a:cmdline.forward()),		suffix,	], " | ")
                            
    8   0.829319   0.000128 	call s:_redraw(a:cmdline)

FUNCTION  177()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:144
Called 2 times
Total time:   0.000065
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000064   0.000016 	call s:cmdheight.restore()

FUNCTION  178()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim:24
Called 8 times
Total time:   0.001806
 Self time:   0.000945

count  total (s)   self (s)
    8   0.000448   0.000109 	if a:cmdline.is_input("\<C-h>")	|| a:cmdline.is_input("\<BS>")
                            		if a:cmdline.line.length() == 0
                            			return a:cmdline.exit(1)
                            		else
                            			call a:cmdline.line.remove_prev()
                            			call a:cmdline.setchar('')
                            		endif
    8   0.000216   0.000057 	elseif a:cmdline.is_input("\<Del>")
                            		call a:cmdline.line.remove_pos()
                            		call a:cmdline.setchar('')
    8   0.000227   0.000054 	elseif a:cmdline.is_input("\<C-w>")
                            		let word = a:cmdline.backward_word()
                            		let backward = a:cmdline.backward()[ : -strlen(word)-1 ]
                            		call a:cmdline.setline(backward . a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(strchars(backward))
                            		call a:cmdline.setchar('')
    8   0.000263   0.000073 	elseif a:cmdline.is_input("\<C-u>")
                            		call a:cmdline.setline(a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
    8              0.000011 	endif

FUNCTION  vista#autocmd#Init()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/autocmd.vim:58
Called 1 time
Total time:   0.000375
 Self time:   0.000347

count  total (s)   self (s)
                            
    1   0.000043   0.000015   call s:ClearOtherEvents(a:group_name)
                            
    1              0.000005   if index(s:registered, a:group_name) == -1
                                call add(s:registered, a:group_name)
    1              0.000001   endif
                            
    1              0.000005   let s:ApplyAutoUpdate = a:AUF
                            
    1              0.000007   if exists('#'.a:group_name)
    1              0.000002     let group = ''
    1              0.000005     redir => group
    1              0.000270     silent execute 'autocmd' a:group_name
    1              0.000007     redir END
    1              0.000021     if len(split(group, '\n')) > 1
    1              0.000001       return
                                endif
                              endif
                            
                              execute 'augroup' a:group_name
                                autocmd!
                            
                                " vint: -ProhibitAutocmdWithNoGroup
                                autocmd WinEnter,WinLeave __vista__ call vista#statusline#RenderOnWinEvent()
                            
                                " BufReadPost is needed for reloading the current buffer if the file
                                " was changed by an external command;
                                "
                                " CursorHold and CursorHoldI event have been removed in order to
                                " highlight the nearest tag automatically.
                                autocmd BufWritePost,BufReadPost, * call s:GenericAutoUpdate(+expand('<abuf>'), fnamemodify(expand('<afile>'), ':p'))
                            
                                autocmd BufEnter * call s:OnBufEnter(+expand('<abuf>'), fnamemodify(expand('<afile>'), ':p'))
                            
                                if get(g:, 'vista_update_on_text_changed', 0)
                                  autocmd TextChanged,TextChangedI * call s:AutoUpdateWithDelay(+expand('<abuf>'), fnamemodify(expand('<afile>'), ':p'))
                                endif
                              augroup END

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:377
Called 2894 times
Total time:   0.027076
 Self time:   0.027076

count  total (s)   self (s)
 2894              0.025482     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  airline#extensions#prepend_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:64
Called 6 times
Total time:   0.000427
 Self time:   0.000262

count  total (s)   self (s)
    6   0.000336   0.000171   call <sid>check_defined_section(a:name)
    6              0.000081   let w:airline_section_{a:name} = a:value . w:airline_section_{a:name}

FUNCTION  316()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:151
Called 4 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    4              0.000018 	let self.variables.prompt = a:prompt

FUNCTION  <SNR>136_IdentifierFinishedOperations()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:849
Called 5594 times
Total time:   2.547883
 Self time:   1.716150

count  total (s)   self (s)
 5594   0.920845   0.089112   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
 4302              0.011962     return
 1292              0.002055   endif
 1292              1.555841   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
 1292              0.014882   let s:force_semantic = 0
 1292              0.029604   let s:completion = s:default_completion

FUNCTION  91()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:162
Called 16 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   16              0.000037 	return self.variables.prompt

FUNCTION  93()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:172
Called 16 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   16              0.000038 	return self.variables.suffix

FUNCTION  94()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:177
Called 8 times
Total time:   0.000330
 Self time:   0.000128

count  total (s)   self (s)
    8              0.000017 	if a:0
                            		call self.line.set(a:1)
    8              0.000013 	endif
    8   0.000267   0.000065 	call self.line.input(a:word)

FUNCTION  96()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:188
Called 8 times
Total time:   0.000117
 Self time:   0.000052

count  total (s)   self (s)
    8   0.000113   0.000048 	return self.line.backward()

FUNCTION  98()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:199
Called 27 times
Total time:   0.015143
 Self time:   0.012131

count  total (s)   self (s)
   27              0.000161 	if type(a:module) == type("")
   10   0.011565   0.000181 		return call(self.connect, [s:Module.make(a:module)] + a:000, self)
   17              0.000026 	endif
   17              0.000055 	if empty(a:module)
                            		return
   17              0.000025 	endif
   17              0.000099 	let name = a:0 > 0 ? a:1 : a:module.name
   17   0.001135   0.000257 	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(name))
   17              0.000052 	if empty(slot)
   17   0.000491   0.000188 		call self.variables.modules.connect({ "name" : name, "module" : a:module })
                            	else
                            		let slot.slot.module = a:module
   17              0.000025 	endif
                            " 	let self.variables.modules[name] = a:module

FUNCTION  319()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:166
Called 28 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   28              0.000081 	return self.variables.suffix

FUNCTION  <SNR>287_get_list()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/list.vim:39
Called 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000004     let row = prevnonblank(a:row)
                            
    1              0.000005     let save_pos = getpos('.')
    1              0.000003     call cursor(row,1)
                            
    1              0.000022     while getline(row) !~ s:p.b_e_list && row != 0
                                    let idt = indent(row)
                                    if idt == 0 
                                        let row = 0
                                        break
                                    endif
                                    let idt_ptn = '^\s\{,'.(idt-1).'}\S'
                                    let [row, col] = searchpos(idt_ptn, 'b',0,100)
    1              0.000002     endwhile
                                
    1              0.000004     call setpos('.',save_pos)
                            
    1              0.000002     return row

FUNCTION  <SNR>248__finish()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim:102
Called 18 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
   18              0.000142 	if exists("s:old_statusline")
                            		let &statusline = s:old_statusline
                            		unlet s:old_statusline
                            		redrawstatus
   18              0.000026 	endif

FUNCTION  180()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim:25
Called 8 times
Total time:   0.000346
 Self time:   0.000163

count  total (s)   self (s)
    8   0.000239   0.000056 	if a:cmdline.is_input("<Over>(paste)")
                            		let register = v:register == "" ? '"' : v:register
                            		call a:cmdline.insert(tr(getreg("*"), "\n", "\r"))
                            		call a:cmdline.setchar('')
    8              0.000012 	endif

FUNCTION  183()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:117
Called 8 times
Total time:   0.002101
 Self time:   0.001051

count  total (s)   self (s)
    8   0.000494   0.000108 	if a:cmdline.is_input("<Over>(buffer-complete)")		|| a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            		if self.complete(a:cmdline) == -1
                            			call s:_finish()
                            			call a:cmdline.setchar('')
                            			return
                            		endif
                            		if a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            		call a:cmdline.setchar('')
                            		call a:cmdline.tap_keyinput("Completion")
                            " 	elseif a:cmdline.is_input("\<Tab>", "Completion")
    8   0.000415   0.000169 	elseif a:cmdline.is_input("<Over>(buffer-complete)", "Completion")		|| a:cmdline.is_input("\<Right>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count += 1
                            		if s:count >= len(s:complete_list)
                            			let s:count = 0
                            		endif
    8   0.000352   0.000114 	elseif a:cmdline.is_input("<Over>(buffer-complete-prev)", "Completion")		|| a:cmdline.is_input("\<Left>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count -= 1
                            		if s:count < 0
                            			let s:count = len(s:complete_list) - 1
                            		endif
    8              0.000011 	else
    8   0.000157   0.000085 		if a:cmdline.untap_keyinput("Completion")
                            			call a:cmdline.callevent("on_char_pre")
    8              0.000011 		endif
    8   0.000201   0.000093 		call s:_finish()
    8              0.000011 		return
                            	endif
                            	call a:cmdline.setline(s:line)
                            	call a:cmdline.insert(s:complete_list[s:count], s:pos)
                            	if len(s:complete_list) > 1
                            		let &statusline = s:_as_statusline(s:complete_list, s:count)
                            		redrawstatus
                            	endif
                            	if len(s:complete_list) == 1
                            		call a:cmdline.untap_keyinput("Completion")
                            	endif

FUNCTION  184()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:164
Called 8 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                            " 	redrawstatus

FUNCTION  185()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:169
Called 2 times
Total time:   0.000114
 Self time:   0.000088

count  total (s)   self (s)
    2   0.000107   0.000081 	call s:_finish()
    2              0.000005 	unlet! s:complete

FUNCTION  186()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:76
Called 2 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    2              0.000095 	let self.cword = expand("<cword>")
    2              0.000012 	let self.cWORD = expand("<cWORD>")
    2              0.000011 	let self.cfile = expand("<cfile>")

FUNCTION  187()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:82
Called 2 times
Total time:   0.000144
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000140   0.000018 	call self.reset()
                            " 	let self.prefix_key = ""

FUNCTION  <SNR>108_new_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:36
Called 34552 times
Total time:   0.260481
 Self time:   0.260481

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
34552              0.098304   if a:cnt == 0
34552              0.069327     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:70
Called 164 times
Total time:   0.001379
 Self time:   0.001379

count  total (s)   self (s)
  164              0.001273     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:237
Called 2 times
Total time:   0.003810
 Self time:   0.000170

count  total (s)   self (s)
    2              0.000013   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    2              0.000003   endif
    2              0.000008   if !exists('b:git_dir')
    2   0.001776   0.000035     let dir = FugitiveExtractGitDir(a:path)
    2              0.000006     if dir !=# ''
    2              0.000009       let b:git_dir = dir
    2              0.000004     endif
    2              0.000003   endif
    2              0.000011   if exists('b:git_dir')
    2   0.001963   0.000064     return fugitive#Init()
                              endif

FUNCTION  <SNR>136_SetCompleteFunc()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:551
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000040   let &completefunc = 'youcompleteme#CompleteFunc'

FUNCTION  airline#extensions#tabline#buffers#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:47
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000015   let s:current_bufnr = -1

FUNCTION  <SNR>35_ShouldStripWhitespaceOnSave()
    Defined: ~/.vim/plugged/vim-better-whitespace/plugin/better-whitespace.vim:129
Called 9 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
                                " Guess from local whitespace enabled-ness and global whitespace setting
    9              0.000100     if !exists('b:strip_whitespace_on_save') && exists('b:better_whitespace_enabled')
    3              0.000033         let b:strip_whitespace_on_save = b:better_whitespace_enabled && g:strip_whitespace_on_save && &modifiable && (g:strip_max_file_size == 0 || g:strip_max_file_size >= line('$'))
    9              0.000013     endif
    9              0.000057     return get(b:, 'strip_whitespace_on_save', g:strip_whitespace_on_save)

FUNCTION  <SNR>199__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:21
Called 1 time
Total time:   0.002081
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.002078   0.000015 	let s:List = s:V.import("Data.List")

FUNCTION  RstFold#GetRstFold()
    Defined: /usr/share/vim/vim81/autoload/RstFold.vim:34
Called 132692 times
Total time:   0.700472
 Self time:   0.700472

count  total (s)   self (s)
132692              0.380969   if !g:rst_fold_enabled
132692              0.226306     return
                              endif
                            
                              if !has_key(b:, 'RstFoldCache')
                                call s:CacheRstFold()
                              endif
                              if has_key(b:RstFoldCache, v:lnum)
                                return '>' . b:RstFoldCache[v:lnum]
                              else
                                return '='
                              endif

FUNCTION  <SNR>283_uniq_nr()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Window.vim:61
Called 357 times
Total time:   0.012575
 Self time:   0.012535

count  total (s)   self (s)
  357              0.002405 	let winnr = get(a:, 1, winnr())
  357              0.002161 	let tabnr = get(a:, 2, tabpagenr())
  357              0.003563 	let uniq_nr = get(gettabwinvar(tabnr, winnr, ""), s:prefix . "_gift_uniq_winnr", -1)
  357              0.000849 	if uniq_nr == -1
    1   0.000051   0.000011 		let uniq_nr = s:numbering(winnr, tabnr)
  357              0.000501 	endif
  357              0.000819 	return uniq_nr

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Exit#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim:5
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000012     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  526()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/cli.vim:100
Called 14 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   14              0.000084   return copy(self._keymap)

FUNCTION  527()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/extend.vim:26
Called 3 times
Total time:   0.012183
 Self time:   0.000286

count  total (s)   self (s)
    3   0.000044   0.000028   let is_cancel = self.exit_code()
    3              0.000033   if is_cancel
                                return s:U.is_visual(self._mode) ? '\<ESC>gv' : "\<ESC>"
    3              0.000005   else
    3   0.011213   0.000031     call self._call_execute_event()
    3   0.000341   0.000080     let [pattern, offset] = incsearch#parse_pattern(a:input, self._base_key)
                                " TODO: implement convert input method
    3   0.000204   0.000055     let p = self._combine_pattern(self._convert(pattern), offset)
    3   0.000318   0.000029     return self._build_search_cmd(p)
                              endif

FUNCTION  192()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:35
Called 8 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    8              0.000040 	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
    8              0.000011 	endif

FUNCTION  194()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:49
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000008 	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
    2              0.000002 	endif

FUNCTION  <SNR>123_TempReadPost()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2121
Called 1 time
Total time:   0.000080
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000049   0.000012   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
    1              0.000001   endif
    1              0.000002   return ''

FUNCTION  199()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:31
Called 8 times
Total time:   0.000212
 Self time:   0.000131

count  total (s)   self (s)
    8   0.000171   0.000090 	if self.is_no_insert(a:cmdline.char())
                            		call a:cmdline.setchar("", 0)
    8              0.000009 	endif

FUNCTION  signature#mark#GetList()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/mark.vim:281
Called 30 times
Total time:   0.089794
 Self time:   0.089794

count  total (s)   self (s)
                              " Arguments: mode    = 'used'     : Returns list of [ [used marks, line no., buf no.] ]
                              "                      'free'     : Returns list of [ free marks ]
                              "            scope   = 'buf_curr' : Limits scope to current buffer i.e used/free marks in current buffer
                              "                      'buf_all'  : Set scope to all buffers i.e used/free marks from all buffers
                              "            [type]  = 'global'   : Return only global marks
                            
   30              0.000176   let l:marks_list = []
   30              0.000192   let l:line_tot = line('$')
   30              0.000252   let l:buf_curr = bufnr('%')
   30              0.000191   let l:type     = (a:0 ? a:1 : "")
                            
                              " Respect order specified in g:SignatureIncludeMarks
 1590              0.008384   for i in split(b:SignatureIncludeMarks, '\zs')
 1560              0.011561     if (i =~# "[A-Z]")
  780              0.008610       let [ l:buf, l:line, l:col, l:off ] = getpos( "'" . i )
  780              0.008460       let l:marks_list = add(l:marks_list, [i, l:line, l:buf])
  780              0.003949     elseif (l:type !=? "global")
  780              0.010004       let l:marks_list = add(l:marks_list, [i, line("'" .i), l:buf_curr])
 1560              0.003152     endif
 1590              0.003026   endfor
                            
   30              0.000139   if (a:mode ==? 'used')
   15              0.000062     if (a:scope ==? 'buf_curr')
   15              0.004634       call filter( l:marks_list, '(v:val[2] == l:buf_curr) && (v:val[1] > 0)' )
                                else
                                  call filter( l:marks_list, 'v:val[1] > 0' )
   15              0.000027     endif
   15              0.000030   else
   15              0.000061     if (a:scope ==? 'buf_all')
                                  call filter( l:marks_list, 'v:val[1] == 0' )
   15              0.000026     else
   15              0.003707       call filter( l:marks_list, '(v:val[1] == 0) || (v:val[2] != l:buf_curr)' )
   15              0.000036     endif
   15              0.002205     call map( l:marks_list, 'v:val[0]' )
   30              0.000065   endif
                            
   30              0.000127   return l:marks_list

FUNCTION  <SNR>227__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Buffer.vim:19
Called 1 time
Total time:   0.004370
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000002   let s:V = a:V
    1   0.001702   0.000012   let s:P = s:V.import('Prelude')
    1   0.002664   0.000010   let s:G = s:V.import('Vim.Guard')

FUNCTION  <SNR>236__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline.vim:15
Called 1 time
Total time:   0.013165
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.013072   0.000013 	let s:Maker = s:V.import("Over.Commandline.Maker")
    1   0.000090   0.000014 	let s:Modules = s:V.import("Over.Commandline.Modules")

FUNCTION  <SNR>35_HighlightEOLWhitespaceExceptCurrentLine()
    Defined: ~/.vim/plugged/vim-better-whitespace/plugin/better-whitespace.vim:171
Called 11742 times
Total time:   1.748218
 Self time:   1.265765

count  total (s)   self (s)
11742   0.315434   0.188826         call <SID>ClearHighlighting()
11742   0.527463   0.171618         if <SID>ShouldHighlight()
11742              0.861019             let s:match_id = matchadd('ExtraWhitespace',   '\%<' . line('.') .  'l' . s:eol_whitespace_pattern . '\|\%>' . line('.') .  'l' . s:eol_whitespace_pattern, 10, get(s:, 'match_id', -1))
11742              0.023707         endif

FUNCTION  <SNR>245__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules.vim:15
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V

FUNCTION  <SNR>122_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 25 times
Total time:   0.023938
 Self time:   0.004178

count  total (s)   self (s)
  132              0.000482   for key in a:keys
  107              0.000928     if (key == 'warning' || key == 'error') && !a:context.active
   14              0.000022       continue
   93              0.000135     endif
   93   0.021555   0.001795     call s:add_section(a:builder, a:context, key)
  118              0.000209   endfor

FUNCTION  AutoPairsInit()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:471
Called 3 times
Total time:   0.008409
 Self time:   0.006082

count  total (s)   self (s)
    3              0.000014   let b:autopairs_loaded  = 1
    3              0.000016   if !exists('b:autopairs_enabled')
    3              0.000011     let b:autopairs_enabled = 1
    3              0.000004   end
                            
    3              0.000012   if !exists('b:AutoPairs')
    3   0.000405   0.000042     let b:AutoPairs = AutoPairsDefaultPairs()
    3              0.000005   end
                            
    3              0.000021   if !exists('b:AutoPairsMoveCharacter')
    3              0.000017     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    3              0.000003   end
                            
    3              0.000011   let b:autopairs_return_pos = 0
    3              0.000012   let b:autopairs_saved_pair = [0, 0]
    3              0.000009   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   30              0.000093   for [open, close] in items(b:AutoPairs)
   27              0.000135     let o = open[-1:-1]
   27              0.000090     let c = close[0]
   27              0.000122     let opt = {'mapclose': 1, 'multiline':1}
   27              0.000092     let opt['key'] = c
   27              0.000055     if o == c
   18              0.000053       let opt['multiline'] = 0
   27              0.000031     end
   27              0.000246     let m = matchlist(close, '\v(.*)//(.*)$')
   27              0.000094     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
   27              0.000031     end
   27   0.001434   0.000288     call AutoPairsMap(o)
   27              0.000098     if o != c && c != '' && opt['mapclose']
    9   0.000534   0.000077       call AutoPairsMap(c)
   27              0.000035     end
   27              0.000171     let b:AutoPairsList += [[open, close, opt]]
   30              0.000061   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    3   0.000808   0.000447   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   30              0.000050   for item in b:AutoPairsList
   27              0.000080     let [open, close, opt] = item
   27              0.000068     if open == "'" && open == close
    3              0.000011       let item[0] = '\v(^|\W)\zs'''
   27              0.000031     end
   30              0.000038   endfor
                            
                            
   27              0.000107   for key in split(b:AutoPairsMoveCharacter, '\s*')
   24              0.000261     let escaped_key = substitute(key, "'", "''", 'g')
   24              0.000821     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
   27              0.000041   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    3              0.000008   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    3              0.000105     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    3              0.000005   end
                            
    3              0.000026   if g:AutoPairsMapCh
    3              0.000092     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    3              0.000005   endif
                            
    3              0.000008   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    3              0.000009     let do_abbrev = ""
    3              0.000024     if v:version == 703 && has("patch489") || v:version > 703
    3              0.000010       let do_abbrev = "<C-]>"
    3              0.000003     endif
    3              0.000070     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    3              0.000004   end
                            
    3              0.000010   if g:AutoPairsShortcutFastWrap != ''
    3              0.000106     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    3              0.000005   end
                            
    3              0.000010   if g:AutoPairsShortcutBackInsert != ''
    3              0.000093     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    3              0.000004   end
                            
    3              0.000008   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    3              0.000064     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    3              0.000064     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    3              0.000005   end
                            
    3              0.000009   if g:AutoPairsShortcutJump != ''
    3              0.000082     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    3              0.000082     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    3              0.000006   end
                            
    3              0.000009   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    3              0.000004   end
                            

FUNCTION  ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:52
Called 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000007     redir => l:output
    1              0.000048         0verbose silent highlight SignColumn
    1              0.000005     redir end
                            
    1              0.000039     let l:highlight_syntax = join(split(l:output)[2:])
    1              0.000013     let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                            
    1              0.000004     if !empty(l:match)
                                    execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
    1              0.000004     elseif l:highlight_syntax isnot# 'cleared'
    1              0.000037         execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
    1              0.000002     endif

FUNCTION  EasyMotion#highlight#load()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:32
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                               "load

FUNCTION  vista#util#Blink()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:111
Called 1 time
Total time:   0.001552
 Self time:   0.001398

count  total (s)   self (s)
    1              0.000010   let s:blink = { 'ticks': 2 * a:times, 'delay': a:delay }
    1              0.000009   let s:hi_pos = get(a:000, 0, line('.'))
                            
    1              0.000010   if !exists('#VistaBlink')
    1              0.000005     augroup VistaBlink
    1              0.001281       autocmd!
    1              0.000018       autocmd BufWinEnter * call s:blink.clear()
    1              0.000003     augroup END
    1              0.000003   endif
                            
    1              0.000006   function! s:blink.tick(_) abort
                                let self.ticks -= 1
                                let active = self == s:blink && self.ticks > 0
                            
                                if !self.clear() && active && &hlsearch
                                  let w:vista_blink_id = matchaddpos('IncSearch', [s:hi_pos])
                                endif
                                if active
                                  call timer_start(self.delay, self.tick)
                                endif
                              endfunction
                            
    1              0.000003   function! s:blink.clear() abort
                                if exists('w:vista_blink_id')
                                  call matchdelete(w:vista_blink_id)
                                  unlet w:vista_blink_id
                                  return 1
                                endif
                              endfunction
                            
    1   0.000037   0.000012   call s:blink.clear()
    1   0.000138   0.000009   call s:blink.tick(0)
    1              0.000003   return ''

FUNCTION  <SNR>132_GetDefaultCmd()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:29
Called 1 time
Total time:   0.000195
 Self time:   0.000096

count  total (s)   self (s)
                              " Refer to tagbar
    1              0.000007   let common_opt = '--format=2 --excmd=pattern --fields=nksSaf --file-scope=yes --sort=no --append=no'
                            
                              " Do not pass --extras for C/CPP in order to let uctags handle the tags for anonymous
                              " entities correctly.
    1   0.000058   0.000014   if t:vista.source.filetype() !=# 'c' && t:vista.source.filetype() !=# 'cpp'
    1              0.000007     let common_opt .= ' --extras= '
    1              0.000002   endif
                            
    1              0.000003   if s:support_json_format
    1              0.000005     let fmt = '%s %s %s --output-format=json --fields=-PF -f- %s'
    1              0.000007     let s:TagParser = function('vista#parser#ctags#FromJSON')
                              else
                                let fmt = '%s %s %s -f- %s'
                                let s:TagParser = function('vista#parser#ctags#FromExtendedRaw')
    1              0.000001   endif
                            
    1   0.000084   0.000029   let language_specific_opt = s:GetLanguageSpecificOptition(&filetype)
    1              0.000009   let cmd = printf(fmt, s:ctags, common_opt, language_specific_opt, a:file)
                            
    1              0.000002   return cmd

FUNCTION  <SNR>241__compare()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/List.vim:107
Called 4110 times
Total time:   0.033198
 Self time:   0.033198

count  total (s)   self (s)
 4110              0.031286   return eval(s:expr)

FUNCTION  <SNR>127_on_stdout_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:76
Called 24 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
   24              0.000497   call add(self.stdoutbuffer, a:data)

FUNCTION  <SNR>266_capture()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:42
Called 3 times
Total time:   0.001249
 Self time:   0.000103

count  total (s)   self (s)
    3              0.000015 	let mode = get(a:, 1, "")
    3              0.000023 	let modes = split(mode, '\zs')
    3   0.001207   0.000061 	return join(map(modes, "s:_capture(v:val)"), "\n")

FUNCTION  <SNR>145_set_clean_jobs_variable()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:80
Called 50 times
Total time:   0.003900
 Self time:   0.003900

count  total (s)   self (s)
   50              0.002088   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
   50              0.000113   endif
   50              0.001097   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  AutoPairsReturn()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:384
Called 152 times
Total time:   0.127041
 Self time:   0.112229

count  total (s)   self (s)
  152              0.001250   if b:autopairs_enabled == 0
                                return ''
  152              0.000319   end
  152              0.000814   let b:autopairs_return_pos = 0
  152              0.002539   let before = getline(line('.')-1)
  152   0.018563   0.003751   let [ig, ig, afterline] = s:getline()
  152              0.000774   let cmd = ''
 1520              0.009821   for [open, close, opt] in b:AutoPairsList
 1368              0.004525     if close == ''
                                  continue
 1368              0.002029     end
                            
 1368              0.019756     if before =~ '\V'.open.'\v\s*$' && afterline =~ '^\s*\V'.close
                                  let b:autopairs_return_pos = line('.')
                                  if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                    " Recenter before adding new line to avoid replacing line content
                                    let cmd = "zz"
                                  end
                            
                                  " If equalprg has been set, then avoid call =
                                  " https://github.com/jiangmiao/auto-pairs/issues/24
                                  if &equalprg != ''
                                    return "\<ESC>".cmd."O"
                                  endif
                            
                                  " conflict with javascript and coffee
                                  " javascript   need   indent new line
                                  " coffeescript forbid indent new line
                                  if &filetype == 'coffeescript' || &filetype == 'coffee'
                                    return "\<ESC>".cmd."k==o"
                                  else
                                    return "\<ESC>".cmd."=ko"
                                  endif
 1368              0.002205     end
 1520              0.002970   endfor
  152              0.000414   return ''

FUNCTION  <SNR>48_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:203
Called 29 times
Total time:   0.002495
 Self time:   0.000933

count  total (s)   self (s)
   29   0.002473   0.000911   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>194_GetChar()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:503
Called 1 time
Total time:   0.000104
 Self time:   0.000000

count  total (s)   self (s)
    1              0.000006     let mode = get(a:, 1, 0)
    1              0.000002     while 1
                                    " Workaround for https://github.com/osyo-manga/vital-over/issues/53
    1              0.000002         try
    1   0.000056   0.000000             let char = call('getchar', a:000)
                                    catch /^Vim:Interrupt$/
                                        let char = 3 " <C-c>
    1              0.000002         endtry
    1              0.000004         if char == 27 || char == 3
                                        " Escape or <C-c> key pressed
                                        redraw
                                        call s:Message('Cancelled')
                                        return ''
    1              0.000002         endif
                                    " Workaround for the <expr> mappings
    1              0.000007         if string(char) !=# "\x80\xfd`"
    1              0.000008             return mode == 1 ? !!char    : type(char) == type(0) ? nr2char(char) : char
                                    endif
                                endwhile

FUNCTION  <SNR>35_ShouldHighlight()
    Defined: ~/.vim/plugged/vim-better-whitespace/plugin/better-whitespace.vim:120
Called 12185 times
Total time:   0.374436
 Self time:   0.374436

count  total (s)   self (s)
                                " Guess from the filetype if a) not locally decided, b) globally enabled, c) there is enough information
12185              0.163455     if !exists('b:better_whitespace_enabled') && g:better_whitespace_enabled == 1 && !(empty(&buftype) && empty(&filetype))
    3              0.000061         let b:better_whitespace_enabled = &buftype != 'nofile' && index(g:better_whitespace_filetypes_blacklist, &ft) == -1
12185              0.022493     endif
12185              0.089516     return get(b:, 'better_whitespace_enabled', g:better_whitespace_enabled)

FUNCTION  vital#_incsearch#Vim#Buffer#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Buffer.vim:7
Called 1 time
Total time:   0.000170
 Self time:   0.000117

count  total (s)   self (s)
    1   0.000170   0.000117 return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>277_' . v:key)")

FUNCTION  <SNR>242_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:106
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000016 	let result = deepcopy(s:base)
    1              0.000002 	return result

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:95
Called 87 times
Total time:   0.128247
 Self time:   0.014875

count  total (s)   self (s)
   87              0.000626   if g:airline#init#vim_async
                                " Vim 8 with async support
   87   0.123911   0.010539     noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
   87              0.000150   endif

FUNCTION  <SNR>199__clamp()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:34
Called 8 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    8              0.000058 	return min([max([a:x, a:max]), a:min])

FUNCTION  <SNR>266_rhs_key_list()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:101
Called 3 times
Total time:   0.004506
 Self time:   0.000496

count  total (s)   self (s)
    3              0.000020 	let mode = get(a:, 1, "")
    3              0.000013 	let abbr = get(a:, 2, 0)
    3              0.000013 	let dict = get(a:, 3, 0)
                            	
    3              0.000008 	let result = []
    6              0.000053 	for m in split(mode, '\zs')
    3   0.004315   0.000305 		let result += map(s:parse_lhs_list(m), "s:_maparg(v:val, m, abbr, dict)")
    6              0.000011 	endfor
    3              0.000052 	return filter(result, "empty(v:val) == 0")

FUNCTION  <SNR>240__clamp()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:28
Called 14 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
   14              0.000101 	return min([max([a:x, a:max]), a:min])

FUNCTION  <SNR>204_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:35
Called 10 times
Total time:   0.011384
 Self time:   0.000288

count  total (s)   self (s)
   10   0.011138   0.000111 	let module = s:get(a:name)
   10   0.000237   0.000168 	return call(module.make, a:000, module)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:243
Called 541 times
Total time:  32.853456
 Self time:   4.345666

count  total (s)   self (s)
  541              0.002454   let bufnr = a:0 ? a:1 : ''
  541              0.004084   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
  541              0.012247   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
  541              0.002967   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
  541              0.002040   let airline_grouplist = []
  541              0.003642   let buffers_in_tabpage = sort(tabpagebuflist())
  541              0.002519   if exists("*uniq")
  541              0.002831     let buffers_in_tabpage = uniq(buffers_in_tabpage)
  541              0.000871   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
 1547              0.005305   for mode in reverse(mapped)
 1006              0.012512     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
 1001              0.006780       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
23593              0.085917       for kvp in items(dict)
22592              0.097885         let mode_colors = kvp[1]
22592              0.079099         let name = kvp[0]
22592              0.116336         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    3              0.000045           let name = 'airline_c'.bufnr
22592              0.033555         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
22592              0.259502         if name =~# 'airline_c\d\+'
 1987              0.035715           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
 1987              0.011508           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
  991              0.002004             continue
  996              0.001405           endif
20605              0.184091         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
13899              0.024802           continue
 7702              0.010829         endif
 7702   0.284641   0.135954         if s:group_not_done(airline_grouplist, name.suffix)
 5406   3.049343   0.105513           call airline#highlighter#exec(name.suffix, mode_colors)
 7702              0.011884         endif
                            
23106              0.080307         for accent in keys(s:accents)
15404              0.072272           if !has_key(p.accents, accent)
                                        continue
15404              0.025422           endif
15404              0.091031           let colors = copy(mode_colors)
15404              0.078848           if p.accents[accent][0] != ''
 7702              0.040898             let colors[0] = p.accents[accent][0]
15404              0.023845           endif
15404              0.061731           if p.accents[accent][2] != ''
 7702              0.036729             let colors[2] = p.accents[accent][2]
15404              0.022289           endif
15404              0.055529           if len(colors) >= 5
15324              0.109410             let colors[4] = get(p.accents[accent], 4, '')
   80              0.000110           else
   80              0.000650             call add(colors, get(p.accents[accent], 4, ''))
15404              0.022702           endif
15404   0.591899   0.305350           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
10812   5.972952   0.212804             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
15404              0.023601           endif
23106              0.038657         endfor
 8703              0.016157       endfor
                            
 1001              0.004760       if empty(s:separators)
                                    " nothing to be done
                                    continue
 1001              0.001452       endif
                                  " TODO: optimize this
17004              0.065539       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
16003  19.799895   0.431319         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
17004              0.030819       endfor
 1006              0.001494     endif
 1547              0.004300   endfor

FUNCTION  vital#_incsearch#Prelude#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Prelude.vim:7
Called 1 time
Total time:   0.000555
 Self time:   0.000389

count  total (s)   self (s)
    1   0.000554   0.000388 return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''}, "vital#_incsearch#function('<SNR>279_' . v:key)")

FUNCTION  114()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:308
Called 2 times
Total time:   0.000144
 Self time:   0.000138

count  total (s)   self (s)
    2              0.000012 	if exists("self.variables.old_guicursor")
    2   0.000041   0.000039 		set guicursor&
    2   0.000028   0.000027 		let &guicursor = self.variables.old_guicursor
    2              0.000005 		unlet self.variables.old_guicursor
    2              0.000002 	endif
                            
    2              0.000009 	if exists("self.variables.old_t_ve")
    2   0.000036   0.000033 		let &t_ve = self.variables.old_t_ve
    2              0.000004 		unlet self.variables.old_t_ve
    2              0.000002 	endif

FUNCTION  signature#utils#Set()
    Defined: ~/.vim/plugged/vim-signature/autoload/signature/utils.vim:4
Called 120 times
Total time:   0.004431
 Self time:   0.004431

count  total (s)   self (s)
                              " Description: Assign value to var if var is unset or if an optional 3rd arg is provided to force
                            
  120              0.001169   if (!exists(a:var) || a:0 && a:1)
   24              0.000081     if type(a:value)
    9              0.000120       execute 'let' a:var '=' string(a:value)
   15              0.000024     else
   15              0.000138       execute 'let' a:var '=' a:value
   24              0.000031     endif
  120              0.000213   endif
  120              0.000447   return a:var

FUNCTION  <SNR>212_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim:52
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return deepcopy(s:module)

FUNCTION  vital#_easymotion#Over#Commandline#Modules#DrawCommandline#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:5
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000017     return map({'suffix': '', 'make': ''},  'function("s:" . v:key)')

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 17054 times
Total time:   1.186819
 Self time:   1.186819

count  total (s)   self (s)
17054              0.143146   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
17054              0.070380   let bomb     = &l:bomb ? '[BOM]' : ''
17054              0.439002   let ff       = strlen(&ff) ? '['.&ff.']' : ''
17054              0.226546   if expected is# &fenc.bomb.ff
                                return ''
17054              0.027360   else
17054              0.205055     return &fenc.bomb.ff
                              endif

FUNCTION  vista#source#GotoWin()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/source.vim:77
Called 1 time
Total time:   0.000132
 Self time:   0.000124

count  total (s)   self (s)
    1              0.000003   if s:use_winid
    1   0.000019   0.000011     let winid = t:vista.source.winid()
    1              0.000003     if winid != -1
    1              0.000037       noautocmd call win_gotoid(winid)
                                else
                                  return vista#error#('Cannot find the source window id')
    1              0.000002     endif
                              else
                                " t:vista.source.winnr is not always correct.
                                let winnr = t:vista.source.winnr()
                                if winnr != -1
                                  noautocmd execute winnr.'wincmd w'
                                else
                                  return vista#error#('Cannot find the target window')
                                endif
    1              0.000002   endif
                              " Floating window relys on BufEnter event to be closed automatically.
    1              0.000013   if exists('#VistaFloatingWin')
                                doautocmd BufEnter VistaFloatingWin
    1              0.000002   endif

FUNCTION  388()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:23
Called 2248 times
Total time:   0.007646
 Self time:   0.007646

count  total (s)   self (s)
 2248              0.006766 		return a:val.slot.module

FUNCTION  <SNR>46_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:146
Called 17056 times
Total time:   0.376429
 Self time:   0.376429

count  total (s)   self (s)
17056              0.063615   let dir = a:path
17056              0.152746   if dir =~# '/\.git$'
17054              0.140273     return len(dir) ==# 5 ? '/' : dir[0:-6]
    2              0.000004   elseif dir ==# ''
    2              0.000004     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:79
Called 100 times
Total time:   0.003581
 Self time:   0.003318

count  total (s)   self (s)
  100              0.002164   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   76              0.000256     return a:arg
   24   0.000558   0.000295   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   24              0.000065   else
   24              0.000146     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>235__import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:158
Called 50 times
Total time:   0.128711
 Self time:   0.013657

count  total (s)   self (s)
   50              0.000230   if has_key(s:loaded, a:name)
   10              0.000109     return copy(s:loaded[a:name])
   40              0.000051   endif
   40   0.041250   0.000561   let module = self._get_module(a:name)
   40              0.000194   if has_key(module, '_vital_created')
    2   0.000088   0.000041     call module._vital_created(module)
   40              0.000062   endif
   40              0.001912   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
   40              0.000228   let s:loaded[a:name] = export_module
   40              0.000184   if has_key(module, '_vital_loaded')
   20              0.000050     try
   20   0.002020   0.001395       call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
   20              0.000031     endtry
   40              0.000049   endif
   40              0.000306   return copy(s:loaded[a:name])

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:124
Called 17064 times
Total time:   0.884701
 Self time:   0.884701

count  total (s)   self (s)
17064              0.296152   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
17064              0.560000   return match(a:name, pat) > -1

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 17283 times
Total time:   1.577949
 Self time:   0.693935

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
17283   1.258711   0.374697   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
  229              0.000672     return ''
17054              0.027687   endif
17054              0.076469   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
17054              0.025941   else
17054              0.066336     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>208_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim:34
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  <SNR>146_RunIfExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:611
Called 2894 times
Total time:   0.851873
 Self time:   0.291841

count  total (s)   self (s)
 2894   0.071603   0.044527     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
 2894              0.004857     endif
                            
 2894   0.580717   0.047761     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
                                    let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
                                    call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
                                    endif
                            
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                    let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
                                    return s:RunJob(l:command, l:options)
 2894              0.004483     endif
                            
 2894              0.006788     return 0

FUNCTION  <SNR>235__get_module()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:184
Called 40 times
Total time:   0.040689
 Self time:   0.015329

count  total (s)   self (s)
   40   0.002981   0.001145   let funcname = s:_import_func_name(self.plugin_name(), a:name)
   40              0.000069   try
   40   0.037183   0.013659     return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117/
                                return s:_get_builtin_module(a:name)
   40              0.000091   endtry

FUNCTION  <SNR>136_OnCompleteDone()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:566
Called 3381 times
Total time:   3.138988
 Self time:   1.293450

count  total (s)   self (s)
 3381   0.542188   0.073769   if !s:AllowedToCompleteInCurrentBuffer()
                                return
 3381              0.004829   endif
                            
 3381              1.112684   exec s:python_command "ycm_state.OnCompleteDone()"
 3381   1.466026   0.088907   call s:UpdateSignatureHelp()

FUNCTION  462()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Coaster/Highlight.vim:113
Called 96 times
Total time:   0.014762
 Self time:   0.002632

count  total (s)   self (s)
   96   0.006228   0.001466 	let window = get(a:, 1, s:Gift.uniq_winnr())
   96   0.008471   0.001103 	return self.get_hl_id(a:name, window) != ""

FUNCTION  vista#executive#ctags#Execute()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:374
Called 1 time
Total time:   0.002538
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000500   0.000016   call vista#OnExecute(s:provider, function('s:AutoUpdate'))
    1   0.002036   0.000030   return s:Dispatch('s:Execute', a:bang, a:should_display)

FUNCTION  <SNR>109_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:15
Called 50 times
Total time:   0.151614
 Self time:   0.151614

count  total (s)   self (s)
   50              0.000705   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
   50              0.000141   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
   50              0.000190   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
   50              0.000079   else
   50              0.147942     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>216_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionExit.vim:30
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000005 	let result = deepcopy(s:module)
    1              0.000005 	let result.exit_code = get(a:, 1, 0)
    1              0.000002 	return result

FUNCTION  vista#sidebar#IsVisible()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/sidebar.vim:127
Called 2 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000134   return bufwinnr('__vista__') != -1

FUNCTION  <SNR>277__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Vim/Buffer.vim:17
Called 1 time
Total time:   0.006691
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002   let s:V = a:V
    1   0.006688   0.000008   let s:Guard = s:V.import('Vim.Guard')

FUNCTION  <SNR>157_Assemble()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:20
Called 2 times
Total time:   0.000201
 Self time:   0.000121

count  total (s)   self (s)
    2              0.000005   let line = a:line
                            
    2              0.000008   let kind = get(line, 'kind', '')
                            
    2              0.000005   if !empty(kind)
    2   0.000083   0.000026     let kind = vista#renderer#Decorate(kind)
    2              0.000003   endif
                            
    2   0.000087   0.000064   let row = vista#util#Join( repeat(' ', a:depth * 4), s:GetVisibility(line), get(line, 'name'), get(line, 'signature', ''), ' : '.kind, ':'.get(line, 'line', '') )
                            
    2              0.000004   return row

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:494
Called 17052 times
Total time:  14.847859
 Self time:   1.963135

count  total (s)   self (s)
17052              0.098782   let dir = a:0 > 1 ? a:2 : s:Dir()
17052              0.057202   if empty(dir)
                                return ''
17052              0.025218   endif
17052  13.161322   0.276598   let file = fugitive#Find('.git/HEAD', dir)
17052              0.404708   let ftime = getftime(file)
17052              0.051571   if ftime == -1
                                return ''
17052              0.159747   elseif ftime != get(s:head_cache, dir, [-1])[0]
   50              0.001704     let s:head_cache[dir] = [ftime, readfile(file)[0]]
17052              0.027485   endif
17052              0.095268   let head = s:head_cache[dir][1]
17052              0.155124   if head =~# '^ref: '
17052              0.399177     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  322()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:182
Called 14 times
Total time:   0.000247
 Self time:   0.000094

count  total (s)   self (s)
   14   0.000241   0.000088 	return self.line.backward()

FUNCTION  EasyMotion#helper#is_greater_coords()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:46
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
                                " [line_num, col_num] < [line_num, col_num]
                                "
                                " coords1 < coords2  : return 1
                                " coords1 > coords2  : return -1
                                " coords1 == coords2 : return 0
    2              0.000017     if a:coords1 == a:coords2 | return 0 | endif
                            
    2              0.000012     if a:coords1[0] < a:coords2[0]
    1              0.000001         return 1
    1              0.000004     elseif a:coords1[0] > a:coords2[0]
                                    return -1
    1              0.000001     endif
                            
                                " Same line
    1              0.000004     if a:coords1[1] < a:coords2[1]
    1              0.000002         return 1
                                elseif a:coords1[1] > a:coords2[1]
                                    return -1
                                endif

FUNCTION  <SNR>232_deepextend()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/util.vim:166
Called 3 times
Total time:   0.000714
 Self time:   0.000714

count  total (s)   self (s)
    3              0.000013   let expr2 = copy(a:expr2)
   33              0.000101   for [k, V] in items(a:expr1)
   30              0.000246     if (type(V) is type({}) || type(V) is type([])) && has_key(expr2, k)
                                  let a:expr1[k] = extend(a:expr1[k], expr2[k])
                                  unlet expr2[k]
   30              0.000047     endif
   30              0.000045     unlet V
   33              0.000044   endfor
    3              0.000013   return extend(a:expr1, expr2)

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:273
Called 2720 times
Total time:   0.037278
 Self time:   0.037278

count  total (s)   self (s)
 2720              0.018468   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
 2720              0.004217   endif

FUNCTION  <SNR>266_escape_special_key()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:60
Called 60 times
Total time:   0.001569
 Self time:   0.001569

count  total (s)   self (s)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
   60              0.000161 	if a:key ==# "<^?>"
   15              0.000036 		return "\<C-?>"
   45              0.000065 	endif
   45              0.001043 	execute 'let result = "' . substitute(escape(a:key, '\"'), '\(<.\{-}>\)', '\\\1', 'g') . '"'
   45              0.000098 	return result

FUNCTION  vital#_easymotion#Over#Input#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Input.vim:5
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000014     return map({'getchar': ''},  'function("s:" . v:key)')

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:20
Called 3 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)
    3              0.000016   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    3              0.000003   end
    3              0.000038   let r = copy(g:AutoPairs)
    3              0.000032   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
   12              0.000037   for [filetype, pairs] in items(allPairs)
    9              0.000023     if &filetype == filetype
                                  for [open, close] in items(pairs)
                                    let r[open] = close
                                  endfor
    9              0.000010     end
   12              0.000018   endfor
    3              0.000014   let b:autopairs_defaultpairs = r
    3              0.000007   return r

FUNCTION  <SNR>240_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:115
Called 3 times
Total time:   0.000201
 Self time:   0.000109

count  total (s)   self (s)
    3              0.000021 	let default = get(a:, 1, "")
    3              0.000044 	let result = deepcopy(s:base)
    3   0.000114   0.000022 	call result.set(default)
    3              0.000020 	return result

FUNCTION  <SNR>233_keymap()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/config.vim:92
Called 3 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    3              0.000036   return extend(copy(s:default_keymappings), g:incsearch_cli_key_mappings)

FUNCTION  ale#sign#ParsePattern()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:179
Called 50 times
Total time:   0.001194
 Self time:   0.001194

count  total (s)   self (s)
   50              0.000168     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " —Å—Ç—Ä–æ–∫–∞=1  id=1000001  –≥—Ä—É–ø–ø–∞=ale  –∏–º—è=ALEErrorSign
                                    " Ë°å=1  Ë≠òÂà•Â≠ê=1000001  „Ç∞„É´„Éº„Éó=ale  ÂêçÂâç=ALEWarningSign
                                    " l√≠nea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
   50              0.000282         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " —Å—Ç—Ä–æ–∫–∞=1  id=1000001  –∏–º—è=ALEErrorSign
                                    " Ë°å=1  Ë≠òÂà•Â≠ê=1000001  ÂêçÂâç=ALEWarningSign
                                    " l√≠nea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
   50              0.000069     endif
                            
   50              0.000131     return l:pattern

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 24 times
Total time:   0.037711
 Self time:   0.030058

count  total (s)   self (s)
   24              0.000138   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
   24              0.000400     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
   24   0.001020   0.000500     let modified_lines = s:handle_double_hunk(a:modified_lines)
   24   0.033696   0.026563     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
   24              0.000207     if exists('*sign_placelist')
   24              0.002065       call sign_placelist(signs)
   24              0.000051       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim:151
Called 16042 times
Total time:   4.215353
 Self time:   4.215353

count  total (s)   self (s)
16042              4.192367     py3 UltiSnips_Manager._track_change()

FUNCTION  <SNR>123_can_diffoff()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4464
Called 5 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    5              0.000054   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>142_get_separator_change()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:68
Called 214 times
Total time:   0.085186
 Self time:   0.006712

count  total (s)   self (s)
  214   0.085008   0.006534   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>101_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:56
Called 67585 times
Total time:   1.044039
 Self time:   1.044039

count  total (s)   self (s)
67585              0.429389   let opts=empty(a:opts) ? '' : join(a:opts, ',')
67585              0.565465   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:226
Called 1377 times
Total time:   0.035042
 Self time:   0.035042

count  total (s)   self (s)
 1377              0.005632     let l:min = 0
 1377              0.010155     let l:max = len(a:loclist) - 1
                            
 1377              0.004335     while 1
 1377              0.004941         if l:max < l:min
 1377              0.005393             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  vital#_easymotion#Over#String#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:5
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000037     return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  vital#_easymotion#Palette#Keymapping#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Keymapping.vim:5
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000054     return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>191_WinFindBuf()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:74
Called 100 times
Total time:   0.001281
 Self time:   0.001281

count  total (s)   self (s)
  100              0.001212     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>139_EchoScope()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:128
Called 1 time
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
    1              0.000003   if g:vista#renderer#enable_icon
    1              0.000247     echohl Function | echo ' '.a:scope.': ' | echohl NONE
                              else
                                echohl Function  | echo '['.a:scope.'] '  | echohl NONE
    1              0.000001   endif

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:283
Called 17054 times
Total time:   0.962906
 Self time:   0.962906

count  total (s)   self (s)
17054              0.069793   if empty(a:dir)
                                return ''
17054              0.025459   endif
17054              0.105183   if !has_key(s:commondirs, a:dir)
    1              0.000010     if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
    1              0.000015     elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
    1              0.000001     else
    1              0.000005       let s:commondirs[a:dir] = a:dir
    1              0.000002     endif
17054              0.024452   endif
17054              0.074304   return s:commondirs[a:dir]

FUNCTION  <SNR>231_search()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:193
Called 3 times
Total time:   0.013108
 Self time:   0.000415

count  total (s)   self (s)
    3   0.000885   0.000375   call incsearch#autocmd#auto_nohlsearch(1) " NOTE: `.` repeat doesn't handle this
    3   0.012219   0.000036   return a:cli._generate_command(a:input)

FUNCTION  <SNR>252_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Delete.vim:44
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  TogglePaste()
    Defined: ~/.vimrc:369
Called 2 times
Total time:   0.000064
 Self time:   0.000057

count  total (s)   self (s)
                                " check if paste is enabled
    2              0.000008     if &paste == '1'
                                    " disable paste
    1   0.000013   0.000010         set nopaste
    1              0.000002     else
                                    " enable paste
    1   0.000025   0.000021         set paste
    2              0.000004     endif

FUNCTION  <SNR>260_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:100
Called 1 time
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
    1              0.000007 	if has_key(s:cache_command, a:prefix)
                            		unlet! s:cache_command[a:prefix]
    1              0.000002 	endif
    1              0.000039 	execute "augroup " a:prefix . "-vital-over-commandline-doautocmd-dummy"
    1              0.000235 		autocmd!
    1              0.000003 	augroup END
                            
    1              0.000014 	let module = deepcopy(s:module)
    1              0.000005 	let module.prefix = a:prefix
    1              0.000003 	return module

FUNCTION  <SNR>188_is_row_bgns_blank()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/action.vim:147
Called 6 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                                " it's the col include last space in a line
    6              0.000067     return a:col <= matchend(a:line, '^\s*') + 1

FUNCTION  <SNR>120_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:158
Called 382 times
Total time:   0.758791
 Self time:   0.018131

count  total (s)   self (s)
  382   0.246833   0.007991   if airline#builder#should_change_group(a:prev_group, a:group)
  381   0.511577   0.009759     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
    1              0.000001   else
    1              0.000005     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Cancel#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim:5
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000018     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Paste#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000016     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>248_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim:168
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:668
Called 474 times
Total time:   2.144690
 Self time:   0.226071

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
  474   0.023853   0.010218     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
  474   0.069869   0.010447     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
  474   0.071483   0.015853     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
  474   0.026539   0.010248     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
  474   0.024011   0.013098     silent doautocmd <nomodeline> User ALELintPre
                            
 3792              0.012631     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
 3318              0.015172         if !l:linter.lint_file || a:should_lint_file
 2894   1.675010   0.061823             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
 2894              0.004790             endif
  424              0.001061         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
  424              0.002612             let l:can_clear_results = 0
 3318              0.005354         endif
 3792              0.006802     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
  474              0.001781     if l:can_clear_results
   50   0.150452   0.001109         call ale#engine#SetResults(a:buffer, [])
  424              0.001292     elseif l:new_buffer
    1   0.000219   0.000021         call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
  474              0.000677     endif

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:470
Called 1377 times
Total time:   0.129297
 Self time:   0.094255

count  total (s)   self (s)
 1377              0.016349     let l:info = get(g:ale_buffer_info, a:buffer, {})
 1377              0.012024     let l:loclist = get(l:info, 'loclist', [])
 1377              0.009590     let l:pos = getpos('.')
 1377   0.072329   0.037287     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
 1377              0.009260     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
 1377              0.006135     return [l:info, l:loc]

FUNCTION  riv#todo#update()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/todo.vim:409
Called 51 times
Total time:   5.540382
 Self time:   0.008251

count  total (s)   self (s)
                                " update the todo cache with current file
   51              0.001187     let file = expand('%:p')
                                
                                " don't cache file in build path
   51   0.008443   0.001447     if riv#path#is_rel_to(riv#path#build_path(), file)
                                    return
   51              0.000075     endif
                            
   51              0.000092     try
   51   0.010253   0.000720         let f = riv#path#rel_to_root(file)
                                    let lines = s:file2lines(getline(1,line('$')), f)
                                    let dir = riv#path#root()
                                    let cache = dir .'.todo_cache'
                                    if !isdirectory(dir)
                                        call mkdir(dir,'p')
                                    endif
                                    if filereadable(cache)
                                        let c_lines = filter(readfile(cache), ' v:val!~escape(f,''\'')')
                                    else
                                        let c_lines = []
                                    endif
                                    call writefile(c_lines+lines , cache)
   51              0.001066     catch 
   51   5.516645   0.001043         call riv#debug("Update todo cache failed:". v:exception)
   51              0.000232         return -1
   51              0.000099     endtry

FUNCTION  <SNR>150_Render()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer.vim:71
Called 1 time
Total time:   0.002832
 Self time:   0.000502

count  total (s)   self (s)
    1              0.000003   if t:vista.provider ==# 'coc'
                                return vista#renderer#hir#Coc(a:data)
    1              0.000004   elseif t:vista.provider ==# 'ctags' && g:vista#renderer#ctags ==# 'default'
    1   0.002821   0.000491     return vista#renderer#default#Render()
                              else
                                " The kind renderer applys to the LSP provider.
                                return vista#renderer#kind#Render(a:data)
                              endif

FUNCTION  vital#incsearch#new()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:24
Called 20 times
Total time:   0.000622
 Self time:   0.000272

count  total (s)   self (s)
   20   0.000607   0.000257   return s:new(s:plugin_name)

FUNCTION  vital#_incsearch#Over#Commandline#Modules#BufferComplete#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/BufferComplete.vim:7
Called 1 time
Total time:   0.000028
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000028   0.000021 return map({'make': ''}, "vital#_incsearch#function('<SNR>248_' . v:key)")

FUNCTION  riv#ptn#match_object()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:34
Called 2913 times
Total time:   1.478109
 Self time:   1.478109

count  total (s)   self (s)
                                " return a python like match object
                                " @param: string, pattern,  [start]
                                " @return object { start,end, groups, str}
                            
 2913              0.012788     let start = a:0 ? a:1 : 0
 2913              0.008558     let s = {}
                            
 2913              1.385362     let idx = match(a:str,a:ptn,start)
 2913              0.012115     if idx == -1
 2679              0.007814         return s
  234              0.000403     endif
                            
  234              0.001193     let s.start  = idx
  234              0.033816     let s.groups = matchlist(a:str,a:ptn,start)
  234              0.001675     let s.str    = s.groups[0]
  234              0.001685     let s.end    = s.start + len(s.str)
  234              0.000598     return s

FUNCTION  <SNR>235__function()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:11
Called 9 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    9              0.000074     return function(a:fstr)

FUNCTION  riv#todo#col_item()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/todo.vim:38
Called 1443 times
Total time:   0.372318
 Self time:   0.104144

count  total (s)   self (s)
                                " return [is_in, bgn , end, obj]
                                " bgn end is index_1
                                
                                " is_in : 0  not in
                                " is_in : 1  in list
                                " is_in : 2  in keyword/todo group
                                " is_in : 3  in piority
                                " is_in : 4  in begin datestamp
                                " is_in : 5  in end datestamp 
                                
 1443   0.287785   0.020016     let obj = riv#todo#obj(a:line)
 1443              0.004890     if empty(obj)
 1248              0.005957         return [0, 0, 0, {}]
  195              0.000352     endif
                            
  195              0.000477     let end = 0
  195              0.000442     let i = 0
 1045              0.003892     for group in obj.groups[1:5]
  875              0.004046         let bgn = end + 1
  875              0.003880         let len = len(group)
  875              0.003808         let end = bgn + len - 1
  875              0.002596         let i += 1
  875              0.003405         if bgn <= a:col && a:col <= end
   25   0.000865   0.000460             let fix_end = bgn + len(riv#ptn#strip(group)) - 1
   25              0.000097             if bgn <= a:col && a:col <= fix_end
   23              0.000048                 if i == 5
                                                " The td_tms_end have a preceding '~ ' 
                                                let fix_bgn = bgn + 2
                                                if a:col < fix_bgn
                                                    return [0,0,0,obj]
                                                else
                                                    return [i, fix_bgn, fix_end, obj]
                                                endif
   23              0.000031                 endif
   23              0.000087                 return [i, bgn, fix_end, obj]
    2              0.000003             endif
    2              0.000005             break
  850              0.001245         endif
 1022              0.002041     endfor
                            
  172              0.000593     return [0,0,0,obj]
                            

FUNCTION  <SNR>268_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/IgnoreRegexpBackwardWord.vim:42
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	return deepcopy(s:module)

FUNCTION  incsearch#magic()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:477
Called 36 times
Total time:   0.000376
 Self time:   0.000376

count  total (s)   self (s)
   36              0.000143   let m = g:incsearch#magic
   36              0.000207   return (len(m) == 2 && m =~# '\\[mMvV]' ? m : '')

FUNCTION  <SNR>108_airline_ale_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:7
Called 34552 times
Total time:   0.163393
 Self time:   0.163393

count  total (s)   self (s)
34552              0.141196   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>273_move_cursor()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:239
Called 15 times
Total time:   0.013230
 Self time:   0.003432

count  total (s)   self (s)
   15              0.000084   let offset = get(a:, 1, '')
   15              0.000045   if a:cli._flag ==# 'n' " skip if stay mode
                                return
   15              0.000020   endif
   15              0.001405   call winrestview(a:cli._w)
                              " pseud-move cursor position: this is restored afterward if called by
                              " <expr> mappings
   15              0.000040   if a:cli._is_expr
                                for _ in range(a:cli._vcount1)
                                  " NOTE: This cannot handle {offset} for cursor position
                                  call search(a:pattern, a:cli._flag)
                                endfor
   15              0.000022   else
                                " More precise cursor position while searching
                                " Caveat:
                                "   This block contains `normal`, please make sure <expr> mappings
                                "   doesn't reach this block
   15   0.000362   0.000234     let is_visual_mode = s:U.is_visual(mode(1))
   15   0.005153   0.000661     let cmd = incsearch#with_ignore_foldopen(   s:U.dictfunction(a:cli._build_search_cmd, a:cli),   a:cli._combine_pattern(a:pattern, offset), 'n')
                                " NOTE:
                                " :silent!
                                "   Shut up errors! because this is just for the cursor emulation
                                "   while searching
   15   0.005479   0.000301     silent! call incsearch#execute_search(cmd)
   15              0.000058     if is_visual_mode
                                  let w = winsaveview()
                                  normal! gv
                                  call winrestview(w)
                                  call incsearch#highlight#emulate_visual_highlight()
   15              0.000028     endif
   15              0.000019   endif

FUNCTION  402()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:35
Called 14 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
   14              0.000039 	return self.value

FUNCTION  vista#cursor#ShowDetail()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:442
Called 2 times
Total time:   0.002178
 Self time:   0.000350

count  total (s)   self (s)
    2              0.000045   let cur_line = getline('.')
    2              0.000011   if empty(cur_line)
                                return
    2              0.000005   endif
                            
                              " scope line
    2              0.000020   if cur_line[-1:] ==# ']'
                                let splitted = split(cur_line)
                                " Join the scope parts in case of they contains spaces, e.g., structure names
                                let scope = join(splitted[1:-2], ' ')
                                let cnt = matchstr(splitted[-1], '\d\+')
                                call s:EchoScope(scope)
                                echohl Keyword | echon cnt | echohl NONE
                                return
    2              0.000004   endif
                            
    2              0.000013   if foldclosed('.') != -1
                                if !s:has_floating_win && !s:has_popup
                                  return
                                endif
                                call s:ShowFoldedDetail()
                                return
    2              0.000003   endif
                            
    2   0.001876   0.000048   call s:ShowDetail()

FUNCTION  <SNR>253__as_echon()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/DrawCommandline.vim:77
Called 42 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
   42              0.000311 	return "echon " . strtrans(string(a:str))

FUNCTION  <SNR>100_wrap_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:9
Called 2 times
Total time:   0.000076
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000010   if exists('a:part.accent')
    2   0.000048   0.000036     call airline#highlighter#add_accent(a:part.accent)
    2              0.000015     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  <SNR>136_OnCompleteChanged()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:576
Called 6376 times
Total time:   4.061489
 Self time:   0.300994

count  total (s)   self (s)
 6376   1.053384   0.150844   if !s:AllowedToCompleteInCurrentBuffer()
                                return
 6376              0.009060   endif
                            
 6376   2.974492   0.116537   call s:UpdateSignatureHelp()

FUNCTION  vital#_easymotion#Over#Keymapping#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:5
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000034     return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  vista#GetExplicitExecutiveOrDefault()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:106
Called 1 time
Total time:   0.000085
 Self time:   0.000042

count  total (s)   self (s)
    1   0.000065   0.000022   let explicit_executive = s:GetExplicitExecutive()
                            
    1              0.000004   if explicit_executive isnot# v:null
                                let executive = explicit_executive
    1              0.000002   else
    1              0.000006     let executive = get(g:, 'vista_default_executive', 'ctags')
    1              0.000001   endif
                            
    1              0.000002   return executive

FUNCTION  UltiSnips#SnippetsInCurrentScope()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim:87
Called 3 times
Total time:   0.045723
 Self time:   0.045723

count  total (s)   self (s)
    3              0.000093     let g:current_ulti_dict = {}
    3              0.000024     let all = get(a:, 1, 0)
    3              0.000006     if all
    3              0.000083       let g:current_ulti_dict_info = {}
    3              0.000005     endif
    3              0.045485     py3 UltiSnips_Manager.snippets_in_current_scope(int(vim.eval("all")))
    3              0.000015     return g:current_ulti_dict

FUNCTION  121()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:369
Called 8 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    8              0.000064 	let self.variables.input_key_stack = a:stack
    8              0.000025 	return self.variables.input_key_stack

FUNCTION  <SNR>136_ShouldUseSignatureHelp()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:933
Called 25285650 times
Total time: 3417.285289
 Self time: 386.080071

count  total (s)   self (s)
25285650 3404.620025 373.414807   return s:Pyeval( 'vimsupport.VimSupportsPopupWindows()' )

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:114
Called 100 times
Total time:   0.006373
 Self time:   0.003076

count  total (s)   self (s)
  100   0.004618   0.001893   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
  100   0.001647   0.001075   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>132_TempnameBasedOnSourceBufname()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:216
Called 1 time
Total time:   0.000092
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000030   let tempname = sha256(fnamemodify(bufname(t:vista.source.bufnr), ':p'))
    1   0.000060   0.000018   return s:TryAppendExtension(tempname)

FUNCTION  140()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:56
Called 8 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    8              0.000062 	return self.col > 0 ? join(self.list[ : self.col-1], '') : ""

FUNCTION  airline#async#vim_vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:204
Called 87 times
Total time:   0.106915
 Self time:   0.106915

count  total (s)   self (s)
   87              0.000441     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
   87              0.000124     else
   87              0.000978       let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
   87              0.000131     endif
                            
   87              0.000614     let options = {'cfg': a:config, 'buf': '', 'file': a:file}
   87              0.000615     if has_key(s:untracked_jobs, a:file)
   37              0.001038       if job_status(get(s:untracked_jobs, a:file)) == 'run'
    5              0.000009         return
   32              0.000145       elseif has_key(s:untracked_jobs, a:file)
   32              0.000179         call remove(s:untracked_jobs, a:file)
   32              0.000068       endif
   82              0.000103     endif
   82              0.097596     let id = job_start(cmd, { 'err_io':   'out', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_untracked', options)})
   82              0.002092     let s:untracked_jobs[a:file] = id

FUNCTION  <SNR>198__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:21
Called 1 time
Total time:   0.009556
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.003237   0.000015 	let s:String  = s:V.import("Over.String")
    1   0.001387   0.000014 	let s:Signals = s:V.import("Over.Signals")
    1   0.000895   0.000010 	let s:Input = s:V.import("Over.Input")
    1   0.001022   0.000013 	let s:Keymapping = s:V.import("Over.Keymapping")
    1   0.000912   0.000011 	let s:Module = s:V.import("Over.Commandline.Modules")
    1   0.000038   0.000019 	let s:base.variables.modules = s:Signals.make()
    1              0.000004 	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
                            
    1   0.002047   0.000011 	let s:Highlight = s:V.import("Palette.Highlight")

FUNCTION  AutoPairsTryInit()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 4 times
Total time:   0.008947
 Self time:   0.000538

count  total (s)   self (s)
    4              0.000024   if exists('b:autopairs_loaded')
    1              0.000002     return
    3              0.000004   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    3              0.000008   if g:AutoPairsMapCR
    3              0.000015     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    3              0.000121       let info = maparg('<CR>', 'i', 0, 1)
    3              0.000009       if empty(info)
    3              0.000007         let old_cr = '<CR>'
    3              0.000007         let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    3              0.000003       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    3              0.000004     end
                            
    3              0.000022     if old_cr !~ 'AutoPairsReturn'
    3              0.000005       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
    3              0.000004       end
                                  " Always silent mapping
    3              0.000091       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    3              0.000004     end
    3              0.000003   endif
    3   0.008446   0.000037   call AutoPairsInit()

FUNCTION  <SNR>273_on_char_pre()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch/over/modules/incsearch.vim:104
Called 15 times
Total time:   0.010316
 Self time:   0.004371

count  total (s)   self (s)
                              " NOTE:
                              " `:call a:cmdline.setchar('')` as soon as possible!
   15   0.002639   0.000219   let [raw_pattern, offset] = a:cmdline._parse_pattern()
   15   0.000604   0.000173   let pattern = a:cmdline._convert(raw_pattern)
                            
                              " Interactive :h last-pattern if pattern is empty
   15   0.001040   0.000279   if ( a:cmdline.is_input('<Over>(incsearch-next)') || a:cmdline.is_input('<Over>(incsearch-prev)') ) && empty(pattern)
                                call a:cmdline.setchar('')
                                " Use history instead of @/ to work with magic option and converter
                                call a:cmdline.setline(histget('/', -1) . (empty(offset) ? '' : a:cmdline._base_key) . offset)
                                " Just insert last-pattern and do not count up, but the incsearch-prev
                                " should move the cursor to reversed directly, so do not return if the
                                " command is prev
                                if a:cmdline.is_input('<Over>(incsearch-next)') | return | endif
   15              0.000020   endif
                            
   15   0.000486   0.000119   if a:cmdline.is_input('<Over>(incsearch-next)')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n' " exit stay mode
                                  let a:cmdline._flag = ''
                                else
                                  let a:cmdline._vcount1 += 1
                                endif
   15   0.000660   0.000122   elseif a:cmdline.is_input('<Over>(incsearch-prev)')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n' " exit stay mode
                                  let a:cmdline._flag = ''
                                endif
                                let a:cmdline._vcount1 -= 1
   15   0.001036   0.000334   elseif (a:cmdline.is_input('<Over>(incsearch-scroll-f)') &&   (a:cmdline._flag ==# '' || a:cmdline._flag ==# 'n')) ||   (a:cmdline.is_input('<Over>(incsearch-scroll-b)') && a:cmdline._flag ==# 'b')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n' | let a:cmdline._flag = '' | endif
                                let pos_expr = a:cmdline.is_input('<Over>(incsearch-scroll-f)') ? 'w$' : 'w0'
                                let to_col = a:cmdline.is_input('<Over>(incsearch-scroll-f)')          ? s:U.get_max_col(pos_expr) : 1
                                let [from, to] = [getpos('.')[1:2], [line(pos_expr), to_col]]
                                let cnt = s:U.count_pattern(pattern, from, to)
                                let a:cmdline._vcount1 += cnt
   15   0.001010   0.000284   elseif (a:cmdline.is_input('<Over>(incsearch-scroll-b)') &&   (a:cmdline._flag ==# '' || a:cmdline._flag ==# 'n')) ||   (a:cmdline.is_input('<Over>(incsearch-scroll-f)') && a:cmdline._flag ==# 'b')
                                call a:cmdline.setchar('')
                                if a:cmdline._flag ==# 'n'
                                  let a:cmdline._flag = ''
                                  let a:cmdline._vcount1 -= 1
                                endif
                                let pos_expr = a:cmdline.is_input('<Over>(incsearch-scroll-f)') ? 'w$' : 'w0'
                                let to_col = a:cmdline.is_input('<Over>(incsearch-scroll-f)')          ? s:U.get_max_col(pos_expr) : 1
                                let [from, to] = [getpos('.')[1:2], [line(pos_expr), to_col]]
                                let cnt = s:U.count_pattern(pattern, from, to)
                                let a:cmdline._vcount1 -= cnt
   15              0.000024   endif
                            
                              " Handle nowrapscan:
                              "   if you `:set nowrapscan`, you can't move to the reversed direction
   15              0.000187   if !&wrapscan && (    a:cmdline.is_input('<Over>(incsearch-next)') || a:cmdline.is_input('<Over>(incsearch-prev)') || a:cmdline.is_input('<Over>(incsearch-scroll-f)') || a:cmdline.is_input('<Over>(incsearch-scroll-b)') )
                                if a:cmdline._vcount1 < 1
                                  let a:cmdline._vcount1 = 1
                                else
                                  call a:cmdline.setchar('')
                                  let [from, to] = [[a:cmdline._w.lnum, a:cmdline._w.col + 1],       a:cmdline._flag !=# 'b'       ? [line('$'), s:U.get_max_col('$')]       : [1, 1]   ]
                                  let max_cnt = s:U.count_pattern(pattern, from, to, s:TRUE)
                                  let a:cmdline._vcount1 = min([max_cnt, a:cmdline._vcount1])
                                endif
   15              0.000019   endif
   15              0.000071   if &wrapscan && a:cmdline._vcount1 < 1
                                let a:cmdline._vcount1 += s:U.count_pattern(pattern)
   15              0.000018   endif

FUNCTION  <SNR>116_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:196
Called 6379 times
Total time:   3.858799
 Self time:   3.858799

count  total (s)   self (s)
 6379              0.057318   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
 6379              0.017590   if bidx_mode > 0
 6379              0.015265     if bidx_mode == 1
63790              0.186693       for i in range(1, 9)
57411              2.825211         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
63790              0.117338       endfor
                                else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
 6379              0.010353     endif
 6379              0.225285     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
 6379              0.231172     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
 6379              0.011465   endif

FUNCTION  <SNR>235_plugin_name()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:127
Called 40 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
   40              0.000141   return self._plugin_name

FUNCTION  <SNR>206_capture()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Message.vim:49
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000002   try
    1              0.000004     redir => out
    1              0.000039     silent execute a:command
    1              0.000003   finally
    1              0.000003     redir END
    1              0.000002   endtry
    1              0.000002   return out

FUNCTION  EasyMotion#highlight#add_pos_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:176
Called 2 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    2              0.000105     call add(s:h.ids[a:group], matchaddpos(a:group, [[a:line_num, a:col_num]], s:priorities[a:group]))

FUNCTION  vista#renderer#IconFor()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer.vim:55
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000004   if g:vista#renderer#enable_icon
    2              0.000018     return get(g:vista#renderer#icons, tolower(a:kind), g:vista#renderer#icons.default)
                              else
                                return ''
                              endif

FUNCTION  ale#statusline#Update()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:21
Called 51 times
Total time:   0.009046
 Self time:   0.008340

count  total (s)   self (s)
   51              0.000554     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
   51              0.000069     endif
                            
   51              0.000466     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
   51   0.001582   0.000876     let l:count = s:CreateCountDict()
   51              0.000303     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
   51              0.000250     let l:first_problems = {}
                            
   51              0.000188     for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
                                        let l:count.error += 1
                            
                                        if l:count.error == 1
                                            let l:first_problems.error = l:entry
                                        endif
                                    endif
   51              0.000150     endfor
                            
                                " Set keys for backwards compatibility.
   51              0.000375     let l:count[0] = l:count.error + l:count.style_error
   51              0.000352     let l:count[1] = l:count.total - l:count[0]
                            
   51              0.000409     let g:ale_buffer_info[a:buffer].count = l:count
   51              0.000355     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  airline#highlighter#add_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:225
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000012   let s:accents[a:accent] = 1

FUNCTION  <SNR>136_OnTextChangedInsertMode()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:773
Called 5594 times
Total time:  43.754740
 Self time:   2.008755

count  total (s)   self (s)
 5594   0.932262   0.144568   if !s:AllowedToCompleteInCurrentBuffer()
                                return
 5594              0.008388   endif
                            
 5594              0.019069   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
 5594              0.007812   endif
                            
 5594   2.689843   0.141960   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
 5594              0.043996   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
 5594              0.013395   endif
                            
 5594  13.883393   0.322859   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
 5321   2.811733   0.112463     call s:Complete()
 5321  14.005143   0.119070     call s:RequestCompletion()
                            
 5321   5.148627   0.243291     call s:UpdateSignatureHelp()
 5321   3.525838   0.166643     call s:RequestSignatureHelp()
 5594              0.009592   endif
                            
 5594              0.415328   exec s:python_command "ycm_state.OnCursorMoved()"
                            
 5594              0.037017   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
 5594              0.009737   endif

FUNCTION  FugitiveParse()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:71
Called 50 times
Total time:   0.002148
 Self time:   0.001480

count  total (s)   self (s)
   50   0.001419   0.000751   let path = s:Slash(a:0 ? a:1 : @%)
   50              0.000399   if path !~# '^fugitive:'
   50              0.000242     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:216
Called 24 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
   24              0.000591   return has('win64') || has('win32') || has('win16')

FUNCTION  vital#_incsearch#Over#Commandline#Modules#Cancel#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Cancel.vim:7
Called 1 time
Total time:   0.000029
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000028   0.000021 return map({'make': ''}, "vital#_incsearch#function('<SNR>249_' . v:key)")

FUNCTION  <SNR>244__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Keymapping.vim:16
Called 1 time
Total time:   0.000106
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004 	let s:V = a:V
    1   0.000102   0.000012 	let s:String  = s:V.import("Over.String")

FUNCTION  <SNR>136_StartMessagePoll()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:87
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000013   if s:pollers.receive_messages.id < 0
    2              0.000024     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    3              0.000006   endif

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:18
Called 17026 times
Total time:   0.897310
 Self time:   0.376525

count  total (s)   self (s)
17026   0.885683   0.364898   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>194_default_config()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:315
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000014     let c = copy(s:config)
    2              0.000008     let m = mode(1)
    2              0.000010     let c.inclusive = m ==# 'no' ? s:TRUE : s:FALSE
    2              0.000003     return c

FUNCTION  <SNR>280__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/Dict.vim:15
Called 1 time
Total time:   0.001494
 Self time:   0.000013

count  total (s)   self (s)
    1   0.001493   0.000012   let s:t = a:V.import('Vim.Type').types

FUNCTION  vital#_incsearch#Over#Input#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Input.vim:7
Called 1 time
Total time:   0.000029
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000028   0.000021 return map({'getchar': ''}, "vital#_incsearch#function('<SNR>243_' . v:key)")

FUNCTION  vital#_easymotion#Palette#Highlight#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:5
Called 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000052     return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  vital#_incsearch#Over#Commandline#Modules#Digraphs#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Digraphs.vim:7
Called 1 time
Total time:   0.000186
 Self time:   0.000135

count  total (s)   self (s)
    1   0.000186   0.000135 return map({'capture': '', '_vital_depends': '', 'digraph': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>251_' . v:key)")

FUNCTION  <SNR>148_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:22
Called 24 times
Total time:   0.002343
 Self time:   0.000524

count  total (s)   self (s)
   24   0.002306   0.000487   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>136_AllowedToCompleteInBuffer()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:475
Called 27018 times
Total time:   3.215415
 Self time:   2.909838

count  total (s)   self (s)
27018              0.317927   let buftype = getbufvar( a:buffer, '&buftype' )
                            
27018              0.172088   if has_key( s:buftype_blacklist, buftype )
  104              0.000549     return 0
26914              0.050848   endif
                            
26914              0.203456   let filetype = getbufvar( a:buffer, '&filetype' )
                            
26914   0.884850   0.579273   if empty( filetype ) || s:DisableOnLargeFile( a:buffer )
    2              0.000004     return 0
26912              0.042299   endif
                            
26912              0.435164   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, filetype )
26912              0.301231   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, filetype )
                            
26912              0.126843   let allowed = whitelist_allows && blacklist_allows
26912              0.057451   if allowed
26912              0.238827     let s:previous_allowed_buffer_number = bufnr( a:buffer )
26912              0.043298   endif
26912              0.068796   return allowed

FUNCTION  <SNR>194_Prompt()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:443
Called 1 time
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    1              0.000050     echohl Question
    1              0.000040     echo a:message . ': '
    1              0.000012     echohl None

FUNCTION  vital#_incsearch#Over#Commandline#Modules#NoInsert#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/NoInsert.vim:7
Called 1 time
Total time:   0.000048
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000046   0.000033 return map({'make_special_chars': '', 'make': ''}, "vital#_incsearch#function('<SNR>264_' . v:key)")

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:5
Called 1853 times
Total time:   0.015729
 Self time:   0.015729

count  total (s)   self (s)
 1853              0.013619     return call('mode', a:000)

FUNCTION  200()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:47
Called 8 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    8              0.000054 		return char2nr(a:char) == 128 || char2nr(a:char) < 27

FUNCTION  <SNR>157_GetVisibility()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:197
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000012   return has_key(a:line, 'access') ? get(s:visibility_icon, a:line.access, '?') : ''

FUNCTION  204()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 2 times
Total time:   0.000289
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000009 	let s:cmdline = a:cmdline
    2   0.000279   0.000037 	call s:doautocmd_user(self.prefix, self.prefix . 'Enter')

FUNCTION  205()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 2 times
Total time:   0.000344
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000009 	let s:cmdline = a:cmdline
    2   0.000334   0.000032 	call s:doautocmd_user(self.prefix, self.prefix . 'Leave')

FUNCTION  207()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 8 times
Total time:   0.001083
 Self time:   0.000175

count  total (s)   self (s)
    8              0.000031 	let s:cmdline = a:cmdline
    8   0.001048   0.000140 	call s:doautocmd_user(self.prefix, self.prefix . 'CharPre')

FUNCTION  208()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 8 times
Total time:   0.001145
 Self time:   0.000190

count  total (s)   self (s)
    8              0.000036 	let s:cmdline = a:cmdline
    8   0.001103   0.000148 	call s:doautocmd_user(self.prefix, self.prefix . 'Draw')

FUNCTION  209()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 8 times
Total time:   0.001583
 Self time:   0.000225

count  total (s)   self (s)
    8              0.000038 	let s:cmdline = a:cmdline
    8   0.001538   0.000180 	call s:doautocmd_user(self.prefix, self.prefix . 'DrawPre')

FUNCTION  EasyMotion#command_line#GetInput()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:170
Called 2 times
Total time:   1.035429
 Self time:   0.000353

count  total (s)   self (s)
    2              0.000009     let s:num_strokes = a:num_strokes
                            
    2   0.000126   0.000038     let s:prompt_base = s:getPromptMessage(a:num_strokes)
    2   0.000029   0.000019     call s:search.set_prompt(s:prompt_base)
                            
                                " Screen: cursor position, first and last line
    2              0.000012     let s:orig_pos = getpos('.')
    2              0.000063     let s:orig_line_start = getpos('w0')
    2              0.000010     let s:orig_line_end = getpos('w$')
    2              0.000011     let s:save_orig_pos = deepcopy(s:orig_pos)
                            
                                " Direction:
    2              0.000009     let s:direction = a:direction == 1 ? 'b' : ''
    2              0.000010     let s:save_direction = deepcopy(s:direction)
                            
    2   1.034981   0.000020     let input = s:search.get()
    2              0.000010     if input == '' && ! s:search.exit_code()
                                    return a:prev
    2   0.000051   0.000034     elseif s:search.exit_code() == 1 || s:search.exit_code() == -1
                                    call s:Cancell()
                                    return ''
    2              0.000002     else
    2              0.000070         return input
                                endif

FUNCTION  <SNR>68_LocalBrowse()
    Defined: /usr/share/vim/vim81/plugin/netrwPlugin.vim:102
Called 4 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    4              0.000020   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    4              0.000006   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    4              0.000028   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    4              0.000034   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    4              0.000004   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    4              0.000005   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  riv#ptn#exp_con_idt()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:581
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000021     return matchend(a:line, g:_riv_p.exp_mark)+1

FUNCTION  623()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 3 times
Total time:   0.000248
 Self time:   0.000123

count  total (s)   self (s)
    3              0.000014     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
    3              0.000004     endif
    3   0.000177   0.000052     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000010     if bufnum == bufnr('%')
    3              0.000016       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000003     endif
    3              0.000006     return group

FUNCTION  624()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 1 time
Total time:   0.000226
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000090   0.000008     let group = self.get_group(a:i)
    1   0.000085   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000005     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000002       let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
    1              0.000002     endif
                            
    1              0.000006     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
    1              0.000001     else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  EasyMotion#highlight#turn_off()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:231
Called 4 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
    4              0.000018     if type(a:hl) != type([])
                                    return
    4              0.000004     endif
    4              0.000153     execute 'highlight ' . a:hl[0] . ' NONE'

FUNCTION  <SNR>132_ApplyExtracted()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/executive/ctags.vim:122
Called 1 time
Total time:   0.192061
 Self time:   0.000077

count  total (s)   self (s)
                              " Update cache when new data comes.
    1              0.000004   let s:cache = get(s:, 'cache', {})
    1              0.000009   let s:cache[s:fpath] = s:data
    1              0.000012   let s:cache.ftime = getftime(s:fpath)
    1              0.000004   let s:cache.bufnr = bufnr('')
                            
    1   0.192004   0.000020   let [s:reload_only, s:should_display] = vista#renderer#LSPProcess(s:data, s:reload_only, s:should_display)
                            
    1              0.000003   if exists('s:id')
    1              0.000020     unlet s:id
    1              0.000002   endif

FUNCTION  628()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 1 time
Total time:   0.000260
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000009     let bufnum = get(self.buffers, a:i, -1)
    1   0.000117   0.000013     let group = self.get_group(a:i)
    1   0.000087   0.000009     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000005     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
    1              0.000001     endif
                            
    1              0.000006     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
    1              0.000001     else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  vista#statusline#Render()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/statusline.vim:11
Called 2 times
Total time:   0.000046
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000041   0.000026   if vista#statusline#ShouldDisable()
    2              0.000002     return
                              endif
                            
                              if has_key(t:vista, 'bufnr')
                                call setbufvar(t:vista.bufnr, '&statusline', vista#statusline#())
                              endif

FUNCTION  <SNR>139_GetTrailingLnum()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:524
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000027   return str2nr(matchstr(getline('.'), '\d\+$'))

FUNCTION  <SNR>95_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:117
Called 16 times
Total time:   0.001888
 Self time:   0.001888

count  total (s)   self (s)
   16              0.000075   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   16              0.000032   endfor
                            
   64              0.000197   for matchw in g:airline_exclude_filenames
   48              0.000806     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   48              0.000102     endif
   64              0.000104   endfor
                            
   16              0.000055   if g:airline_exclude_preview && &previewwindow
                                return 1
   16              0.000025   endif
                            
   16              0.000035   return 0

FUNCTION  <SNR>145_untracked_output()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:12
Called 82 times
Total time:   0.003920
 Self time:   0.003920

count  total (s)   self (s)
   82              0.001195   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
   82              0.000414   else
   82              0.000601     let a:dict.cfg.untracked[a:dict.file] = ''
   82              0.000130   endif

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:183
Called 50 times
Total time:   0.043074
 Self time:   0.002176

count  total (s)   self (s)
   50              0.000530     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
   50   0.041789   0.000891         call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
   50              0.000069     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:284
Called 2329 times
Total time:   0.062360
 Self time:   0.059628

count  total (s)   self (s)
 2329              0.005338     try
 2329   0.026097   0.023365         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
 2329              0.006934     endtry
                            
 2329              0.005045     return 0

FUNCTION  vista#util#BinarySearch()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:191
Called 1 time
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
    1              0.000007   let [array, target] = [a:array, a:target]
                            
    1              0.000002   let low = 0
    1              0.000006   let high = len(array) - 1
                            
    5              0.000011   while low <= high
    4              0.000012     let mid = (low + high) / 2
    4              0.000018     if array[mid][a:cmp_key] == target
                                  let found = array[mid]
                                  if !empty(a:ret_key)
                                    return get(found, a:ret_key, v:null)
                                  else
                                    return found
                                  endif
    4              0.000028     elseif array[mid][a:cmp_key] > target
                                  let high = mid - 1
    4              0.000005     else
    4              0.000011       let low = mid + 1
    4              0.000006     endif
    5              0.000006   endwhile
                            
    1              0.000002   if low == 0
                                return v:null
    1              0.000001   endif
                            
                              " If no exact match, prefer the previous nearest one.
    1              0.000007   if get(g:, 'vista_find_absolute_nearest_method_or_function', 0)
                                if abs(array[low][a:cmp_key] - target) < abs(array[low - 1][a:cmp_key] - target)
                                  let found = array[low]
                                else
                                  let found = array[low - 1]
                                endif
    1              0.000001   else
    1              0.000004     let found = array[low - 1]
    1              0.000002   endif
                            
    1              0.000003   if !empty(a:ret_key)
                                return get(found, a:ret_key, v:null)
    1              0.000001   else
    1              0.000002     return found
                              endif

FUNCTION  <SNR>48_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:189
Called 129 times
Total time:   0.005139
 Self time:   0.005139

count  total (s)   self (s)
  129              0.004233   let p = resolve(expand('#'.a:bufnr.':p'))
  129              0.000790   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  79()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:90
Called 26 times
Total time:   0.000474
 Self time:   0.000272

count  total (s)   self (s)
   26   0.000462   0.000260 	return self.line.str()

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 17056 times
Total time:   0.186532
 Self time:   0.186532

count  total (s)   self (s)
17056              0.172704   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  214()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:59
Called 8 times
Total time:   0.001573
 Self time:   0.000666

count  total (s)   self (s)
    8   0.000387   0.000062     if a:cmdline.is_input("<Over>(em-scroll-f)")
                                    call s:scroll(0)
                                    call a:cmdline.setchar('')
    8   0.000218   0.000060     elseif a:cmdline.is_input("<Over>(em-scroll-b)")
                                    call s:scroll(1)
                                    call a:cmdline.setchar('')
    8   0.000214   0.000053     elseif a:cmdline.is_input("<Over>(em-jumpback)")
                                    keepjumps call setpos('.', s:save_orig_pos)
                                    let s:orig_pos = s:save_orig_pos
                                    let s:orig_line_start = getpos('w0')
                                    let s:orig_line_end = getpos('w$')
                                    let s:direction = s:save_direction
                                    call a:cmdline.setchar('')
    8   0.000326   0.000063     elseif a:cmdline.is_input("<Over>(em-openallfold)")
                                    " TODO: better solution
                                    normal! zR
                                    call a:cmdline.setchar('')
    8              0.000011     endif

FUNCTION  215()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:84
Called 8 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    8              0.000066     return {       "\<CR>"   : {           "key" : "<Over>(exit)",           "noremap" : 1,           "lock" : 1,       },   }

FUNCTION  216()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:123
Called 2 times
Total time:   0.001533
 Self time:   0.000479

count  total (s)   self (s)
    2              0.000008     if s:num_strokes == -1
    2   0.000304   0.000040         call EasyMotion#highlight#delete_highlight()
    2   0.000768   0.000285         call EasyMotion#helper#VarReset('&scrolloff', 0)
    2              0.000009         if g:EasyMotion_do_shade
    2   0.000327   0.000058             call EasyMotion#highlight#add_highlight('\_.*', g:EasyMotion_hl_group_shade)
    2              0.000006         endif
    2              0.000002     endif
    2              0.000009     if g:EasyMotion_cursor_highlight
    2   0.000086   0.000048         call EasyMotion#highlight#add_highlight('\%#', g:EasyMotion_hl_inc_cursor)
    2              0.000003     endif

FUNCTION  217()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:137
Called 2 times
Total time:   0.000395
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000006     if s:num_strokes == -1
    2   0.000139   0.000035         call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
    2              0.000004         if g:EasyMotion_do_shade
    2   0.000119   0.000040             call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_group_shade)
    2              0.000003         endif
    2              0.000002     endif
    2              0.000005     if g:EasyMotion_cursor_highlight
    2   0.000109   0.000033         call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_cursor)
    2              0.000002     endif

FUNCTION  218()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:148
Called 8 times
Total time:   0.003306
 Self time:   0.000711

count  total (s)   self (s)
    8              0.000028     if s:num_strokes == -1
    8   0.000201   0.000055         let re = s:search.getline()
    8   0.000377   0.000135         if EasyMotion#helper#should_case_sensitive(re, 1)
    8              0.000020             let case_flag = '\c'
                                    else
                                        let case_flag = '\C'
    8              0.000008         endif
    8              0.000029         let re .= case_flag
    8              0.000021         if g:EasyMotion_inc_highlight
    8   0.001059   0.000125             call s:inc_highlight(re)
    8              0.000008         endif
    8              0.000024         if g:EasyMotion_off_screen_search
    8   0.001413   0.000140             call s:off_screen_search(re)
    8              0.000011         endif
                                elseif s:search.line.length() >=  s:num_strokes
                                    call s:search.exit()
    8              0.000011     endif

FUNCTION  fugitive#Init()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:6025
Called 2 times
Total time:   0.001899
 Self time:   0.000233

count  total (s)   self (s)
    2              0.000024   if exists('#User#FugitiveBoot')
                                exe s:DoAutocmd('User FugitiveBoot')
    2              0.000002   endif
    2   0.000143   0.000022   let dir = s:Dir()
    2              0.000048   if &tags !~# '\.git' && @% !~# '\.git' && !exists('s:tags_warning')
    2   0.001510   0.000029     let actualdir = fugitive#Find('.git/', dir)
    2              0.000026     if filereadable(actualdir . 'tags')
                                  let s:tags_warning = 1
                                  echohl WarningMsg
                                  echo "Fugitive .git/tags support removed in favor of `:set tags^=./.git/tags;`"
                                  echohl NONE
    2              0.000002     endif
    2              0.000004   endif
    2   0.000109   0.000045   exe s:DoAutocmd('User Fugitive')

FUNCTION  <SNR>108_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:64
Called 34552 times
Total time:   1.350871
 Self time:   1.090390

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
34552              0.253354   if exists("*ale#statusline#FirstProblem")
34552   1.049986   0.789505     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>120_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:143
Called 609 times
Total time:   0.815945
 Self time:   0.060897

count  total (s)   self (s)
  609              0.001996   let line = ''
  609              0.006573   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
  609              0.000894   else
  609   0.776234   0.021186     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  609              0.005301     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  609              0.004487     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  609              0.002846     let line .= '%#'.a:group.'#'
  609              0.006013   endif
  609              0.001719   return line

FUNCTION  riv#fold#update()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/fold.vim:727
Called 51 times
Total time:   0.131190
 Self time:   0.090275

count  total (s)   self (s)
   51              0.000971     if &filetype!='rst' || &fdm!='expr' || g:riv_fold_auto_update == 0
                                    return
   51              0.000080     endif
   51   0.129974   0.089059     normal! zx

FUNCTION  ale#node#FindExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/node.vim:10
Called 998 times
Total time:   0.492229
 Self time:   0.129312

count  total (s)   self (s)
  998   0.043278   0.016966     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
  998              0.001580     endif
                            
 2994              0.009612     for l:path in a:path_list
 1996   0.352074   0.041859         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
 1996              0.009313         if !empty(l:executable)
                                        return l:executable
 1996              0.003023         endif
 2994              0.005427     endfor
                            
  998   0.041612   0.015222     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  632()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 1 time
Total time:   0.000227
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000090   0.000008     let group = self.get_group(a:i)
    1   0.000086   0.000008     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000005     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000002       let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
    1              0.000001     endif
                            
    1              0.000005     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
    1              0.000001     else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  633()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 3 times
Total time:   0.000253
 Self time:   0.000126

count  total (s)   self (s)
    3              0.000017     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
    3              0.000004     endif
    3   0.000180   0.000053     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000010     if bufnum == bufnr('%')
    3              0.000016       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000004     endif
    3              0.000005     return group

FUNCTION  <SNR>136_Complete()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:965
Called 9389 times
Total time:   4.813985
 Self time:   0.602380

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
 9389              0.100743   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
 6008   0.199757   0.115573     call s:CloseCompletionMenu()
 3381              0.006805   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
 3381   0.110387   0.066553     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
 9389              0.014989   endif
                              " Displaying or hiding the PUM might mean we need to hide the sig help
 9389   4.254706   0.171119   call s:UpdateSignatureHelp()

FUNCTION  riv#link#hi_hover()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/link.vim:326
Called 2077 times
Total time:   2.731256
 Self time:   0.403572

count  total (s)   self (s)
                                
 2077              0.023594     let [row,col] = getpos('.')[1:2]
                            
                                " if col have not move out prev hl region , skip
 2077              0.014179     if !&modified && row == s:hl_row && col >= s:hl_bgn && col <= s:hl_end
                                    return
 2077              0.003391     endif
 2077              0.015508     let [s:hl_row, s:hl_bgn,s:hl_end] = [row, 0 , 0]
                            
 2077              0.014351     let line = getline(row)
 2077   0.577261   0.035674     let idx = s:get_link_idx(line, col)
                                
 2077              0.005163     if idx != -1
 1470   1.455526   0.042154         let obj = riv#ptn#match_object(line, riv#ptn#link_all(), idx)
 1470              0.008531         if !empty(obj) && obj.start < col
   27              0.000129             let bgn = obj.start + 1
   27              0.000143             let end = obj.end
   27              0.000118             if col <= end+1
   21              0.000203                 let [s:hl_row, s:hl_bgn,s:hl_end] = [row, bgn, end]
   21              0.000181                 if !empty(obj.groups[5]) || !empty(obj.groups[6]) 
    8              0.000032                     if !empty(obj.groups[5]) 
                                                    let file = riv#link#path(obj.str)
    8              0.000014                     else
    8              0.000163                         let file = expand(obj.str)
    8              0.000015                     endif
                                                " if link invalid
    8   0.000727   0.000320                     if ( riv#path#is_directory(file) && !isdirectory(file) )  ||( !riv#path#is_directory(file) && !filereadable(file) )
                                                    execute '2match '.g:riv_file_link_invalid_hl.' /\%'.(row).'l\%>'.(bgn-1) .'c\%<'.(end+1).'c/'
                                                    return
    8              0.000012                     endif
   21              0.000033                 endif
   21              0.001804                 execute '2match' "IncSearch".' /\%'.(row).'l\%>'.(bgn-1) .'c\%<'.(end+1).'c/'
   21              0.000041                 return
    6              0.000010             endif
 1443              0.002324         else
 1443   0.404439   0.032121             let [is_in,bgn,end,obj] = riv#todo#col_item(line,col)
 1443              0.004362             if is_in>=2
                                            execute '2match' "DiffAdd".' /\%'.(row).'l\%>'.(bgn-1) .'c\%<'.(end+1).'c/'
                                            return
 1443              0.002218             endif
 1449              0.002119         endif
 2056              0.003031     endif
                            
 2056              0.008808     2match none

FUNCTION  <SNR>139_StopFindTimer()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:28
Called 2077 times
Total time:   0.101365
 Self time:   0.043446

count  total (s)   self (s)
 2077   0.099600   0.041681   call s:GenericStopTimer('s:find_timer')

FUNCTION  airline#extensions#tabline#buflist#clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:10
Called 4 times
Total time:   0.000195
 Self time:   0.000160

count  total (s)   self (s)
    4   0.000100   0.000083   call airline#extensions#tabline#buflist#invalidate()
    4   0.000093   0.000075   call airline#extensions#tabline#buffers#invalidate()

FUNCTION  <SNR>123_TempReadPre()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2105
Called 1 time
Total time:   0.000131
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000103   0.000018   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete nobuflisted
                                setlocal buftype=nowrite
                                if has_key(dict, 'modifiable')
                                  let &l:modifiable = dict.modifiable
                                endif
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
    1              0.000001   endif

FUNCTION  225()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/undo.vim:9
Called 1 time
Total time:   0.005313
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000009   let undo = deepcopy(self)
    1   0.005295   0.000044   call undo._save()
    1              0.000006   return undo

FUNCTION  226()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/undo.vim:15
Called 1 time
Total time:   0.005251
 Self time:   0.005245

count  total (s)   self (s)
    1              0.000444   if undotree().seq_last == 0
                                " if there are no undo history, disable undo feature by setting
                                " 'undolevels' to -1 and restore it.
                                let self.save_undolevels = &l:undolevels
                                let &l:undolevels = -1
    1   0.000048   0.000042   elseif !s:Buffer.is_cmdwin()
                                " command line window doesn't support :wundo.
    1              0.000006     let self.undofile = tempname()
    1              0.004714     execute 'wundo!' self.undofile
                              else
                                let self.is_cmdwin = s:TRUE
    1              0.000003   endif

FUNCTION  227()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/undo.vim:30
Called 1 time
Total time:   0.005476
 Self time:   0.005476

count  total (s)   self (s)
    1              0.000004   if has_key(self, 'save_undolevels')
                                let &l:undolevels = self.save_undolevels
    1              0.000002   endif
    1              0.000022   if has_key(self, 'undofile') && filereadable(self.undofile)
    1              0.005349     silent execute 'rundo' self.undofile
    1              0.000075     call delete(self.undofile)
    1              0.000002   endif
    1              0.000007   if has_key(self, 'is_cmdwin')
                                " XXX: it breaks undo history. AFAIK, there are no way to save and restore
                                " undo history in commandline window.
                                call self.undobreak()
    1              0.000001   endif

FUNCTION  <SNR>105_display_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:102
Called 50 times
Total time:   0.006736
 Self time:   0.004588

count  total (s)   self (s)
   50              0.000318   let name = b:buffer_vcs_config['git'].branch
   50              0.000089   try
   50   0.003637   0.001489     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
   50              0.000226     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
   50              0.000165     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
   50              0.000128     endif
                              catch
   50              0.000119   endtry
                            
   50              0.000134   return name

FUNCTION  <SNR>48_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:194
Called 52 times
Total time:   0.005375
 Self time:   0.001951

count  total (s)   self (s)
   52   0.005335   0.001911   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:180
Called 17002 times
Total time:   1.203641
 Self time:   0.307613

count  total (s)   self (s)
17002   1.195228   0.299200   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  <SNR>241_sort_by()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/List.vim:114
Called 84 times
Total time:   0.094492
 Self time:   0.021702

count  total (s)   self (s)
   84   0.017235   0.016212   let pairs = map(a:list, printf('[v:val, %s]', a:expr))
   84   0.077150   0.005383   return map(s:sort(pairs,      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')

FUNCTION  <SNR>200_sort()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:105
Called 44 times
Total time:   0.024988
 Self time:   0.013777

count  total (s)   self (s)
   44              0.000441   if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
   44              0.000158   endif
   44              0.000152   let s:expr = a:expr
   44   0.023979   0.012768   return sort(a:list, 's:_compare')

FUNCTION  vital#_easymotion#Palette#Capture#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Capture.vim:5
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000019     return map({'extend': '', 'command': ''},  'function("s:" . v:key)')

FUNCTION  vital#incsearch#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/incsearch.vim:28
Called 4 times
Total time:   0.031026
 Self time:   0.000146

count  total (s)   self (s)
    4              0.000015   if !exists('s:V')
    1   0.000026   0.000011     let s:V = s:new(s:plugin_name)
    4              0.000005   endif
    4   0.030963   0.000098   return call(s:V.import, a:000, s:V)

FUNCTION  <SNR>200_sort_by()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:120
Called 44 times
Total time:   0.033169
 Self time:   0.008181

count  total (s)   self (s)
   44              0.005935   let pairs = map(a:list, printf('[v:val, %s]', a:expr))
   44   0.027189   0.002201   return map(s:sort(pairs,      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')

FUNCTION  <SNR>264_make()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/NoInsert.vim:32
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000008 	let module = deepcopy(s:module)
    1              0.000008 	let module.chars = type(a:chars) == type([]) ? a:chars : [a:chars]
    1              0.000002 	return module

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:205
Called 50 times
Total time:   0.012063
 Self time:   0.002252

count  total (s)   self (s)
   50              0.000794     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
   50              0.000509     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
   50   0.010616   0.000805     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>199_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:121
Called 2 times
Total time:   0.000300
 Self time:   0.000147

count  total (s)   self (s)
    2              0.000016 	let default = get(a:, 1, "")
    2              0.000043 	let result = deepcopy(s:base)
    2   0.000230   0.000077 	call result.set(default)
    2              0.000007 	return result

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 9 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    9              0.000040   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    9              0.000013   endif

FUNCTION  <SNR>203_match_key()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:48
Called 12 times
Total time:   0.000829
 Self time:   0.000829

count  total (s)   self (s)
   12              0.000154 	let keys = sort(keys(a:keymapping))
   12              0.000663 	return get(filter(keys, 'stridx(a:key, v:val) == 0'), -1, '')

FUNCTION  <SNR>266_capture_list()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:54
Called 3 times
Total time:   0.001813
 Self time:   0.000387

count  total (s)   self (s)
    3              0.000014 	let mode = get(a:, 1, "")
    3   0.001795   0.000369 	return filter(split(s:capture(mode), "\n"), "s:_keymapping(v:val)")

FUNCTION  <SNR>136_SendKeys()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:694
Called 5444 times
Total time:   0.068677
 Self time:   0.068677

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
 5444              0.045959   call feedkeys( a:keys, 'in' )

FUNCTION  ale#sign#ParseSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:204
Called 50 times
Total time:   0.009009
 Self time:   0.007815

count  total (s)   self (s)
   50   0.001979   0.000785     let l:pattern =ale#sign#ParsePattern()
   50              0.000137     let l:result = []
   50              0.000187     let l:is_dummy_sign_set = 0
                            
  150              0.000443     for l:line in a:line_list
  100              0.002411         let l:match = matchlist(l:line, l:pattern)
                            
  100              0.000393         if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
                                        endif
  100              0.000154         endif
  150              0.000264     endfor
                            
   50              0.000236     return [l:is_dummy_sign_set, l:result]

FUNCTION  vital#_easymotion#Over#Commandline#Modules#History#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:5
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000011     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  vista#()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:139
Called 2 times
Total time:   0.045964
 Self time:   0.000865

count  total (s)   self (s)
                            
    2              0.000095   let [bufnr, winnr, fname, fpath] = [bufnr('%'), winnr(), expand('%'), expand('%:p')]
                            
    2   0.000606   0.000114   call vista#source#Update(bufnr, winnr, fname, fpath)
                            
    2              0.000008   if a:bang
    2              0.000007     if a:0 == 0
                                  call vista#sidebar#Close()
                                  return
    2              0.000007     elseif a:0 == 1
    2              0.000009       if a:1 ==# '!'
    2              0.000017         let t:vista.lnum = line('.')
    2   0.045175   0.000568         call vista#sidebar#Toggle()
    2              0.000005         return
                                  else
                                    return vista#error#Expect('Vista!!')
                                  endif
                                else
                                  return vista#error#Expect('Vista![!]')
                                endif
                              endif
                            
                              if a:0 == 0
                                call vista#sidebar#Open()
                                return
                              endif
                            
                              if a:0 == 1
                                if index(g:vista#executives, a:1) > -1
                                  call vista#executive#{a:1}#Execute(v:false, v:true)
                                  let t:vista.lnum = line('.')
                                elseif a:1 ==# 'finder'
                                  call vista#finder#Dispatch('', '')
                                elseif a:1 ==# 'finder!'
                                  call vista#finder#fzf#ProjectRun()
                                elseif a:1 ==# 'toc'
                                  if vista#SupportToc()
                                    call vista#extension#{&filetype}#Execute(v:false, v:true)
                                  else
                                    return vista#error#For('Vista toc', &filetype)
                                  endif
                                elseif a:1 ==# 'focus'
                                  call vista#sidebar#ToggleFocus()
                                elseif a:1 ==# 'show'
                                  if vista#sidebar#IsVisible()
                                    call vista#cursor#ShowTag()
                                  else
                                    call vista#sidebar#Open()
                                    let t:vista.lnum = line('.')
                                  endif
                                elseif a:1 ==# 'info'
                                  call vista#debugging#Info()
                                elseif a:1 ==# 'info+'
                                  call vista#debugging#InfoToClipboard()
                                else
                                  return vista#error#Expect('Vista [finder] [EXECUTIVE]')
                                endif
                              elseif a:0 == 2
                                if a:1 !=# 'finder'
                                  return vista#error#Expect('Vista finder [EXECUTIVE]')
                                endif
                                let finder_args_reg = '^\('.join(g:vista#finders, '\|').'\):\('.join(g:vista#executives, '\|').'\)$'
                                if stridx(a:2, ':') > -1
                                  if a:2 =~? finder_args_reg
                                    let matched = matchlist(a:2, finder_args_reg)
                                    let finder = matched[1]
                                    let executive = matched[2]
                                  else
                                    return vista#error#Expect('Vista finder [FINDER|EXECUTIVE|FINDER:EXECUTIVE]')
                                  endif
                                else
                                  if index(g:vista#finders, a:2) > -1
                                    let finder = a:2
                                    let executive = ''
                                  elseif index(g:vista#executives, a:2) > -1
                                    let finder = ''
                                    let executive = a:2
                                  else
                                    return vista#error#Expect('Vista finder [FINDER|EXECUTIVE|FINDER:EXECUTIVE]')
                                  endif
                                endif
                                call vista#finder#Dispatch(finder, executive)
                                return
                              else
                                return vista#error#('Too many arguments for Vista')
                              endif

FUNCTION  <SNR>197__function()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:11
Called 9 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    9              0.000048     return function(a:fstr)

FUNCTION  CloseBuffer()
    Defined: ~/.vimrc:424
Called 1 time
Total time:   0.057649
 Self time:   0.000954

count  total (s)   self (s)
                              " Get all loaded buffers
    1              0.000161   let buffers = filter(range(1, bufnr('$')), 'bufloaded(v:val)')
                              " Check if quickfix/location-list exists
    1              0.000004   let flag = 0
    3              0.000009   for i in buffers
    2              0.000018     let btype = getbufvar(i, '&buftype')
    2              0.000012     if btype == 'quickfix' || btype == 'location-list'
                                  let flag = 1
                                  break
    2              0.000003     endif
    3              0.000006   endfor
                              " If quickfix/location-list exists, close them
    1              0.000003   if flag == 1
                                exec 'lclose | cclose'
                              " Otherwise, close the current buffer
    1              0.000002   else
                                " Number of buffers exist
    1              0.000018     let bnum = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))
                                " When there is only one buffer, quit vim
    1              0.000002     if bnum == 1
    1   0.057367   0.000672       exec 'quit'
                                " Otherwise, delete the current buffer
                                else
                                  exec 'bd'
    1              0.000002     endif
    1              0.000002   endif

FUNCTION  <SNR>105_format_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 50 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
   50              0.000165     return a:name

FUNCTION  <SNR>136_ReceiveMessages()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:96
Called 4 times
Total time:   0.009302
 Self time:   0.000383

count  total (s)   self (s)
    4              0.000059   let poll_again = v:false
    4   0.000653   0.000093   if s:AllowedToCompleteInCurrentBuffer()
    4   0.008419   0.000060     let poll_again = s:Pyeval( 'ycm_state.OnPeriodicTick()' )
    4              0.000035   endif
                            
                            
    4              0.000010   if poll_again
    2              0.000059     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    2              0.000002   else
                                " Don't poll again until we open another buffer
    2              0.000010     let s:pollers.receive_messages.id = -1
    4              0.000006   endif

FUNCTION  <SNR>136_RequestSignatureHelp()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:938
Called 5321 times
Total time:   3.359195
 Self time:   0.761178

count  total (s)   self (s)
 5321   1.214356   0.125180   if !s:ShouldUseSignatureHelp()
                                return
 5321              0.015771   endif
                            
 5321              0.460592   exec s:python_command "ycm_state.SendSignatureHelpRequest()"
 5321   1.638670   0.129829   call s:PollSignatureHelp()

FUNCTION  <SNR>136_ClearSignatureHelp()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim:1021
Called 893 times
Total time:   1.073501
 Self time:   0.079817

count  total (s)   self (s)
  893   0.795712   0.018439   if !s:ShouldUseSignatureHelp()
                                return
  893              0.001692   endif
                            
  893              0.019444   call timer_stop( s:pollers.signature_help.id )
  893              0.010648   let s:signature_help = s:default_signature_help
  893   0.239678   0.023267   call s:Pyeval( 'ycm_state.ClearSignatureHelp()' )

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:26
Called 24 times
Total time:   0.003402
 Self time:   0.001066

count  total (s)   self (s)
   24   0.001746   0.000464   let summary = gitgutter#hunk#summary(a:bufnr)
   24              0.000123   let summary[0] += a:count
   24   0.001489   0.000435   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>197_import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:53
Called 37 times
Total time:   0.058143
 Self time:   0.001896

count  total (s)   self (s)
   37              0.000105   let target = {}
   37              0.000115   let functions = []
   37              0.000106   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
   37              0.000064   endfor
   37   0.033509   0.013232   let module = self._import(a:name)
   37              0.000130   if empty(functions)
   37              0.000311     call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
   37              0.000044   endif
   37              0.000093   return target

FUNCTION  vista#SupportToc()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista.vim:28
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return &filetype ==# 'markdown' || &filetype ==# 'rst'

FUNCTION  <SNR>18_SynSet()
    Defined: /usr/share/vim/vim81/syntax/synload.vim:33
Called 3 times
Total time:   0.013412
 Self time:   0.006659

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    3              0.000032   syn clear
    3              0.000023   if exists("b:current_syntax")
                                unlet b:current_syntax
    3              0.000006   endif
                            
    3              0.000018   let s = expand("<amatch>")
    3              0.000027   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    3              0.000009   elseif s == "OFF"
                                let s = ""
    3              0.000005   endif
                            
    3              0.000009   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    6              0.000065     for name in split(s, '\.')
    3   0.012865   0.006112       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    6              0.000160     endfor
    3              0.000005   endif

FUNCTION  vista#parser#ctags#FromJSON()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/parser/ctags.vim:134
Called 11 times
Total time:   0.002089
 Self time:   0.000722

count  total (s)   self (s)
   11              0.000070   if a:line =~# '^ctags'
                                return
   11              0.000013   endif
                            
   11              0.000013   try
   11              0.000131     let line = json_decode(a:line)
                              catch
                                call vista#error#('Fail to decode from JSON: '.a:line.', error: '.v:exception)
                                return
   11              0.000014   endtry
                            
   11   0.000218   0.000133   if vista#ShouldIgnore(line.kind)
                                return
   11              0.000014   endif
                            
   11   0.001437   0.000155   call s:LoadData(a:container, line)
                            

FUNCTION  <SNR>197__import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:158
Called 37 times
Total time:   0.055645
 Self time:   0.007528

count  total (s)   self (s)
   37              0.000204   if has_key(s:loaded, a:name)
    6              0.000114     return copy(s:loaded[a:name])
   31              0.000038   endif
   31   0.029092   0.000425   let module = self._get_module(a:name)
   31              0.000189   if has_key(module, '_vital_created')
    1   0.000065   0.000018     call module._vital_created(module)
   31              0.000045   endif
   31              0.001253   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
   31              0.000176   let s:loaded[a:name] = export_module
   31              0.000134   if has_key(module, '_vital_loaded')
   12              0.000021     try
   12   0.001314   0.000863       call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
   12              0.000019     endtry
   31              0.000046   endif
   31              0.000230   return copy(s:loaded[a:name])

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:227
Called 106 times
Total time:   0.008612
 Self time:   0.003597

count  total (s)   self (s)
  106   0.006765   0.001750   let builder = airline#builder#new(a:context)
  106              0.000515   let builder._build = builder.build
  106              0.000945   call extend(builder, s:prototype, 'force')
  106              0.000232   return builder

FUNCTION  EasyMotion#highlight#delete_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:164
Called 19 times
Total time:   0.001341
 Self time:   0.001341

count  total (s)   self (s)
   19              0.000134     let groups = !empty(a:000) ? a:000 : keys(s:priorities)
   64              0.000187     for group in groups
   61              0.000174         for id in s:h.ids[group]
   16              0.000082             silent! call matchdelete(id)
   61              0.000107         endfor
   45              0.000163         let s:h.ids[group] = []
   64              0.000091     endfor

FUNCTION  airline#extensions#wordcount#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:74
Called 17278 times
Total time:   3.831952
 Self time:   0.830043

count  total (s)   self (s)
17278              0.108154   if get(g:, 'airline#visual_active', 0)
   62   0.022884   0.001861     return s:format_wordcount(s:get_wordcount(1))
17216              0.026985   else
17216              0.116107     if get(b:, 'airline_changedtick', 0) != b:changedtick
 9851   3.152439   0.171553       call s:update_wordcount(0)
 9851              0.053406       let b:airline_changedtick = b:changedtick
17216              0.026730     endif
17216              0.097072     return get(b:, 'airline_wordcount', '')
                              endif

FUNCTION  <SNR>199__split_keystring()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:139
Called 18 times
Total time:   0.000935
 Self time:   0.000935

count  total (s)   self (s)
   18              0.000905 	return split(a:str, s:_engine . '\m\%(' . get(a:, 1, '') . s:_regex . '\)')

FUNCTION  82()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:105
Called 10 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
                            	" 1 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å¶„ÇÇ‰∏äÊõ∏„Åç„Åô„Çã
                            	" 0 „ÅÆÂ†¥Âêà„ÅØÊó¢„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞‰∏äÊõ∏„Åç„Åó„Å™„ÅÑ
   10              0.000060 	let overwrite = get(a:, 1, 1)
   10              0.000037 	if overwrite || self.variables.is_setted == 0
   10              0.000036 		let self.variables.input = a:char
   10              0.000027 		let self.variables.is_setted = 1
   10              0.000017 	endif

FUNCTION  <SNR>147_CreateCountDict()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:5
Called 743 times
Total time:   0.011489
 Self time:   0.011489

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
  743              0.009833     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>48_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:65
Called 28 times
Total time:   0.004237
 Self time:   0.000989

count  total (s)   self (s)
   28   0.004220   0.000972   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:29
Called 1996 times
Total time:   0.309798
 Self time:   0.309798

count  total (s)   self (s)
 1996              0.038703     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
 1996              0.054043     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
 1996              0.184947     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
 1996              0.010423     if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
 1996              0.003334     endif
                            
 1996              0.003948     return ''

FUNCTION  <SNR>283_numbering()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Window.vim:52
Called 1 time
Total time:   0.000040
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000005 	let winnr = get(a:, 1, winnr())
    1              0.000005 	let tabnr = get(a:, 2, tabpagenr())
    1   0.000018   0.000011 	let uniq_nr = s:make_uniq_nr()
    1              0.000009 	call settabwinvar(tabnr, winnr, s:prefix . "_gift_uniq_winnr", uniq_nr)
    1              0.000002 	return uniq_nr

FUNCTION  <SNR>194_SaveValue()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:453
Called 2 times
Total time:   0.000787
 Self time:   0.000212

count  total (s)   self (s)
    2              0.000006     if ! s:current.is_search
                                    call EasyMotion#helper#VarReset('&scrolloff', 0)
    2              0.000002     endif
    2   0.000140   0.000038     call EasyMotion#helper#VarReset('&modified', 0)
    2   0.000107   0.000026     call EasyMotion#helper#VarReset('&modifiable', 1)
    2   0.000103   0.000024     call EasyMotion#helper#VarReset('&readonly', 0)
    2   0.000103   0.000025     call EasyMotion#helper#VarReset('&spell', 0)
    2   0.000113   0.000030     call EasyMotion#helper#VarReset('&virtualedit', '')
                                " if &foldmethod !=# 'expr'
    2   0.000198   0.000046         call EasyMotion#helper#VarReset('&foldmethod', 'manual')
                                " endif

FUNCTION  345()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:353
Called 44 times
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
   44              0.000171 	return self.variables.input_key_stack

FUNCTION  379()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Signals.vim:34
Called 27 times
Total time:   0.000624
 Self time:   0.000624

count  total (s)   self (s)
   27              0.000133 	let self.variables.counter += 1
   27              0.000166 	let slot = { "id" : self.variables.counter, "slot" : a:slot }
   27              0.000147 	call add(self.variables.slots, slot)
   27              0.000056 	return slot

FUNCTION  <SNR>48_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:171
Called 24 times
Total time:   0.001302
 Self time:   0.000403

count  total (s)   self (s)
   24   0.001283   0.000384   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>194_convertRegep()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:559
Called 2 times
Total time:   0.000413
 Self time:   0.000274

count  total (s)   self (s)
                                " 1. regexp
                                " 2. migemo
                                " 3. smartsign
                                " 4. smartcase
    2   0.000079   0.000060     let use_migemo = s:should_use_migemo(a:input)
    2   0.000050   0.000039     let re = use_migemo || s:should_use_regexp() ? a:input : s:escape_regexp_char(a:input)
                            
                                " Convert space to match only start of spaces
    2              0.000005     if re ==# ' '
                                    let re = '\s\+'
    2              0.000007     endif
                            
    2              0.000008     if use_migemo
                                    let re = s:convertMigemo(re)
    2              0.000002     endif
                            
    2   0.000086   0.000039     if s:should_use_smartsign(a:input)
                                    let r = s:convertSmartsign(a:input)
                                    if use_migemo
                                        let re = re . '\m\|' . r
                                    else
                                        let re = r
                                    endif
    2              0.000003     endif
                            
    2   0.000102   0.000040     let case_flag = EasyMotion#helper#should_case_sensitive( a:input, s:current.is_search) ? '\c' : '\C'
    2              0.000007     let re = case_flag . re
    2              0.000004     return re

FUNCTION  riv#ptn#get()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:585
Called 5 times
Total time:   0.000507
 Self time:   0.000507

count  total (s)   self (s)
                                " get the pattern at row and indent > 0
                                
                                " return 0 if find nothhing.
                                " else return the pattern's row
                                
    5              0.000030     let row = prevnonblank(a:row)
                            
    5              0.000027     let save_pos = getpos('.')
                            
                                " XXX
                                " can we use another method without moving cursor.
    5              0.000026     call cursor(row,1)
                            
    9              0.000090     while getline(row) !~ a:ptn && row != 0
    6              0.000024         let idt = indent(row)
    6              0.000012         if idt == 0 
    2              0.000004             let row = 0
    2              0.000004             break
    4              0.000005         endif
    4              0.000029         let idt_ptn = '^\s\{,'.(idt-1).'}\S'
    4              0.000083         let [row, col] = searchpos(idt_ptn, 'b',0,100)
    9              0.000019     endwhile
                                
    5              0.000025     call setpos('.',save_pos)
                            
    5              0.000011     return row

FUNCTION  206()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 8 times
Total time:   0.000970
 Self time:   0.000173

count  total (s)   self (s)
    8              0.000035 	let s:cmdline = a:cmdline
    8   0.000932   0.000135 	call s:doautocmd_user(self.prefix, self.prefix . 'Char')

FUNCTION  <SNR>283__vital_loaded()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Window.vim:15
Called 1 time
Total time:   0.000852
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000849   0.000010 	let s:Tabpage = s:V.import("Gift.Tabpage")

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:138
Called 17139 times
Total time:   0.292351
 Self time:   0.292351

count  total (s)   self (s)
17139              0.124789   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
17139              0.027147   endif
17139              0.055828   return s:has_lawrencium

FUNCTION  AutoPairsInsert()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:198
Called 35 times
Total time:   0.062163
 Self time:   0.050494

count  total (s)   self (s)
   35              0.000175   if !b:autopairs_enabled
                                return a:key
   35              0.000055   end
                            
   35              0.000603   let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
   35   0.004036   0.000842   let [before, after, afterline] = s:getline()
                            
                              " Ignore auto close if prev character is \
   35              0.000206   if before[-1:-1] == '\'
                                return a:key
   35              0.000044   end
                            
                              " check open pairs
  272              0.001164   for [open, close, opt] in b:AutoPairsList
  257   0.011500   0.004238     let ms = s:matchend(before.a:key, open)
  257              0.002951     let m = matchstr(afterline, '^\v\s*\zs\V'.close)
  257              0.000937     if len(ms) > 0
                                  " process the open pair
                                  
                                  " remove inserted pair
                                  " eg: if the pairs include < > and  <!-- --> 
                                  " when <!-- is detected the inserted pair < > should be clean up 
   20              0.000083       let target = ms[1]
   20              0.000068       let openPair = ms[2]
   20              0.000091       if len(openPair) == 1 && m == openPair
    3              0.000004         break
   17              0.000023       end
   17              0.000039       let bs = ''
   17              0.000059       let del = ''
   17              0.000094       while len(before) > len(target)
                                    let found = 0
                                    " delete pair
                                    for [o, c, opt] in b:AutoPairsList
                                      let os = s:matchend(before, o)
                                      if len(os) && len(os[1]) < len(target)
                                        " any text before openPair should not be deleted
                                        continue
                                      end
                                      let cs = s:matchbegin(afterline, c)
                                      if len(os) && len(cs)
                                        let found = 1
                                        let before = os[1]
                                        let afterline = cs[2]
                                        let bs = bs.s:backspace(os[2])
                                        let del = del.s:delete(cs[1])
                                        break
                                      end
                                    endfor
                                    if !found
                                      " delete charactor
                                      let ms = s:matchend(before, '\v.')
                                      if len(ms)
                                        let before = ms[1]
                                        let bs = bs.s:backspace(ms[2])
                                      end
                                    end
   17              0.000027       endwhile
   17   0.000952   0.000422       return bs.del.openPair.close.s:left(close)
  237              0.000375     end
  255              0.000596   endfor
                            
                              " check close pairs
  150              0.000566   for [open, close, opt] in b:AutoPairsList
  139              0.000331     if close == ''
                                  continue
  139              0.000181     end
  139              0.001152     if a:key == g:AutoPairsWildClosedPair || opt['mapclose'] && opt['key'] == a:key
                                  " the close pair is in the same line
   31              0.000375       let m = matchstr(afterline, '^\v\s*\V'.close)
   31              0.000072       if m != ''
    7              0.000089         if before =~ '\V'.open.'\v\s*$' && m[0] =~ '\v\s'
                                      " remove the space we inserted if the text in pairs is blank
                                      return "\<DEL>".s:right(m[1:])
    7              0.000012         else
    7   0.000896   0.000213           return s:right(m)
                                    end
   24              0.000033       end
   24              0.000328       let m = matchstr(after, '^\v\s*\zs\V'.close)
   24              0.000068       if m != ''
                                    if a:key == g:AutoPairsWildClosedPair || opt['multiline']
                                      if b:autopairs_return_pos == line('.') && getline('.') =~ '\v^\s*$'
                                        normal! ddk$
                                      end
                                      call search(m, 'We')
                                      return "\<Right>"
                                    else
                                      break
                                    end
   24              0.000031       end
  132              0.000170     end
  143              0.000218   endfor
                            
                            
                              " Fly Mode, and the key is closed-pairs, search closed-pair and jump
   11              0.000036   if g:AutoPairsFlyMode &&  a:key =~ '\v[\}\]\)]'
                                if search(a:key, 'We')
                                  return "\<Right>"
                                endif
   11              0.000015   endif
                            
   11              0.000026   return a:key

FUNCTION  <SNR>134_SafeSetBufline()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/util.vim:69
Called 1 time
Total time:   0.042079
 Self time:   0.001908

count  total (s)   self (s)
    1   0.000062   0.000016   let lines = s:PrependFpath(a:lines)
                            
    1              0.000003   let bufnr = bufnr('')
    1   0.000016   0.000015   call setbufvar(bufnr, '&readonly', 0)
    1   0.000011   0.000010   call setbufvar(bufnr, '&modifiable', 1)
                            
    1              0.000007   silent 1,$delete _
    1              0.000037   call setline(1, lines)
                            
    1   0.000011   0.000010   call setbufvar(bufnr, '&readonly', 1)
    1   0.000009   0.000008   call setbufvar(bufnr, '&modifiable', 0)
                            
    1   0.000025   0.000014   let filetype = vista#sidebar#WhichFileType()
    1   0.038322   0.000231   call setbufvar(bufnr, '&filetype', filetype)
                            
    1   0.001887   0.000614   call vista#ftplugin#Set()
                              " Reload vista syntax as you may switch between serveral
                              " executives/extensions.
                              "
                              " rst shares the same syntax with vista_markdown.
    1   0.000024   0.000013   if t:vista.source.filetype() ==# 'rst'
    1   0.001647   0.000912     execute 'runtime! syntax/vista_markdown.vim'
                              else
                                execute 'runtime! syntax/'.filetype.'vim'
    1              0.000001   endif

FUNCTION  <SNR>129_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:374
Called 24 times
Total time:   0.008676
 Self time:   0.008676

count  total (s)   self (s)
   24              0.001399   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
   24              0.000125   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
   24              0.000032   endif
                            
   24              0.000174   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
   24              0.000032   endif
                            
   24              0.000159   if getbufvar(a:bufnr, '&endofline')
   24              0.000120     call add(bufcontents, '')
   24              0.000035   endif
                            
   24              0.000141   let fenc = getbufvar(a:bufnr, '&fileencoding')
   24              0.000067   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
   24              0.000035   endif
                            
   24              0.000118   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='Ôªø'.bufcontents[0]
   24              0.000033   endif
                            
   24              0.005580   call writefile(bufcontents, a:file, 'b')

FUNCTION  airline#async#vim_vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:178
Called 87 times
Total time:   0.113372
 Self time:   0.109472

count  total (s)   self (s)
   87              0.000798     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:cmd
   87              0.000146     else
   87              0.020219       let cmd = ['sh', '-c', a:cmd]
   87              0.000234     endif
                            
   87              0.000633     let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
   87              0.001331     let jobs = get(s:clean_jobs, a:vcs, {})
   87              0.000525     if has_key(jobs, a:file)
   37              0.000695       if job_status(get(jobs, a:file)) == 'run'
                                    return
   37              0.000187       elseif has_key(jobs, a:file)
                                    " still running
   37              0.000070         return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
   50              0.000068     endif
   50              0.058281     let id = job_start(cmd, { 'err_io':   'null', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_clean', options)})
   50   0.026055   0.022155     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  <SNR>135_GenericAutoUpdate()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/autocmd.vim:26
Called 1 time
Total time:   0.000027
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000025   0.000010   if vista#ShouldSkip()
    1              0.000001     return
                              endif
                            
                              let [bufnr, winnr, fname] = [a:bufnr, winnr(), expand('%')]
                            
                              call vista#source#Update(bufnr, winnr, fname, a:fpath)
                            
                              call s:ApplyAutoUpdate(a:fpath)

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:523
Called 2894 times
Total time:   0.609517
 Self time:   0.091492

count  total (s)   self (s)
 2894              0.040003     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
 2894   0.565478   0.047453     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>198_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:49
Called 1 time
Total time:   0.000159
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000049 	let result = deepcopy(s:base)
    1   0.000015   0.000011 	call result.set_prompt(get(a:, 1, ":"))
    1   0.000093   0.000008 	call result.connect(result, "_")
    1              0.000002 	return result

FUNCTION  vital#_incsearch#Gift#Tabpage#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Gift/Tabpage.vim:7
Called 1 time
Total time:   0.000085
 Self time:   0.000061

count  total (s)   self (s)
    1   0.000085   0.000061 return map({'uniq_nr': '', 'make_uniq_nr': '', 'numbering': '', 'set_prefix': ''}, "vital#_incsearch#function('<SNR>284_' . v:key)")

FUNCTION  riv#path#file_link_style()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/path.vim:40
Called 1470 times
Total time:   0.083597
 Self time:   0.023066

count  total (s)   self (s)
 1470   0.082115   0.021584     return s:c.p[a:0 ? a:1 : s:id()].file_link_style

FUNCTION  vital#_incsearch#Over#Commandline#Modules#Doautocmd#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/Doautocmd.vim:7
Called 1 time
Total time:   0.000137
 Self time:   0.000096

count  total (s)   self (s)
    1   0.000136   0.000095 return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>260_' . v:key)")

FUNCTION  <SNR>223_doautocmd_user()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:35
Called 36 times
Total time:   0.004562
 Self time:   0.002998

count  total (s)   self (s)
   36              0.000221 	let group =  a:prefix . "-vital-over-commandline-doautocmd-dummy"
   36              0.000190 	if !has_key(s:cache_command, a:prefix)
    1              0.000007 		let s:cache_command[a:prefix] = {}
   36              0.000052 	endif
                            
   36              0.000227 	if !has_key(s:cache_command[a:prefix], a:command)
    6              0.000191 		execute "autocmd " . group			. " User " . a:command." silent! execute ''"
                            
    6              0.000074 		if v:version > 703 || v:version == 703 && has("patch438")
    6              0.000068 			let s:cache_command[a:prefix][a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:prefix][a:command] = "doautocmd User " . a:command
    6              0.000010 		endif
   36              0.000043 	endif
                            
   36   0.002543   0.000979 	execute s:cache_command[a:prefix][a:command]

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 17056 times
Total time:   0.398944
 Self time:   0.398944

count  total (s)   self (s)
17056              0.209662   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
17056              0.166607     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#tabline#tabs#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:24
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000029   let s:current_bufnr = -1

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:295
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004     let l:clear_tempdir = 0
                            
    1              0.000006     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    1              0.000002     endif
                            
    1              0.000001     try
    1              0.000005         let l:name = tempname() " no-custom-checks
    1              0.000002     finally
    1              0.000003         if l:clear_tempdir
                                        let $TMPDIR = ''
    1              0.000001         endif
    1              0.000002     endtry
                            
    1              0.000003     return l:name

FUNCTION  <SNR>157_DescendantsOf()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:122
Called 1 time
Total time:   0.000227
 Self time:   0.000162

count  total (s)   self (s)
    1   0.000224   0.000159   let candidates = filter(copy(a:candidates), 'has_key(v:val, ''scope'')'. ' && s:StartWith(v:val.scope, a:scope)'. ' && v:val.scopeKind ==# a:root_line.kind'. ' && v:val.line >= a:root_line.line' )
                            
    1              0.000002   return candidates
                              " The real parent problem seemingly has been solved?
                              " return filter(candidates, 's:RealParentOf(v:val) ==# a:root_line')

FUNCTION  EasyMotion#highlight#capture()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:199
Called 4 times
Total time:   0.000977
 Self time:   0.000969

count  total (s)   self (s)
                                " Based On: https://github.com/t9md/vim-ezbar
                                "           https://github.com/osyo-manga/vital-over
    4              0.000014     let hlname = a:hlname
    4              0.000167     if !hlexists(hlname)
                                    return
    4              0.000006     endif
    4              0.000008     while 1
    4              0.000013         let save_verbose = &verbose
    4   0.000031   0.000027         let &verbose = 0
    4              0.000005         try
    4              0.000021             redir => HL_SAVE
    4              0.000186             execute 'silent! highlight ' . hlname
    4              0.000017             redir END
    4              0.000008         finally
    4   0.000045   0.000041             let &verbose = save_verbose
    4              0.000021         endtry
    4              0.000059         if !empty(matchstr(HL_SAVE, 'xxx cleared$'))
                                        return ''
    4              0.000006         endif
                                    " follow highlight link
    4              0.000048         let ml = matchlist(HL_SAVE, 'links to \zs.*')
    4              0.000012         if !empty(ml)
                                        let hlname = ml[0]
                                        continue
    4              0.000006         endif
    4              0.000007         break
    4              0.000010     endwhile
    4              0.000216     let HL_SAVE = substitute(matchstr(HL_SAVE, 'xxx \zs.*'), '[ \t\n]\+', ' ', 'g')
    4              0.000013     return [hlname, HL_SAVE]

FUNCTION  <SNR>190_EscapeSignText()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:72
Called 5 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    5              0.000065     return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')

FUNCTION  vital#_incsearch#Over#Commandline#Maker#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Maker.vim:7
Called 1 time
Total time:   0.000143
 Self time:   0.000102

count  total (s)   self (s)
    1   0.000143   0.000102 return map({'plain': '', '_vital_depends': '', 'standard_search': '', 'standard': '', 'standard_search_back': '', 'default': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>238_' . v:key)")

FUNCTION  364()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/String.vim:41
Called 70 times
Total time:   0.000528
 Self time:   0.000528

count  total (s)   self (s)
   70              0.000482 	return join(self.list, "")

FUNCTION  <SNR>105_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 17052 times
Total time:  18.040769
 Self time:   1.203309

count  total (s)   self (s)
17052   0.579827   0.273369   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
17052              0.024199   endif
                            
17052  16.568350   0.381468   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
17052   0.659927   0.315807   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
17052              0.025992   endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:63
Called 17052 times
Total time:   9.034331
 Self time:   4.230091

count  total (s)   self (s)
17052              0.105628   if !get(w:, 'airline_active', 0)
                                return ''
17052              0.025275   endif
                              " Cache values, so that it isn't called too often
17052   0.696134   0.547293   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
17052              0.027891   endif
17052   3.591456   0.356125   let hunks = airline#extensions#hunks#get_raw_hunks()
17052              0.046104   let string = ''
17052   0.420617   0.297184   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
17052              0.062520   if !empty(hunks)
68008              0.184534     for i in [0, 1, 2]
51006   1.836751   0.854083       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
51006              0.607186         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
51006              0.082063       endif
68008              0.118475     endfor
17052              0.025734   endif
17052              0.071753   let b:airline_hunks = string
17052              0.092621   let b:airline_changenr = b:changedtick
17052   0.587119   0.273152   let s:airline_winwidth = airline#util#winwidth()
17052              0.050372   return string

FUNCTION  <SNR>157_Append()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/renderer/default.vim:42
Called 1 time
Total time:   0.000122
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003   let line = a:line
    1              0.000002   let rows = a:rows
                            
    1   0.000109   0.000012   let row = s:Assemble(line, a:depth)
                            
    1              0.000004   call add(rows, row)
    1              0.000004   call add(s:vlnum_cache, line)

FUNCTION  vista#ftplugin#Set()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/ftplugin.vim:12
Called 1 time
Total time:   0.001135
 Self time:   0.000742

count  total (s)   self (s)
    1   0.000644   0.000266   setlocal nonumber norelativenumber nopaste nomodeline noswapfile nocursorline nocursorcolumn colorcolumn= nobuflisted buftype=nofile bufhidden=hide nomodifiable signcolumn=no textwidth=0 nolist winfixwidth winfixheight nospell nofoldenable foldcolumn=0 nowrap
                            
    1   0.000009   0.000007   setlocal foldmethod=expr
    1              0.000006   setlocal foldexpr=vista#fold#Expr()
    1   0.000008   0.000007   setlocal foldtext=vista#fold#Text()
                            
    1   0.000030   0.000018   if !vista#statusline#ShouldDisable()
                                let &l:statusline = vista#statusline#()
    1              0.000002   endif
                            
    1              0.000053   nnoremap <buffer> <silent> q    :close<CR>
    1              0.000025   nnoremap <buffer> <silent> <CR> :<c-u>call vista#cursor#FoldOrJump()<CR>
    1              0.000020   nnoremap <buffer> <silent> s    :<c-u>call vista#Sort()<CR>
    1              0.000021   nnoremap <buffer> <silent> p    :<c-u>call vista#cursor#TogglePreview()<CR>
                            
    1              0.000006   augroup VistaCursor
    1              0.000218     autocmd!
    1              0.000010     if get(g:, 'vista_echo_cursor', 1)
    1              0.000012       autocmd CursorMoved <buffer> call vista#cursor#ShowDetailWithDelay()
    1              0.000001     endif
    1              0.000006     autocmd BufLeave <buffer> call vista#floating#Close()
    1              0.000002   augroup END
                            
    1              0.000007   if !exists('#VistaMOF')
                                call vista#autocmd#InitMOF()
    1              0.000001   endif

FUNCTION  <SNR>139_ShowDetail()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/cursor.vim:232
Called 2 times
Total time:   0.001828
 Self time:   0.000615

count  total (s)   self (s)
    2   0.000429   0.000049   let [tag, source_line] = s:GetInfoUnderCursor()
                            
    2              0.000051   if empty(tag) || empty(source_line)
    1              0.000320     echo "\r"
    1              0.000003     return
    1              0.000002   endif
                            
    1              0.000009   let strategy = get(g:, 'vista_echo_cursor_strategy', 'echo')
                            
    1   0.000071   0.000021   let msg = vista#util#Truncate(source_line)
    1   0.000045   0.000018   let lnum = s:GetTrailingLnum()
                            
    1              0.000013   if strategy ==# s:echo_cursor_opts[0]
    1   0.000608   0.000027     call s:EchoInCmdline(msg, tag)
                              elseif strategy ==# s:echo_cursor_opts[1]
                                call s:DisplayInFloatingWin(lnum, tag)
                              elseif strategy ==# s:echo_cursor_opts[2]
                                call s:PeekInSourceFile(lnum, tag)
                              elseif strategy ==# s:echo_cursor_opts[3]
                                call s:EchoInCmdline(msg, tag)
                                if s:has_floating_win
                                  call s:DisplayInFloatingWin(lnum, tag)
                                else
                                  call s:PeekInSourceFile(lnum, tag)
                                endif
                              else
                                call vista#error#InvalidOption('g:vista_echo_cursor_strategy', s:echo_cursor_opts)
    1              0.000001   endif
                            
    1   0.000213   0.000038   call s:ApplyHighlight(line('.'), v:false, tag)

FUNCTION  vital#_easymotion#Data#List#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:5
Called 1 time
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
    1              0.000228     return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>149_LoadData()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/parser/ctags.vim:13
Called 11 times
Total time:   0.001282
 Self time:   0.000938

count  total (s)   self (s)
   11              0.000028   let line = a:line
                            
   11              0.000028   let kind = line.kind
                            
   11   0.000301   0.000121   call s:Insert(t:vista.raw_by_kind, kind, line)
                            
   11              0.000041   call add(t:vista.raw, line)
                            
   11              0.000037   if has_key(line, 'scope')
   10              0.000033     call add(t:vista.with_scope, line)
    1              0.000001   else
    1              0.000004     call add(t:vista.without_scope, line)
   11              0.000011   endif
                            
   11              0.000049   let picked = {'lnum': line.line, 'text': line.name }
                            
   11              0.000064   if kind =~# '^f' || kind =~# '^m'
                                if has_key(line, 'signature')
                                  let picked.signature = line.signature
                                endif
                                call add(t:vista.functions, picked)
   11              0.000014   endif
                            
   11              0.000051   if index(t:vista.kinds, kind) == -1
    4              0.000016     call add(t:vista.kinds, kind)
   11              0.000014   endif
                            
   11   0.000331   0.000167   call s:Insert(a:container, kind, picked)

FUNCTION  vital#_incsearch#Data#Dict#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Data/Dict.vim:7
Called 1 time
Total time:   0.000377
 Self time:   0.000260

count  total (s)   self (s)
    1   0.000376   0.000259 return map({'_vital_depends': '', 'clear': '', 'max_by': '', 'foldl': '', 'pick': '', 'from_list': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': '', '_vital_loaded': ''}, "vital#_incsearch#function('<SNR>280_' . v:key)")

FUNCTION  riv#ptn#get_WORD_idx()
    Defined: ~/.vim/plugged/riv.vim/autoload/riv/ptn.vim:69
Called 2074 times
Total time:   0.129148
 Self time:   0.129148

count  total (s)   self (s)
                                " if cursor is in a WORD ,return it's idx , else return -1
 2074              0.014291     let ptn = printf('\%%%dc.', a:col)
 2074              0.050290     if matchstr(a:line, ptn)=~'\S'
 1467              0.056309         return match(a:line, '\S*'.ptn)
  607              0.001060     else
  607              0.001375         return -1
                                endif

FUNCTION  <SNR>266_parse_lhs_list()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Palette/Keymapping.vim:80
Called 3 times
Total time:   0.003237
 Self time:   0.000472

count  total (s)   self (s)
    3              0.000016 	let mode = get(a:, 1, "")
    3   0.003219   0.000454 	return map(s:capture_list(mode), "s:parse_lhs(v:val, mode)")

FUNCTION  <SNR>123_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:94
Called 51162 times
Total time:   0.703385
 Self time:   0.703385

count  total (s)   self (s)
51162              0.251967   if exists('+shellslash')
                                return tr(a:path, '\', '/')
51162              0.084636   else
51162              0.138154     return a:path
                              endif

FUNCTION  144()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:74
Called 8 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    8              0.000017 	return self.col

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:108
Called 17276 times
Total time:   6.371114
 Self time:   0.419701

count  total (s)   self (s)
17276   6.359000   0.407587   return airline#extensions#ale#get('warning')

FUNCTION  <SNR>127_on_exit_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:84
Called 24 times
Total time:   0.099604
 Self time:   0.002378

count  total (s)   self (s)
   24              0.000194   let job = ch_getjob(a:channel)
   24              0.000067   while 1
   24              0.000446     if job_status(job) == 'dead'
   24              0.000345       let exit_code = job_info(job).exitval
   24              0.000058       break
                                endif
                                sleep 5m
   24              0.000054   endwhile
                            
   24              0.000059   if !exit_code
   24   0.098144   0.000918     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   24              0.000032   endif

FUNCTION  146()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:84
Called 16 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
   16              0.000057 	return len(self.list)

FUNCTION  <SNR>149_Insert()
    Defined: ~/.vim/plugged/vista.vim/autoload/vista/parser/ctags.vim:5
Called 22 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
   22              0.000091   if has_key(a:container, a:kind)
   14              0.000070     call add(a:container[a:kind], a:picked)
    8              0.000009   else
    8              0.000052     let a:container[a:kind] = [a:picked]
   22              0.000029   endif

FUNCTION  <SNR>38_init()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:12
Called 9 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    9              0.000036   if s:airline_initialized
    9              0.000016     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  <SNR>231__searchforward_cmd()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/incsearch.vim:349
Called 3 times
Total time:   0.000287
 Self time:   0.000101

count  total (s)   self (s)
    3   0.000254   0.000068   let d = (g:incsearch#consistent_n_direction ? s:DIRECTION.forward : (incsearch#cli()._base_key is# '/' ? 1 : 0))
    3              0.000030   return printf(":\<C-u>let v:searchforward=%d\<CR>", d)

FUNCTION  EasyMotion#highlight#turn_on()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:237
Called 4 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
    4              0.000023     if type(a:hl) != type([])
                                    return
    4              0.000005     endif
    4              0.000263     execute 'highlight ' . a:hl[0] . ' ' . a:hl[1]

FUNCTION  ToggleMouse()
    Defined: ~/.vimrc:355
Called 4 times
Total time:   0.000186
 Self time:   0.000174

count  total (s)   self (s)
                                " check if mouse is enabled
    4              0.000035     if &mouse == 'n'
                                    " disable mouse
    2   0.000075   0.000066         set mouse=
    2              0.000003     else
                                    " enable mouse everywhere
    2   0.000043   0.000040         set mouse=n
    4              0.000007     endif

FUNCTION  vital#_incsearch#Over#Commandline#Modules#History#import()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Modules/History.vim:7
Called 1 time
Total time:   0.000030
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000029   0.000022 return map({'make': ''}, "vital#_incsearch#function('<SNR>263_' . v:key)")

FUNCTION  <SNR>123_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:308
Called 17054 times
Total time:   2.429953
 Self time:   0.281741

count  total (s)   self (s)
17054   2.416995   0.268783   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  <SNR>164_IsBoolean()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:75
Called 20 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
   20              0.000275     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  ale#sign#ReadSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:170
Called 50 times
Total time:   0.004375
 Self time:   0.003505

count  total (s)   self (s)
   50              0.000391     redir => l:output
   50   0.003099   0.002229         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
   50              0.000274     redir end
                            
   50              0.000509     return split(l:output, "\n")

FUNCTION  <SNR>205_parse_to_name()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:52
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000011 	return matchstr(a:highlight, '^\zs\w\+\ze')

FUNCTION  airline#extensions#tabline#add_tab_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:246
Called 106 times
Total time:   0.002612
 Self time:   0.002612

count  total (s)   self (s)
  106              0.000940   if get(g:, 'airline#extensions#tabline#show_tab_count', 1) && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
  106              0.000178   endif

FUNCTION  <SNR>106_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 17059 times
Total time:   0.137966
 Self time:   0.137966

count  total (s)   self (s)
17059              0.125129   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  350()
    Defined: ~/.vim/plugged/incsearch.vim/autoload/vital/_incsearch/Over/Commandline/Base.vim:382
Called 3 times
Total time:   0.000395
 Self time:   0.000194

count  total (s)   self (s)
    3              0.000010 	let self.variables.tap_key = ""
    3              0.000008 	let self.variables.char = ""
    3              0.000008 	let self.variables.input = ""
    3              0.000006 	let self.variables.exit = 0
    3              0.000009 	let self.variables.exit_code = 1
    3              0.000009 	let self.variables.enable_keymapping = 1
    3              0.000010 	let self.variables.input_key_stack = []
    3   0.000325   0.000124 	let self.line = deepcopy(s:String.make())

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:232
Called 122 times
Total time:   0.005749
 Self time:   0.005749

count  total (s)   self (s)
  122              0.001938   let builder = copy(s:prototype)
  122              0.000540   let builder._context = a:context
  122              0.000500   let builder._sections = []
                            
  122              0.002190   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
  122              0.000283   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
25254969 5662.826055 1402.916628  <SNR>136_PollSignatureHelp()
50592046 3898.286359             <SNR>136_Pyeval()
25285650 3417.285289 386.080071  <SNR>136_ShouldUseSignatureHelp()
 5594  43.754740   2.008755  <SNR>136_OnTextChangedInsertMode()
17283  37.485985   4.156444  airline#check_mode()
  541  32.853456   4.345666  airline#highlighter#highlight()
17052  30.278775   1.486058  airline#extensions#branch#get_head()
17052  27.665831   1.142815  airline#extensions#branch#head()
17052  22.809995   2.013744  <SNR>105_update_branch()
16612  20.098362   1.804582  <SNR>101_exec_separator()
67585  18.275381   8.961868  airline#highlighter#get_highlight()
17052  18.040769   1.203309  <SNR>105_update_git_branch()
33371  17.325792   4.566578  airline#highlighter#exec()
17052  16.186882   0.654048  FugitiveHead()
17052  14.847859   1.963135  fugitive#Head()
 5321  13.886073   7.316182  <SNR>136_RequestCompletion()
24467  13.223997   1.326615  <SNR>136_UpdateSignatureHelp()
17054  12.886205   8.527022  fugitive#Find()
 5594  12.243446   0.262270  <SNR>136_InsideCommentOrStringAndShouldStop()
 5594  11.981176             <SNR>136_InsideCommentOrString()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
50592046            3898.286359  <SNR>136_Pyeval()
25254969 5662.826055 1402.916628  <SNR>136_PollSignatureHelp()
25285650 3417.285289 386.080071  <SNR>136_ShouldUseSignatureHelp()
 5594             11.981176  <SNR>136_InsideCommentOrString()
67585  18.275381   8.961868  airline#highlighter#get_highlight()
17054  12.886205   8.527022  fugitive#Find()
135170              8.269474  <SNR>101_get_syn()
 5321  13.886073   7.316182  <SNR>136_RequestCompletion()
34552  11.687624   5.691740  airline#extensions#ale#get()
   51              5.515602  riv#debug()
33371  17.325792   4.566578  airline#highlighter#exec()
13762              4.544641  <SNR>67_Highlight_Matching_Pair()
17276   5.717670   4.488121  airline#extensions#whitespace#check()
  541  32.853456   4.345666  airline#highlighter#highlight()
17052   9.034331   4.230091  airline#extensions#hunks#get_hunks()
16042              4.215353  UltiSnips#TrackChange()
17283  37.485985   4.156444  airline#check_mode()
196029              3.881811  airline#util#winwidth()
 6379              3.858799  <SNR>116_map_keys()
17052   3.706025   2.959467  <SNR>105_update_untracked()

