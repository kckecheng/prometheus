#!/usr/bin/env python
'''
A script to push vdbench output to pushgateway

Requirements:
    - Python3
    - pometheus_client: pip install prometheus_client

Notices:
    - Has only verified the script on Linux
'''
from prometheus_client import CollectorRegistry, Gauge, push_to_gateway, delete_from_gateway
import argparse
import re
import signal
import socket
import subprocess
import sys


def sig_handler(signum, frame):
    global gateway
    global job
    if gateway and job:
        print(f"Delete job {job} from pushgateway {gateway}")
        delete_from_gateway(gateway, job=job)
    print("Exit program execution")
    sys.exit(1)


def args_parse():
    '''
    Parse command line arguments
    '''
    parser = argparse.ArgumentParser(
        usage=(
            "push vdbench output to prometheus gateway"
            "\n\n\t./vdbench_pusher -n job1 -i raw -p localhost:8080 <vdbench options ...>\n\n"
            "\tGet Help: ./vdbench_pusher -h\n\n"
        )
    )
    parser.add_argument("-n", "--name", default="raw", help='job name, "job1" as default')
    parser.add_argument(
        "-i",
        "--io",
        required=True,
        choices=["raw", "filesystem", "fs"],
        help="vdbench I/O type(raw/filesystem(fs for short))",
    )
    parser.add_argument(
        "-p",
        "--pushgateway",
        required=True,
        help='Prometheus pushgateway address in format "x.x.x.x:xxxx"',
    )
    parser.add_argument(
        "-s",
        "--src",
        default=socket.gethostname(),
        help="The source where the script is run, FQDN is recommended. The hostname is used as default.",
    )
    #  return parser.parse_args()
    return parser.parse_known_args()


def metrics_init(job_type='raw'):
    raw = [
        "io_rate",
        "mb_ps",
        "bytes",
        "read_pct",
        "resp_time",
        "read_resp",
        "write_resp",
        "read_max",
        "write_max",
        "resp_stddev",
        "q_depth",
        "cpu_total",
        "cpu_sys",
    ]
    fs = [
        "req_std_ops_rate",
        "req_std_ops_resp",
        "cpu_total",
        "cpu_sys",
        "read_pct",
        "read_rate",
        "read_resp",
        "write_rate",
        "write_resp",
        "read_mb_ps",
        "write_mb_ps",
        "total_mb_ps",
        "xfer_size",
        "mkdir_rate",
        "mkdir_resp",
        "rmdir_rate",
        "rmdir_resp",
        "create_rate",
        "create_resp",
        "open_rate",
        "open_resp",
        "close_rate",
        "close_resp",
        "delete_rate",
        "delete_resp",
    ]

    names = None
    if job_type == 'raw':
        names = raw
    else:
        names = fs

    registry = CollectorRegistry()
    metrics = {}
    for name in names:
        metrics.update({name: Gauge(name, name.replace("_", " "), ["src", "io_type"], registry=registry,)})
    return (names, metrics, registry)


if __name__ == '__main__':
    # Capture Ctrl-C
    signal.signal(signal.SIGINT, sig_handler)
    # Capture kill
    signal.signal(signal.SIGTERM, sig_handler)
    (gw_args, vdbench_args) = args_parse()
    gateway = f'http://{gw_args.pushgateway}'
    job = gw_args.name

    cmd = vdbench_args.copy()
    os_type = sys.platform
    if os_type == 'linux':
        cmd.insert(0, r"./vdbench")
    elif os_type.startswith('win'):
        cmd.insert(0, r".\vdbench.bat")
    else:
        print(f"Unsupported OS type {os_type}")
        sys.exit(1)

    names, metrics, registry = metrics_init(gw_args.io)
    pattern = r"^\d\d:\d\d:\d\d\.\d\d\d\s+?\d+?\s+?\d+?\.\d+?.*?\d+?\.\d+?$"
    with subprocess.Popen(cmd, stdout=subprocess.PIPE) as proc:
        for line in proc.stdout:
            line = line.decode().rstrip("\r\n")
            print(line)
            if re.match(pattern, line):
                data = line.split()[2:]
                for (name, value) in zip(names, data):
                    metrics.get(name).labels(src=gw_args.src, io_type=gw_args.io).set(value)
                push_to_gateway(gateway, job=job, registry=registry)
    # Delete the job once it is done
    delete_from_gateway(gateway, job=job)
